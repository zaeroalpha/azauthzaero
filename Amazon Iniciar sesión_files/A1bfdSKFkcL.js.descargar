////////////////////////////////////////////
;(function (packageFunction) {
  /* istanbul ignore next */
  var p = window.AmazonUIPageJS || window.P;
  /* istanbul ignore next */
  var attribute = p._namespace || p.attributeErrors;
  /* istanbul ignore next */
  var namespacedP = attribute ? attribute("ACICAssets", "") : p;

  /* istanbul ignore next */
  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET ACICAssets-1.0.17481.0
/////////////////////////
// BEGIN FILE js/acic.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsAggregator = void 0;
var MetricsAggregator = /** @class */ (function () {
    function MetricsAggregator(filterFunction) {
        var _this = this;
        this.filterFunction = filterFunction;
        this.aggregatedMetrics = {};
        window.addEventListener('katal.metrics.publish', function (event) {
            _this.aggregateMetric(event);
        });
    }
    MetricsAggregator.prototype.aggregateMetric = function (event) {
        var _a = event.detail, metric = _a.metric, context = _a.context;
        var serviceName = context.serviceName, methodName = context.methodName;
        if (this.filterFunction && !this.filterFunction(metric, context)) {
            return;
        }
        this.aggregatedMetrics[serviceName] =
            this.aggregatedMetrics[serviceName] || {};
        this.aggregatedMetrics[serviceName][methodName] =
            this.aggregatedMetrics[serviceName][methodName] || {};
        this.aggregatedMetrics[serviceName][methodName][metric.name] =
            this.aggregatedMetrics[serviceName][methodName][metric.name] || [];
        this.aggregatedMetrics[serviceName][methodName][metric.name].push(metric.value);
    };
    return MetricsAggregator;
}());
exports.MetricsAggregator = MetricsAggregator;
//# sourceMappingURL=metrics-aggregator.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Level = void 0;
var promise_polyfill_1 = __importDefault(__webpack_require__(/*! promise-polyfill */ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js"));
var stacktrace_js_1 = __importDefault(__webpack_require__(/*! stacktrace-js */ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js"));
var katal_metrics_1 = __webpack_require__(/*! ./metrics/katal-metrics */ "./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js");
var metrics_aggregator_1 = __webpack_require__(/*! ./helper/metrics-aggregator */ "./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js");
var Level;
(function (Level) {
    Level["DEBUG"] = "debug";
    Level["INFO"] = "info";
    Level["WARN"] = "warn";
    Level["ERROR"] = "error";
    Level["FATAL"] = "fatal";
})(Level = exports.Level || (exports.Level = {}));
var LOG_LEVELS = [
    Level.DEBUG,
    Level.INFO,
    Level.WARN,
    Level.ERROR,
    Level.FATAL,
];
var DEFAULT_MAX_LOG_LINE_SIZE = 10000; // 10 kilobytes default
var DEFAULT_BATCH_TIMEOUT_DURATION = 5000;
var DEFAULT_MAX_LOGS_PER_BATCH = 25;
var CONFIG_DEFAULTS = {
    logThreshold: Level.DEBUG,
    maxLogLineSize: DEFAULT_MAX_LOG_LINE_SIZE,
    batchTimeoutDuration: DEFAULT_BATCH_TIMEOUT_DURATION,
    decodeStackTrace: false,
    recordMetrics: true,
    context: {},
    headers: {},
    logToConsole: false,
    maxLogsPerBatch: DEFAULT_MAX_LOGS_PER_BATCH,
    useXMLHttpRequest: false,
};
// obtained from https://developer.mozilla.org/en-US/docs/Web/API/Event
var EVENT_PROPERTIES = [
    'bubbles',
    'cancelBubble',
    'cancelable',
    'composed',
    'currentTarget',
    'deepPath',
    'defaultPrevented',
    'eventPhase',
    'explicitOriginalTarget',
    'originalTarget',
    'returnValue',
    'srcElement',
    'target',
    'timeStamp',
    'type',
    'isTrusted',
];
var ERROR_EVENT_PROPERTIES = __spreadArrays(EVENT_PROPERTIES, ['message']);
var KatalLogger = /** @class */ (function () {
    /**
     * Construct a KatalLogger
     *
     * @param config
     */
    function KatalLogger(config) {
        var _this = this;
        this.resourceTimingLogged = false;
        this.sendLogsToBackend = function () {
            var logsToSend = _this.logLineQueue;
            if (logsToSend.length === 0) {
                return;
            }
            _this.logLineQueue = [];
            _this.currentLogBatchSize = 0;
            var logs = {
                logs: logsToSend,
            };
            _this.sendLogToBackend(_this.toJSON(logs));
            _this.queueTimerId = undefined;
        };
        var configWithDefaults = __assign(__assign({}, CONFIG_DEFAULTS), config);
        this.url = configWithDefaults.url;
        this.logThreshold = configWithDefaults.logThreshold;
        this.maxLogLineSize = configWithDefaults.maxLogLineSize;
        this.context = configWithDefaults.context;
        this.logToConsole = configWithDefaults.logToConsole;
        this.headers = configWithDefaults.headers;
        this.recordMetrics = configWithDefaults.recordMetrics;
        this.batchTimeoutDuration = configWithDefaults.batchTimeoutDuration;
        this.decodeStackTrace = configWithDefaults.decodeStackTrace;
        this.maxLogsPerBatch = configWithDefaults.maxLogsPerBatch;
        this.maxLogBatchSize =
            config.maxLogBatchSize || this.maxLogLineSize * this.maxLogsPerBatch;
        this.currentLogBatchSize = 0;
        this.xhrWithCredentials = configWithDefaults.xhrWithCredentials;
        this.useXMLHttpRequest = configWithDefaults.useXMLHttpRequest;
        this.logLineQueue = [];
        this.unregisterFns = [];
        this.unloaded = false;
        this.logThresholdIndex = Math.max(LOG_LEVELS.indexOf(Level.DEBUG), LOG_LEVELS.indexOf(this.logThreshold));
        if (this.maxLogBatchSize < this.maxLogLineSize) {
            throw new Error("maxLogBatchSize(" + this.maxLogBatchSize + ") must be greater than maxLogLineSize(" + this.maxLogLineSize + ")");
        }
        if (configWithDefaults.sendToBackendOverride &&
            typeof configWithDefaults.sendToBackendOverride === 'function') {
            this.sendLogToBackend = configWithDefaults.sendToBackendOverride;
        }
        if (this.recordMetrics) {
            this.metricsPublisher = katal_metrics_1.createMetricsPublisher('KatalLogger:Loaded');
            this.metricsPublisher.publishCounterMonitor('KatalLogger:construct', 1);
        }
        this.registerUnloadAction(function () {
            _this.unloaded = true;
            _this.sendLogsToBackend();
        });
        /**
         * Set this.unloaded to false to continue queueing the logs
         */
        this.registerBackToPageAction(function () {
            _this.unloaded = false;
        });
    }
    /**
     * Cover all of the unload cases:
     * https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/
     */
    KatalLogger.prototype.registerUnloadAction = function (callback) {
        this.registerEvent('pagehide', callback);
        this.registerEvent('beforeunload', callback);
        this.registerEvent('visibilitychange', function () {
            if (document.visibilityState === 'hidden') {
                callback();
            }
        });
    };
    /**
     * Check if the user comes back to the page
     * https://t.corp.amazon.com/D69927460
     */
    KatalLogger.prototype.registerBackToPageAction = function (callback) {
        this.registerEvent('pageshow', callback);
        this.registerEvent('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                callback();
            }
        });
    };
    /**
     * Log a copy of Katal Metrics emitted on this page
     * @param filterFunction: an optional function to filter metrics before publishing
     */
    KatalLogger.prototype.addMetricsListener = function (filterFunction) {
        var _this = this;
        var aggregator = new metrics_aggregator_1.MetricsAggregator(filterFunction);
        var unloadedAlready = false;
        this.registerUnloadAction(function () {
            if (unloadedAlready)
                return;
            unloadedAlready = true;
            _this.info('Katal Metrics', aggregator.aggregatedMetrics);
        });
    };
    /**
     * Adds a formatted version of Performance API logs.
     * Uses https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries
     * to determine resource and paint timings.
     */
    KatalLogger.prototype.addPerformanceListener = function () {
        var _this = this;
        this.registerUnloadAction(function () {
            _this.logResourceTiming();
        });
    };
    KatalLogger.prototype.logResourceTiming = function () {
        var _a, _b;
        if (this.resourceTimingLogged) {
            return;
        }
        this.resourceTimingLogged = true;
        var resource = window.performance
            .getEntriesByType('resource')
            .reduce(function (acc, resourceTiming) {
            var _a;
            var _b = resourceTiming, name = _b.name, initiatorType = _b.initiatorType, duration = _b.duration;
            var resource = name.split('/').pop();
            acc[initiatorType] = (_a = acc[initiatorType]) !== null && _a !== void 0 ? _a : {};
            acc[initiatorType][resource] = Math.round(duration);
            return acc;
        }, {});
        var paint = window.performance
            .getEntriesByType('paint')
            .reduce(function (acc, _a) {
            var name = _a.name, startTime = _a.startTime;
            acc[name] = Math.round(startTime);
            return acc;
        }, {});
        var navigation = Object.entries((_b = (_a = window.performance.getEntriesByType('navigation')[0]) === null || _a === void 0 ? void 0 : _a.toJSON()) !== null && _b !== void 0 ? _b : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            acc[key] = typeof value === 'number' ? Math.round(value) : value;
            return acc;
        }, {});
        this.info("Performance Timing", { resource: resource, paint: paint, navigation: navigation });
    };
    /**
     * Adds an event listener for errors. Will log the error if the filter callback returns true
     *
     * @param filterCallback function that takes an error object and returns whether it should be logged
     */
    KatalLogger.prototype.addErrorListener = function (filterCallback) {
        var _this = this;
        ['error', 'unhandledrejection'].map(function (listener) {
            _this.registerEvent(listener, 
            /* istanbul ignore next - this.eventListener tested seperately */
            function (e) {
                return _this.eventListener(e, filterCallback);
            }, true);
        });
    };
    /**
     * Removes the registered error event listeners
     * Normal applications need not call this.
     * This is required for multitenant SPAs to avoid memory leaks.
     */
    KatalLogger.prototype.removeErrorListener = function () {
        this.unregisterFns.forEach(function (fn) { return fn(); });
    };
    KatalLogger.prototype.registerEvent = function (event, cb, capture) {
        window.addEventListener(event, cb, capture);
        this.unregisterFns.push(function () {
            window.removeEventListener(event, cb, capture);
        });
    };
    KatalLogger.prototype.eventListener = function (e, filterCallback) {
        var errorMessage;
        var error;
        // e is an ErrorEvent
        if (e.error) {
            errorMessage = e.error.message;
            error = e.error;
        }
        // e is PromiseRejectionEvent
        else if (e.reason) {
            if (isError(e.reason)) {
                errorMessage = e.reason.message;
                error = e.reason;
            }
            else {
                errorMessage = e.reason;
            }
        }
        else if (isError(e)) {
            errorMessage = e.message;
            error = e;
        }
        else {
            errorMessage = "An unknown error occurred: " + this.toStringObject(e);
            // Capture a stack trace
            error = new Error('Unknown error');
        }
        if (errorMessage !== 'KatalLogger error' &&
            (!filterCallback || filterCallback(error))) {
            try {
                return this.error(errorMessage, error);
            }
            catch (_) {
                // Prevent infinite loops by swallowing errors that occur while logging errors
            }
        }
    };
    KatalLogger.prototype.createJsonStringifyReplacer = function () {
        var cache = new Map();
        return function (key, value) {
            if (typeof value === 'object' && value != null) {
                if (cache.has(value)) {
                    return "reference-loop, also referenced from '" + cache.get(value) + "'";
                }
                cache.set(value, key);
            }
            return value;
        };
    };
    /**
     * Event objects are hard to serialize (see https://stackoverflow.com/questions/11547672/how-to-stringify-event-object) so we need a helper method
     */
    KatalLogger.prototype.toStringObject = function (object) {
        var constructorName = object.constructor.name;
        if (object instanceof Event) {
            var objectProperties = EVENT_PROPERTIES;
            var eventObject = {};
            /** if error event, we need to capture the error message */
            if (object instanceof ErrorEvent) {
                objectProperties = ERROR_EVENT_PROPERTIES;
            }
            for (var _i = 0, objectProperties_1 = objectProperties; _i < objectProperties_1.length; _i++) {
                var prop = objectProperties_1[_i];
                /** ignore serializing and logging the entire window log
                 */
                if (object[prop] !== window) {
                    eventObject[prop] = object[prop];
                }
            }
            object = eventObject;
        }
        return constructorName + ':' + this.toJSON(object);
    };
    /**
     * JSON.stringify can throw but we really don't want to error when logging error
     * so use our own error-safe serialization
     */
    KatalLogger.prototype.toJSON = function (data) {
        var stringified;
        try {
            stringified = JSON.stringify(data, this.createJsonStringifyReplacer());
        }
        catch (error) {
            stringified = "{ \"KatalLogger\": \"Failed to serialize!\", \"data\": \"" + data + "\", \"error\": \"" + error + "\" }";
        }
        return stringified;
    };
    KatalLogger.prototype.debug = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.DEBUG, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.info = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.INFO, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.warn = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.WARN, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.error = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.ERROR, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.fatal = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.FATAL, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.extractArgs = function (level, message, error, context) {
        var errorInfo = isError(error)
            ? {
                errorMessage: error.message,
                errorName: error.name,
                errorStackTrace: '',
            }
            : undefined;
        var logPayload = {
            level: level,
            message: message,
            error: errorInfo,
            context: __assign(__assign(__assign({}, this.context), (errorInfo ? context : error)), { logTime: Date.now() }),
        };
        if (logPayload.error) {
            return this.getStackTraceFromError(error).then(function (trace) {
                logPayload.error.errorStackTrace = trace;
                return logPayload;
            });
        }
        return promise_polyfill_1.default.resolve(logPayload);
    };
    KatalLogger.prototype.getStackTraceFromError = function (error) {
        if (!this.decodeStackTrace) {
            return promise_polyfill_1.default.resolve(String(error.stack));
        }
        return promise_polyfill_1.default.resolve(stacktrace_js_1.default.fromError(error)
            .then(function (stackframes) {
            return stackframes.map(function (sf) { return sf.toString(); }).join('\n');
        })
            .catch(function (err) {
            // we failed to decode it, just output raw
            return String(error.stack) +
                '\n\nFailed to decode stacktrace:\n' +
                String(err);
        }));
    };
    KatalLogger.prototype.sendRequest = function (payload) {
        this.queueLogLine(payload);
        if (this.logToConsole) {
            this.sendLogToConsole(payload);
        }
    };
    KatalLogger.prototype.sendLogToConsole = function (data) {
        var level = data.level;
        if (!LOG_LEVELS.includes(data.level) || data.level === Level.FATAL) {
            level = Level.ERROR;
        }
        console[level](data);
    };
    KatalLogger.prototype.queueLogLine = function (payload) {
        if (this.payloadIsValid(payload)) {
            var payloadSize = this.getPayloadSize(payload);
            if (this.currentLogBatchSize + payloadSize > this.maxLogBatchSize) {
                this.sendLogsToBackend();
            }
            this.appendToQueue(payload);
            this.currentLogBatchSize += payloadSize;
            if (this.unloaded || this.logLineQueue.length >= this.maxLogsPerBatch) {
                this.sendLogsToBackend();
            }
            else if (!this.queueTimerId) {
                this.queueTimerId = window.setTimeout(this.sendLogsToBackend, this.batchTimeoutDuration);
            }
        }
    };
    KatalLogger.prototype.appendToQueue = function (payload) {
        this.logLineQueue.push(payload);
    };
    KatalLogger.prototype.doCallBeacon = function () {
        return ((navigator === null || navigator === void 0 ? void 0 : navigator.sendBeacon) &&
            !(Object.keys(this.headers).length || this.useXMLHttpRequest));
    };
    KatalLogger.prototype.sendLogToBackend = function (dataString) {
        if (this.url) {
            if (this.doCallBeacon()) {
                navigator.sendBeacon(this.url, dataString);
            }
            else {
                var xhr_1 = new XMLHttpRequest();
                // xhr request is set to async.
                // In case this needs to be changed to sync, it should be noted that xhr.withCredentials with sync request is not supported since Firefox 11.
                // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#browser_compatibility
                xhr_1.open('POST', this.url, true);
                if (this.xhrWithCredentials) {
                    xhr_1.withCredentials = this.xhrWithCredentials;
                }
                Object.entries(this.headers).forEach(function (_a) {
                    var headerName = _a[0], headerValue = _a[1];
                    xhr_1.setRequestHeader(headerName, headerValue);
                });
                xhr_1.send(dataString);
            }
        }
    };
    KatalLogger.prototype.payloadIsValid = function (data) {
        var a = LOG_LEVELS.indexOf(data.level);
        var b = this.logThresholdIndex;
        var passesLogLevelCheck = a >= b;
        if (passesLogLevelCheck) {
            var payloadSize = this.getPayloadSize(data);
            if (payloadSize <= this.maxLogLineSize) {
                return true;
            }
        }
        return false;
    };
    KatalLogger.prototype.getPayloadSize = function (data) {
        var dataString = this.toJSON(data);
        return dataString.length;
    };
    return KatalLogger;
}());
exports.default = KatalLogger;
function isError(object) {
    /* istanbul ignore next - in node (unit tests) there is no error.constructor. In ie, there is no error.stack */
    return ((object === null || object === void 0 ? void 0 : object.name) && object.message && (object.stack || !!object.constructor));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* istanbul ignore file */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMetricsPublisher = void 0;
var metrics_publisher_singleton_1 = __webpack_require__(/*! ./metrics-publisher-singleton */ "./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js");
exports.createMetricsPublisher = function (methodName) {
    return metrics_publisher_singleton_1.MetricsPublisherSingleton.getInstance().newChildActionPublisherForMethod(methodName);
};
//# sourceMappingURL=katal-metrics.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsPublisherSingleton = void 0;
var KatalMetrics = __importStar(__webpack_require__(/*! @amzn/katal-metrics */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js"));
var katal_metrics_driver_sushi_1 = __importDefault(__webpack_require__(/*! @amzn/katal-metrics-driver-sushi */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js"));
var MetricsPublisherSingleton = /** @class */ (function () {
    /* istanbul ignore next - Private constructor to prevent initializing the singleton */
    function MetricsPublisherSingleton() {
    }
    MetricsPublisherSingleton.getInstance = function () {
        if (!MetricsPublisherSingleton.instance) {
            /* istanbul ignore next - This is invoked by the metrics driver */
            var metricsErrorHandler = function (err) {
                console.error(err);
            };
            var metricsDriver = this.getMetricsDriver(metricsErrorHandler);
            var metricsContext = this.getMetricsContext();
            MetricsPublisherSingleton.instance = new KatalMetrics.Publisher(metricsDriver, metricsErrorHandler, metricsContext);
        }
        return MetricsPublisherSingleton.instance;
    };
    MetricsPublisherSingleton.getMetricsContext = function () {
        var urlMatch = /([^?]+)/.exec(window.location.href);
        var urlMetric = new KatalMetrics.Metric.String('url', 
        /* istanbul ignore next - This is invoked by the metrics context */
        urlMatch ? urlMatch[1] : window.location.href);
        urlMetric.truncate = true;
        return new KatalMetrics.Context.Builder()
            .withSite('KatalLoggerInternalMetrics')
            .withServiceName('KatalLogger')
            .addRelatedMetrics(urlMetric)
            .build();
    };
    MetricsPublisherSingleton.getMetricsDriver = function (metricsErrorHandler) {
        return new katal_metrics_driver_sushi_1.default.Builder()
            .withDomainRealm('prod', 'USAmazon')
            .withErrorHandler(metricsErrorHandler)
            .build();
    };
    return MetricsPublisherSingleton;
}());
exports.MetricsPublisherSingleton = MetricsPublisherSingleton;
//# sourceMappingURL=metrics-publisher-singleton.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KatalMetricsDriverSushi = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricsDriver2 = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/metricObject/KatalMetricType */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

var _katalSushiClient = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-sushi-client */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js"));

var _temp;

var KAT_STANDALONE_NEXUS_PRODUCER_ID = 'katal';
var KAT_STANDALONE_DEFAULT_SOURCE_GROUPS = {
  test: 'com.amazon.eel.katal.metrics.core.nexus.gamma',
  prod: 'com.amazon.eel.katal.metrics.core.nexus'
};

var KatalMetricsDriverSushi =
/*#__PURE__*/
function (_KatalMetricsDriver) {
  (0, _inherits2.default)(KatalMetricsDriverSushi, _KatalMetricsDriver);

  function KatalMetricsDriverSushi(options) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushi);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricsDriverSushi).call(this));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sushi", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "producerId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sourceGroupId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "errorHandler", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "combinedErrorHandler", function (err) {
      if (_this.errorHandler) {
        try {
          _this.errorHandler(err); // Return to avoid falling through to default error handler


          return;
        } catch (nextErr) {
          console.error("Error handling error publishing metrics:");
          console.error(nextErr); // Fall through
        }
      }

      _this.defaultErrorHandler(err);
    });
    var domain = options.domain,
        realm = options.realm,
        errorHandler = options.errorHandler,
        sushiClient = options.sushiClient,
        _options$sushiProduce = options.sushiProducer,
        producerId = _options$sushiProduce === void 0 ? KAT_STANDALONE_NEXUS_PRODUCER_ID : _options$sushiProduce,
        sushiClientOptions = options.sushiClientOptions,
        sushiClientTransportOverride = options.sushiClientTransportOverride; // custom source group always overrides defaults

    var sourceGroupId = options.sourceGroupId || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS[domain] || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS['test'];
    _this.sushi = sushiClient || _this.buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride);
    _this.errorHandler = errorHandler;
    _this.producerId = producerId;
    _this.sourceGroupId = sourceGroupId;
    return _this;
  }

  (0, _createClass2.default)(KatalMetricsDriverSushi, [{
    key: "beforeUnload",

    /**
     * Register a callback to be called right before the page unloads. This
     * allows for any final metrics, such as page visit duration, to be sent
     * before the user navigates away from the page or closes the tab.
     * NOTE: This is an experimental API and may change in the future.
     * @param cb The callback to call.
     */
    value: function beforeUnload(cb) {
      this.sushi.onSushiUnload(cb);
    }
    /**
     * Default error handler if the user-supplied error handler fails or is unset.  Should never be called unless
     * user-provided error handler misbehaves.
     *
     * @param err Unhandled error object
     */

  }, {
    key: "defaultErrorHandler",
    value: function defaultErrorHandler(err) {
      console.error("Error publishing metrics:");
      console.error(err);
    }
    /**
     * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
     * an exception, calls the default error handler as a fallback, which will just log the error to the console.
     *
     * @param err Error object to handle
     */

  }, {
    key: "withErrorHandling",

    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    value: function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
  }, {
    key: "buildSushiClient",
    value: function buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride) {
      if (!domain || !realm) {
        throw new Error('KatalMetricsDriverSushi requires a domain and realm to build a sushi client.');
      }

      return new _katalSushiClient.default(KatalMetricsDriverSushi.getRealmName(realm), sourceGroupId, this.combinedErrorHandler, sushiClientOptions, sushiClientTransportOverride);
    }
  }, {
    key: "publish",
    // TODO: errorHandler in this method is deprecated and is not referenced.
    // Tech debt: https://issues.amazon.com/issues/KAT-875
    value: function publish(metricObject, errorHandler, context) {
      var _this2 = this;

      // Support for new 2-argument form of publish, which does not pass the unused errorHandler object (KAT-875)
      var metricsContext = arguments.length < 3 ? arguments[1] : arguments[2];
      this.withErrorHandling(function () {
        // TODO: This logic is now moved into KatalMetricsPublisher, once everybody has that update we can remove this.
        // Tech debt: https://issues.amazon.com/issues/KAT-876
        if (_KatalMetricType.default.List === metricObject.type) {
          metricObject.metricList.forEach(function (metric) {
            _this2.publish(metric, metricsContext);
          });
          return;
        }

        var nexusSchema = _this2.mapObjectTypeToNexusSchema(metricObject.type);

        var fields = (0, _objectSpread2.default)({}, metricsContext.context, {
          metricKey: metricObject.name,
          value: metricObject.value
        });

        if (metricObject.isMonitor) {
          fields.isMonitor = true;
        } // Reset the event count back to 0, otherwise Sushi will stop publishing after 1K items (https://issues.amazon.com/issues/KAT-1534)


        _this2.sushi.reset();

        _this2.sushi.event(fields, _this2.producerId, nexusSchema, {
          "ssd": 1
        });
      });
    }
  }, {
    key: "mapObjectTypeToNexusSchema",
    value: function mapObjectTypeToNexusSchema(objectType) {
      switch (objectType) {
        case _KatalMetricType.default.String:
          return 'katal.client.metrics.String.2';

        case _KatalMetricType.default.Counter:
          return 'katal.client.metrics.Counter.3';

        case _KatalMetricType.default.Timer:
          return 'katal.client.metrics.Timer.2';

        default:
          throw new Error("Unknown type ".concat(objectType, " when publishing metric object."));
      }
    }
  }], [{
    key: "getRealmName",
    value: function getRealmName(realm) {
      switch (realm) {
        case 'NAAmazon':
        case 'USAmazon':
          return _katalSushiClient.default.REGIONS.NA;

        case 'EUAmazon':
          return _katalSushiClient.default.REGIONS.EU;

        case 'FEAmazon':
        case 'JPAmazon':
          return _katalSushiClient.default.REGIONS.FE;

        case 'CNAmazon':
          return _katalSushiClient.default.REGIONS.CN;

        default:
          // Let the SushiClient decide if this is bogus or not.
          return realm;
      }
    }
  }]);
  return KatalMetricsDriverSushi;
}(_KatalMetricsDriver2.default);

exports.KatalMetricsDriverSushi = KatalMetricsDriverSushi;
(0, _defineProperty2.default)(KatalMetricsDriverSushi, "Builder", (_temp =
/*#__PURE__*/
function () {
  function _temp() {
    (0, _classCallCheck2.default)(this, _temp);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_temp, [{
    key: "withSushiClient",
    value: function withSushiClient(sushiClient) {
      this.context.sushiClient = sushiClient;
      return this;
    }
  }, {
    key: "withDomainRealm",
    value: function withDomainRealm(domain, realm) {
      this.context.domain = domain;
      this.context.realm = realm;
      return this;
    }
  }, {
    key: "withCustomProducer",
    value: function withCustomProducer(sushiProducerId) {
      this.context.sushiProducer = sushiProducerId;
      return this;
    }
  }, {
    key: "withCustomSourceGroup",
    value: function withCustomSourceGroup(sourceGroupId) {
      this.context.sourceGroupId = sourceGroupId;
      return this;
    }
  }, {
    key: "withErrorHandler",
    value: function withErrorHandler(errorHandler) {
      this.context.errorHandler = errorHandler;
      return this;
    }
  }, {
    key: "withSushiClientOptions",
    value: function withSushiClientOptions(sushiClientOptions) {
      this.context.sushiClientOptions = sushiClientOptions;
      return this;
    }
  }, {
    key: "withSushiClientTransportOverride",
    value: function withSushiClientTransportOverride(sushiClientTransportOverride) {
      this.context.sushiClientTransportOverride = sushiClientTransportOverride;
      return this;
    }
  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsDriverSushi(this.context);
    }
  }]);
  return _temp;
}(), _temp));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! ./nodejsShims */ 0);

var _KatalMetricsDriverSushi = __webpack_require__(/*! ./KatalMetricsDriverSushi */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js");

/* istanbul ignore file */
var _default = _KatalMetricsDriverSushi.KatalMetricsDriverSushi;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ./helper/ValidateSimpleString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./helper/FirstMap */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var _temp;

var REQUIRED_FIELDS = ['site', 'serviceName', 'methodName'];

var KatalMetricsContext =
/*#__PURE__*/
function () {
  /**
   * Create a new metrics context with the given fields.
   *
   * @param contextFields Context fields value (default empty)
   */
  function KatalMetricsContext() {
    var contextFields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, KatalMetricsContext);
    // Copy fields so this is immutable
    this.context = (0, _objectSpread2.default)({}, contextFields);
  }
  /**
   * Return a new KatalMetricsContext which is a copy of this context, with values added or overridden from
   * the given context.
   *
   * If the given context is null or empty, this method may return the original object as an optimization.
   *
   * @param thatContext Context to merge values from
   * @return New context with default values from this context, and values overridden or added by the given context.
   */


  (0, _createClass2.default)(KatalMetricsContext, [{
    key: "merge",
    value: function merge(thatContext) {
      if (!thatContext) return this; // Check for a common error

      if (thatContext instanceof KatalMetricsContext.Builder) {
        throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
      }

      var context = thatContext instanceof KatalMetricsContext ? thatContext.context : thatContext;
      var newContext = (0, _objectSpread2.default)({}, this.context, context, {
        relatedMetrics: (0, _mergeLists.mergeLists)(this.context.relatedMetrics, context.relatedMetrics),
        relatedMetricsSingleAction: (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, context.relatedMetricsSingleAction)
      });
      return new KatalMetricsContext(newContext);
    }
    /**
     * Return a new context which is a copy of this context with relatedMetricsSingleAction removed.
     *
     * This is intended to be called when creating a new child publisher.
     *
     * @return Copy of this context, with relatedMetricsSingleAction removed
     */

  }, {
    key: "withoutRelatedMetricsSingleAction",
    value: function withoutRelatedMetricsSingleAction() {
      return new KatalMetricsContext((0, _objectSpread2.default)({}, this.context, {
        relatedMetricsSingleAction: undefined
      }));
    }
    /**
     * Get a context suitable for publication to the driver.
     *
     * This method strips out any private fields, and leaves only fields from the schema that the driver should publish.
     *
     * @return Context suitable for driver publication
     */

  }, {
    key: "driverContext",
    value: function driverContext() {
      // Don't publish relatedMetrics to the driver
      var newContextFields = (0, _objectSpread2.default)({}, this.context);
      delete newContextFields["relatedMetrics"];
      delete newContextFields["relatedMetricsSingleAction"];
      delete newContextFields["requestId"];

      if (this.context.requestId) {
        newContextFields.actionId = (0, _embedRequestId.embedRequestId)(newContextFields.actionId, this.context.requestId);
      }

      return new KatalMetricsContext(newContextFields);
    }
    /**
     * Get a simple JavaScript object with a copy of the fields for this context.
     *
     * @return Simple Javascript object with a copy of the fields for this context
     */

  }, {
    key: "getFields",
    value: function getFields() {
      // Copy fields so this remains immutable
      return (0, _objectSpread2.default)({}, this.context);
    }
    /**
     * Check for a validation error on this context.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns Errors found with this context
     */

  }, {
    key: "validationError",
    value: function validationError() {
      var _this = this;

      var err; // Fields “site”, “serviceName”, “methodName”, and “metricKey” are required.

      err = (0, _FirstMap.default)(REQUIRED_FIELDS, function (field) {
        if (_this.context[field] == undefined) {
          return new Error("Field ".concat(field, " is required, but it is ").concat(_this.context[field]));
        }
      });
      if (err) return err;
      return (0, _FirstMap.default)(Object.keys(this.context), function (field) {
        return _this.validateField(field);
      });
    }
    /**
     * Validate an individual context field.
     *
     * @param field Name of field to validate
     * @returns Error found with this field, or undefined
     */

  }, {
    key: "validateField",
    value: function validateField(field) {
      var val = this.context[field];
      var nameForError = "field ".concat(field);

      switch (field) {
        // Strings which could be used as partition keys ("site" and "serviceName") cannot contain slashes, in
        // addition to the other restictions below.
        case 'site':
        case 'serviceName':
          if (val.indexOf('/') > -1) return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It cannot contain a slash."));
        // Else fall through
        // Strings for fields “site”, “serviceName”, “methodName”, “metricKey” must match be valid PMET field names:
        // maximum length of 256, only letters, numbers, and the dot, colon, at-sign, underscore, forward-slash,
        // and slash characters (in short the regex ^[A-Za-z0-9.:@_/-]+$).

        case 'methodName':
        case 'actionId':
          return (0, _ValidateSimpleString.default)(val, nameForError);
      } // No error found, implicitly return undefined

    }
    /**
     * Builder class for KatalMetricsContext
     */

  }]);
  return KatalMetricsContext;
}();

exports.default = KatalMetricsContext;
(0, _defineProperty2.default)(KatalMetricsContext, "Builder", (_temp =
/*#__PURE__*/
function () {
  function _temp() {
    (0, _classCallCheck2.default)(this, _temp);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_temp, [{
    key: "withSite",
    value: function withSite(site) {
      this.context.site = site;
      return this;
    }
  }, {
    key: "withServiceName",
    value: function withServiceName(serviceName) {
      this.context.serviceName = serviceName;
      return this;
    }
  }, {
    key: "withMethodName",
    value: function withMethodName(methodName) {
      this.context.methodName = methodName;
      return this;
    }
  }, {
    key: "withActionId",
    value: function withActionId(actionId) {
      this.context.actionId = actionId;
      return this;
    }
  }, {
    key: "withRequestId",
    value: function withRequestId(requestId) {
      this.context.requestId = requestId;
      return this;
    }
    /**
     * Replace any related metrics with the given list (see addRelatedMetrics to add instead of replace).
     *
     * Related metrics are metrics that are published whenever a new action is started.  They are used to relate the
     * action back to the context where it is happening, for example a request ID or a user identity.
     *
     * @param relatedMetrics Related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetrics",
    value: function withRelatedMetrics() {
      for (var _len = arguments.length, relatedMetrics = new Array(_len), _key = 0; _key < _len; _key++) {
        relatedMetrics[_key] = arguments[_key];
      }

      this.context.relatedMetrics = relatedMetrics;
      return this;
    }
    /**
     * Add additional related metrics to this builder.  See withRelatedMetrics for more information.
     *
     * @param relatedMetrics Additional related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetrics",
    value: function addRelatedMetrics() {
      for (var _len2 = arguments.length, relatedMetrics = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        relatedMetrics[_key2] = arguments[_key2];
      }

      this.context.relatedMetrics = (0, _mergeLists.mergeLists)(this.context.relatedMetrics, relatedMetrics);
      return this;
    }
    /**
     * Replace single-action related metrics with the given list (see addRelatedMetricsSingleAction to add instead of replace,
     * and withRelatedMetrics for more information about related metrics).
     *
     * Single-action related metrics are published when a new child metric publisher is created, but not included as
     * related metrics for the new child metric publisher, so are not published again if the child metric publisher
     * creates grandchild published metrics.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetricsSingleAction",
    value: function withRelatedMetricsSingleAction() {
      for (var _len3 = arguments.length, metrics = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        metrics[_key3] = arguments[_key3];
      }

      this.context.relatedMetricsSingleAction = metrics;
      return this;
    }
    /**
     * Add additional single-action related metrics to this builder.  See addRelatedMetricsSingleAction for more information.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetricsSingleAction",
    value: function addRelatedMetricsSingleAction() {
      for (var _len4 = arguments.length, metrics = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        metrics[_key4] = arguments[_key4];
      }

      this.context.relatedMetricsSingleAction = (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, metrics);
      return this;
    }
    /**
     * Take the fields set in this builder and use them to create a new KatalMetricsContext.
     *
     * @return KatalMetricsContext object built with the parameters given to this builder
     */

  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsContext(this.context);
    }
  }]);
  return _temp;
}(), _temp));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _v = _interopRequireDefault(__webpack_require__(/*! uuid/v4 */ "./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./metricObject/KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var KatalMetrics = _interopRequireWildcard(__webpack_require__(/*! . */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./metricObject/KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _metricsExtension = __webpack_require__(/*! ./helper/metricsExtension */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var INITIALIZATION_METHOD_NAME = 'Initialization';

/**
 * Default error handler if the user-supplied error handler fails or is unset.
 * Should never be called unless user-provided error handler misbehaves.
 */
var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  console.error("Error publishing metrics:");
  console.error(err);
};

var PARENT_ACTION_ID_NAME = 'parentActionId';

var getContextFields = function getContextFields(context) {
  if (context.context) {
    return context.context;
  } else {
    return context;
  }
};
/**
 * Class used for publishing metrics to Katal.  Contains a driver and a context.
 *
 * This class knows how to publish metrics, and how to create new publishers with a modified context.
 */


var KatalMetricsPublisher =
/*#__PURE__*/
function () {
  /**
   * Create a new metrics publisher with the given driver and context
   *
   * @param driver Subclass of KatalMetricsDriver used to publish the metrics
   * @param errorHandler Handler for errors that occur while using this publisher
   * @param context Context for this metrics publisher; contains data to be included with every
   *     metric published using this publisher object.  Default is an empty context.
   */
  function KatalMetricsPublisher(driver) {
    var _this = this;

    var errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ERROR_HANDLER;
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _KatalMetricsContext.default();
    (0, _classCallCheck2.default)(this, KatalMetricsPublisher);
    (0, _defineProperty2.default)(this, "combinedErrorHandler", function (err) {
      try {
        _this.errorHandler(err);
      } catch (nextErr) {
        console.error("Error handling error publishing metrics:");
        console.error(nextErr);
        DEFAULT_ERROR_HANDLER(err);
      }
    });

    // Check for a common error
    if (context instanceof _KatalMetricsContext.default.Builder) {
      throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
    }

    this.driver = driver;
    this.errorHandler = errorHandler;
    this.context = !(context instanceof _KatalMetricsContext.default) ? new _KatalMetricsContext.default(context) : context;
  }
  /**
   * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
   * an exception, calls the default error handler as a fallback, which will just log the error to the console.
   *
   * @param err Error object to handle
   */


  (0, _createClass2.default)(KatalMetricsPublisher, [{
    key: "withErrorHandling",

    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    value: function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
    /**
     * Helper method to return all the related metrics of base publisher and additionalContext.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @return Return all related metrics from base publisher and additionalContext.
     */

  }, {
    key: "getAdditionalRelatedMetrics",
    value: function getAdditionalRelatedMetrics(additionalContext) {
      var newContext = additionalContext instanceof _KatalMetricsContext.default ? additionalContext.context : additionalContext;
      var baseRelatedMetrics = this.getBaseRelatedMetrics();
      return (0, _mergeLists.mergeLists)(baseRelatedMetrics, newContext.relatedMetrics);
    }
    /**
     * Helper method to return all the related metrics of base publisher.
     *
     * @return Return all related metrics from the base publisher.
     */

  }, {
    key: "getBaseRelatedMetrics",
    value: function getBaseRelatedMetrics() {
      return (0, _mergeLists.mergeLists)(this.context.context.relatedMetrics, this.context.context.relatedMetricsSingleAction);
    }
    /**
     * Publish the given metric object.
     *
     * This method is guaranteed never to throw an exception.  If the metric object or context are invalid,
     * or any other exception is thrown while publishing, the publisher's error handler is called.  If the
     * publisher's error handler is unset or fails, the default error handler is called (see defaultErrorHandler).
     *
     * @param katalMetricObject Metric object to publish
     */

  }, {
    key: "publish",
    value: function publish(katalMetricObject) {
      var _this2 = this;

      this.withErrorHandling(function () {
        if (!katalMetricObject) {
          throw new Error("Cannot publish undefined/null metric object");
        }

        if (_KatalMetricObject.default.Types.List === katalMetricObject.type) {
          katalMetricObject.metricList.forEach(function (metric) {
            _this2.publish(metric);
          });
        } else {
          var driverContext = _this2.context.driverContext();

          var contextError = driverContext.validationError();
          if (contextError) throw contextError;
          var objectError = katalMetricObject.validationError();
          if (objectError) throw objectError;
          (0, _metricsExtension.dispatchMetricEvent)(katalMetricObject, driverContext);

          _this2.driver.publish(katalMetricObject, _this2.combinedErrorHandler, driverContext);
        }
      });
    }
    /**
     * Create a new publisher which is identical to this publisher, but with the given context fields merged into
     * the new publisher's context.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildPublisher",
    value: function newChildPublisher(additionalContext) {
      return new KatalMetricsPublisher(this.driver, this.errorHandler, this.context.merge(additionalContext));
    }
    /**
     * Begin a new action, and return a new publisher for metrics related to that action.
     *
     * Beginning a new action involves the following steps:
     *   1. Generate a new actionId for the action, randomly in the browser
     *   2. If there are any related metrics in the context, publish them
     *   3. Create and return a new publisher with this object's context, merged with any additional context given,
     *      merged with the actionId generated above.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisher",
    value: function newChildActionPublisher(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var newContext = this.context.withoutRelatedMetricsSingleAction().merge({
        actionId: actionId
      }).merge(additionalContext);
      var newPublisher = new KatalMetricsPublisher(this.driver, this.errorHandler, newContext);
      var allRelatedMetrics = additionalContext && !(additionalContext instanceof _KatalMetricsContext.default.Builder) ? this.getAdditionalRelatedMetrics(additionalContext) : this.getBaseRelatedMetrics();

      if (allRelatedMetrics) {
        allRelatedMetrics.forEach(function (metric) {
          newPublisher.publish(metric);
        });
      }

      return newPublisher;
    }
    /**
     * Begin a new chained child action, and return a new publisher for metrics related to that action.
     *
     * A chained action is handled the same way as in newChildActionPublisher, but additionally,
     * the returned publisher has a relatedMetricNoInherit named "parentActionId", with the newly
     * generated actionId as its value.
     *
     * The effect of this is that any further chained child actions can be connected back to this
     * action through the parentActionId, and so on recursively.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChained",
    value: function newChildActionPublisherChained(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var parentActionId = (0, _embedRequestId.embedRequestId)(actionId, this.context.context.requestId);
      var relatedMetricsSingleAction = [new _KatalMetricString.default(PARENT_ACTION_ID_NAME, parentActionId)];
      var newContext = new _KatalMetricsContext.default({
        actionId: actionId,
        relatedMetricsSingleAction: relatedMetricsSingleAction
      }).merge(additionalContext);
      return this.newChildActionPublisher(newContext);
    }
    /**
     * Helper method to create a new chained child action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherChained.
     *
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChainedForMethod",
    value: function newChildActionPublisherChainedForMethod(methodName, additionalContext) {
      return this.newChildActionPublisherChained(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherForMethod.
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForMethod",
    value: function newChildActionPublisherForMethod(methodName, additionalContext) {
      return this.newChildActionPublisher(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action for application initialization.  It will always have a methodName
     * of "Initialization"; otherwise this method is identical to newChildActionPublisherForMethod.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForInitialization",
    value: function newChildActionPublisherForInitialization(additionalContext) {
      return this.newChildActionPublisherForMethod(INITIALIZATION_METHOD_NAME, additionalContext);
    }
    /**
     * Helper method to publish a string with the given name and value.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishString",
    value: function publishString(name, value) {
      this.publish(new KatalMetrics.Metric.String(name, value));
    }
    /**
     * Helper method to publish a string with the given name and value, truncated to the maximum size allowed by the
     * schema.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishStringTruncate",
    value: function publishStringTruncate(name, value) {
      var object = new KatalMetrics.Metric.String(name, value);
      object.truncate = true;
      this.publish(object);
    }
    /**
     * Helper method to publish a counter with the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounter",
    value: function publishCounter(name, value) {
      this.publish(new KatalMetrics.Metric.Counter(name, value));
    }
    /**
     * Helper method to publish a timer with the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimer",
    value: function publishTimer(name, value) {
      this.publish(new KatalMetrics.Metric.Timer(name, value));
    }
    /**
     * Helper method to publish a counter with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounterMonitor",
    value: function publishCounterMonitor(name, value) {
      this.publish(new KatalMetrics.Metric.Counter(name, value).withMonitor());
    }
    /**
     * Helper method to publish a timer with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimerMonitor",
    value: function publishTimerMonitor(name, value) {
      this.publish(new KatalMetrics.Metric.Timer(name, value).withMonitor());
    }
    /**
     * Private helper method to extract an actionId from a context if one is provided, and otherwise generate a new one.
     *
     * @returns Action ID string
     */

  }, {
    key: "_generateActionid",
    value: function _generateActionid(context) {
      if (context) {
        var fields = getContextFields(context);

        if (fields.actionId) {
          return fields.actionId;
        }
      }

      return (0, _v.default)();
    }
  }]);
  return KatalMetricsPublisher;
}();

exports.default = KatalMetricsPublisher;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ERROR_HANDLER = void 0;

var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  throw err;
};

exports.DEFAULT_ERROR_HANDLER = DEFAULT_ERROR_HANDLER;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Abstract base class for a Katal metrics driver.
 */
var KatalMetricsDriver =
/*#__PURE__*/
function () {
  function KatalMetricsDriver() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriver);
  }

  (0, _createClass2.default)(KatalMetricsDriver, [{
    key: "publish",

    /**
     * Publish the given metric object with the given error handler and context.
     *
     * @param metricObject Metric object to publish.  Contains metricKey, isMonitor, type, and value.
     * @param errorHandler Callback function for handling any asynchronous errors that occur in the driver
     *     (the driver should just throw an exception for a synchronous error).
     * @param context Context for publishing this metric.  Contains all other fields to be published.
     */
    value: function publish(metricObject, errorHandler, context) {
      throw new Error('KatalMetricsDriver is an abstract class, please choose a driver and use that instead');
    }
  }]);
  return KatalMetricsDriver;
}();

exports.default = KatalMetricsDriver;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = firstMap;

/**
 * Returns the first non-undefined value that results from running each value
 * in the given array through the mapper function.
 * @param array An array of values.
 * @param mapper A mapper function that should return a value or undefined.
 * @returns The first non-undefined value from the mapper function.
 */
function firstMap(array, mapper) {
  var toReturn = undefined;
  array.some(function (val) {
    toReturn = mapper(val);
    return toReturn != null;
  });
  return toReturn;
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectValues = Object.values ? Object.values : function (object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
};
var _default = objectValues;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleInt;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

/**
 * Number.isInteger is not in IE11, and letting Babel polyfill it added too much weight.
 * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 */
var isInteger = function isInteger(val) {
  return isFinite(val) && Math.floor(val) === val;
};
/**
 * Check if the given value is valid to be published to KatalMetrics as an integer (Counter or Timer),
 * and return either undefined (no error), or an Error object describing the problem.
 *
 * @param val Value to check
 * @param nameForError Name to use when constructing the error message, if necessary
 * @returns Error, or undefined if no error
 */


function validateSimpleInt(val, nameForError) {
  if (typeof val !== 'number') {
    return new Error("Expected ".concat(nameForError, " to have type 'number', but it was type '").concat((0, _typeof2.default)(val), "'"));
  }

  if (val < 0) {
    return new Error("Expected ".concat(nameForError, " to be positive, but it was ").concat(val));
  } // This will also catch NaN and Infinity


  if (!isInteger(val)) {
    return new Error("Expected ".concat(nameForError, " to be an integer, but it was ").concat(val));
  } // Couldn't find anything wrong, implicitly return undefined

}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleString;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var SIMPLE_STRING_PAT = /^[A-Za-z0-9.:@_/-]+$/;
var SIMPLE_STRING_MAX_LEN = 127;
/**
 * Check if the given value is valid to be published to KatalMetrics as a field value,
 * such as site, serviceName, methodName, or actionId (note this is not used to check values for string metrics).
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, it must be a non-empty string, less than 256 characters, containing only ASCII
 * letters, numbers, or these characters: .:@_/- (those are the PMET field value requirements).
 *
 * @param val String value to check
 * @param nameForError Name to use in the error message, if one is generated
 * @returns Error, or undefined if no error
 */

function validateSimpleString(val, nameForError) {
  if (typeof val !== "string") {
    return new Error("Expected ".concat(nameForError, " to be a string, but it was a ").concat((0, _typeof2.default)(val)));
  }

  if (val.length > SIMPLE_STRING_MAX_LEN) {
    return new Error("Expected ".concat(nameForError, " to be less than ").concat(SIMPLE_STRING_MAX_LEN, " characters, but it was ").concat(val.length, " characters"));
  }

  if (val.length < 1) {
    return new Error("Expected ".concat(nameForError, " to be non-blank"));
  }

  if (!SIMPLE_STRING_PAT.test(val)) {
    return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It can only contain letters, numbers, and these symbols: .:@_/-"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedRequestId = embedRequestId;

// until we can add a requestId field to the andes schema we will embed it in the actionId
function embedRequestId(actionId, requestId) {
  if (requestId) {
    return [requestId, actionId].join("::");
  }

  return actionId;
}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLists = mergeLists;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js"));

// Helper method to merge two lists which could be undefined
// Returns merged lists if either is defined, otherwise returns undefined
function mergeLists(list1, list2) {
  if (list1 || list2) {
    return [].concat((0, _toConsumableArray2.default)(list1 || []), (0, _toConsumableArray2.default)(list2 || []));
  } else {
    return undefined;
  }
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchMetricEvent = dispatchMetricEvent;

/**
 * Publish to external parties that are 
 * listening for katal.metrics.publish Custom Events
 */
function dispatchMetricEvent(metric, context) {
  if (typeof window === 'undefined') {
    return;
  }

  dispatchCustomEvent(metric, context); // for legacy purposes, also publish to __KATAL_METRICS_EXTENSION__

  publishToMetricsExtension(metric, context);
}

function dispatchCustomEvent(metric, context) {
  if (typeof CustomEvent !== "function") {
    return;
  }

  var event = new CustomEvent('katal.metrics.publish', {
    detail: {
      metric: metric,
      context: context.getFields()
    }
  });
  window.dispatchEvent(event);
}
/**
 * @Deprecated
 * Publish to https://code.amazon.com/packages/KatalMetricsExtension
 * The extension injects a global __KATAL_METRICS_EXTENSION__ object with a
 * `publish` method.
 */


function publishToMetricsExtension(metric, context) {
  var extension = window.__KATAL_METRICS_EXTENSION__;

  if (extension) {
    extension.publish(metric, context.getFields());
  }
}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Publisher", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsPublisher.default;
  }
});
Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsContext.default;
  }
});
Object.defineProperty(exports, "MetricsDriver", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsDriver.default;
  }
});
Object.defineProperty(exports, "ErrorHandler", {
  enumerable: true,
  get: function get() {
    return _ErrorHandler.ErrorHandler;
  }
});
exports.Metric = void 0;

var Metric = _interopRequireWildcard(__webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js"));

exports.Metric = Metric;

var _KatalMetricsPublisher = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsPublisher */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricsDriver = _interopRequireDefault(__webpack_require__(/*! ./driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _ErrorHandler = __webpack_require__(/*! ./driver/ErrorHandler */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js");

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

/**
 * Counter type.
 *
 * Can be used to count the number of times an event happened on a page, or as a simple 1/0 counter to track
 * success and failure.
 */
var KatalMetricCounter =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricCounter, _KatalMetricObject);

  /**
   * Create a new counter with the given name and value.
   *
   * @param name Counter name
   * @param value Counter value
   */
  function KatalMetricCounter(name) {
    var _this;

    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, KatalMetricCounter);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricCounter).call(this, name));
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this counter
   *
   * @return Counter value
   */


  (0, _createClass2.default)(KatalMetricCounter, [{
    key: "add",

    /**
     * Add a number to this counter.
     *
     * Can also be negative to subtract.
     *
     * @param addValue Amount to add to this counter
     */
    value: function add(addValue) {
      this.value += addValue;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricCounter.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Counter metrics object '".concat(this.name, "'"));
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set a new value for this counter
     *
     * @param value New value for this counter
     */
    ,
    set: function set(value) {
      // Math.round will also coerce from a string if necessary, and return NaN if invalid
      this._value = Math.round(value);
    }
    /**
     * Gets the type for this counter.
     *
     * @return Always returns "Counter".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Counter;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }]);
  return KatalMetricCounter;
}(_KatalMetricObject2.default);

exports.default = KatalMetricCounter;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

/**
 * Standardized metric for instrumenting HTTP requests.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name you provide prefixed with "HTTPRequest.".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * It has additional properties which will be emitted if set; see url, statusCode, and statusText.
 *
 * For example, if you gave the name "Search", these metrics will be created:
 *   HTTPRequest.Search.Latency - Latency for this request
 *   HTTPRequest.Search.Failure - Failure for this request (1 for failure, 0 for success)
 */
var KatalMetricHttpRequest =
/*#__PURE__*/
function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricHttpRequest, _KatalMetricTimedAtte);

  /** The prefix for this metric. */

  /** The suffix for URL metrics of this class. */

  /** The suffix for HTTP response code metrics of this class. */

  /** The suffix for HTTP response text metrics of this class. */

  /**
   * Create a new HTTP Request timed attempt metric incorporating the given name.
   *
   * The name you give will be used to create a KatalMetricTimedAttempt with the provided name prefixed with "HTTPRequest.".
   *
   * @param name Name of this metric; resulting metrics will prefix this name with "HTTPRequest."
   */
  function KatalMetricHttpRequest(name) {
    (0, _classCallCheck2.default)(this, KatalMetricHttpRequest);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricHttpRequest).call(this, "".concat(KatalMetricHttpRequest.HTTP_REQUEST_PREFIX, ".").concat(name)));
  }
  /**
   * Set the url for this metric.
   *
   * A string metric will be added to the list of objects that will be published for this metric.  Its name will
   * be this metrics name suffixed with '.URL', and its value will be the URL value given here.
   *
   * @param value URL for this metric
   */


  (0, _createClass2.default)(KatalMetricHttpRequest, [{
    key: "url",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the URL for this metric, if defined.
     *
     * @return The URL for this metric, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Get the URL metric object associated with this metric, if defined.
     *
     * @return Associated URL metric object, or undefined
     */

  }, {
    key: "urlMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Set the HTTP response status code for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusCode', and its value will be the status code value given here.
     *
     * @param value HTTP response status code for this metric
     */

  }, {
    key: "statusCode",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the HTTP response status code for this metric, if defined.
     *
     * @return Associated HTTP response status code metric object, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Get the HTTP response status code metric object associated with this metric, if defined.
     *
     * @return HTTP response status code metric object, or undefined
     */

  }, {
    key: "statusCodeMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Set the HTTP response status text for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusText', and its value will be the status text value given here.
     *
     * @param statusText HTTP response status text for this metric, or undefined to remove
     */

  }, {
    key: "statusText",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */

  }, {
    key: "statusTextMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
  }]);
  return KatalMetricHttpRequest;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricHttpRequest;
(0, _defineProperty2.default)(KatalMetricHttpRequest, "HTTP_REQUEST_PREFIX", 'HTTPRequest');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "URL_SUFFIX", 'URL');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_CODE_SUFFIX", 'StatusCode');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_TEXT_SUFFIX", 'StatusText');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

/**
 * Standardized metric for instrumenting application initialization.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name "Initialization".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * By default, these metrics will be created:
 *   Initialization.Latency - Latency for application initialization
 *   Initialization.Failure - Failure for this application initialization (1 for failure, 0 for success)
 */
var KatalMetricInitialization =
/*#__PURE__*/
function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricInitialization, _KatalMetricTimedAtte);

  /** The name for this metric. */

  /**
   * Create a new timed attempt metric named "Initialization", for recording latency and failure information about
   * your application's initialization.
   */
  function KatalMetricInitialization() {
    (0, _classCallCheck2.default)(this, KatalMetricInitialization);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricInitialization).call(this, KatalMetricInitialization.INITIALIZE_METRIC_NAME));
  }

  return KatalMetricInitialization;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricInitialization;
(0, _defineProperty2.default)(KatalMetricInitialization, "INITIALIZE_METRIC_NAME", 'Initialization');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObjectList */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js"));

var _ObjectValuesPonyfill = _interopRequireDefault(__webpack_require__(/*! ../helper/ObjectValuesPonyfill */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js"));

/**
 * Metric object list that tracks metrics by name, and generates metrics prefixed with the name of this object.
 */
var KatalMetricNamedObjectList =
/*#__PURE__*/
function (_KatalMetricObjectLis) {
  (0, _inherits2.default)(KatalMetricNamedObjectList, _KatalMetricObjectLis);

  /**
   * Create a new named object list.
   *
   * The name given here will be used to prefix all metrics.
   *
   * @param name Name of this metric
   */
  function KatalMetricNamedObjectList(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricNamedObjectList);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricNamedObjectList).call(this, name));
    _this.namedMetrics = {};
    return _this;
  }

  (0, _createClass2.default)(KatalMetricNamedObjectList, [{
    key: "setNamedMetric",

    /**
     * Replace the metric with the given name with a new metric generated by the given function.
     *
     * If the newly created metric supports monitoring, its isMonitor flag will be set to the value of the
     * isMonitor flag for this containing object.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     */
    value: function setNamedMetric(subName, metricCreator) {
      var fullName = this.getNameForSubMetric(subName);
      var metric = metricCreator(fullName);

      if (metric.canMonitor) {
        metric.isMonitor = this.isMonitor;
      }

      this.namedMetrics[subName] = metric;
    }
    /**
     * If the given value is undefined or null, delete the metric with the give name; otherwise if the given named
     * metric already exists update its value; otherwise create a new metric of the given type and set its value.
     *
     * This specialized helper method is designed to deal with the common case of a value setter in a more complex
     * metric.  Outside of subclasses, other methods will probably prove more useful.
     *
     * If the value is null the metric will also be deleted.
     *
     * @param subName Name of metric to create or delete
     * @param newValueClass Class of new metric to create
     * @param newValue New value for this metric (or undefined to delete the metric)
     */

  }, {
    key: "setOrDeleteNamedMetricValue",
    value: function setOrDeleteNamedMetricValue(subName, newValueClass, newValue) {
      if (newValue == undefined) {
        this.deleteNamedMetric(subName);
      } else {
        var metric = this.getOrCreateNamedMetric(subName, function (name) {
          return new newValueClass(name, newValue);
        });
        metric.value = newValue;
      }
    }
    /**
     * Get the sub-metric with the given name if it exists, otherwise use the given function to create a new metric and
     * store and return that.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     * @return Metric object which was retrieved or created
     */

  }, {
    key: "getOrCreateNamedMetric",
    value: function getOrCreateNamedMetric(subName, metricCreator) {
      if (!this.namedMetrics[subName]) {
        this.setNamedMetric(subName, metricCreator);
      }

      return this.namedMetrics[subName];
    }
    /**
     * Return the given named sub-metric, if it exists.
     *
     * @param {string} subName Name of this sub-metric
     * @return {KatalMetricObject | undefined} Metric object with this name if it exists, otherwise undefined
     */

  }, {
    key: "getNamedMetric",
    value: function getNamedMetric(subName) {
      return this.namedMetrics[subName];
    }
    /**
     * Delete the given named sub-metric.
     *
     * @param subName Name of this sub-metric
     */

  }, {
    key: "deleteNamedMetric",
    value: function deleteNamedMetric(subName) {
      delete this.namedMetrics[subName];
    }
    /**
     * Get the value for the given metric, or undefined if the metric does not exist.
     *
     * @param subName Name of this sub-metric
     * @return Value for the given metric, or undefined if the metric does not exist
     */

  }, {
    key: "getNamedMetricValue",
    value: function getNamedMetricValue(subName) {
      var metric = this.getNamedMetric(subName);
      if (!metric) return undefined;
      return metric.value;
    }
    /**
     * Generate a name for the given sub-metric.
     *
     * @param subName Name of this sub-metric
     * @return Full name for this sub-metric
     */

  }, {
    key: "getNameForSubMetric",
    value: function getNameForSubMetric(subName) {
      return "".concat(this.name, ".").concat(subName);
    }
  }, {
    key: "metricList",
    get: function get() {
      return (0, _ObjectValuesPonyfill.default)(this.namedMetrics);
    }
  }]);
  return KatalMetricNamedObjectList;
}(_KatalMetricObjectList.default);

exports.default = KatalMetricNamedObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricType */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

/**
 * Abstract base class for a single metric in Katal.
 *
 * A single metric contains the name (metricKey), value, type, and the isMonitor flag; everything else is in the
 * KatalMetricsContext it is published to.
 */
var KatalMetricObject =
/*#__PURE__*/
function () {
  /**
   * Metric types.
   */

  /**
   * Create a new KatalMetricObject with the given name.
   *
   * @param name Name for this metric; published as metricKey field
   */
  function KatalMetricObject(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObject);
    this._name = name;
    this._isMonitor = false;
  }
  /**
   * Get the name for this metric.
   *
   * Note that the name is immutable, and this cannot be set.
   *
   * @returns Name for this metric
   */


  (0, _createClass2.default)(KatalMetricObject, [{
    key: "withMonitor",

    /**
     * Set the isMonitor flag for this metric, and returns this object for continued use.
     *
     * This flag determines if the metric can be used for dashboards and alarms (i.e. if it will be published to PMET)
     * @param isMonitor New value for the isMonitor flag; defaults to true
     * @returns This object
     */
    value: function withMonitor() {
      var isMonitor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isMonitor = isMonitor;
      return this;
    }
    /**
     * Set the isMonitor flag for this metric.
     *
     * The value is forced to a boolean based on its truthiness.
     *
     * @param isMonitor New value for the isMonitor flag
     */

  }, {
    key: "validationError",

    /**
     * Check for a validation error on this object.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns {Error | undefined} Error found with this object, or undefined if no error is found
     */
    value: function validationError() {
      if (this.isMonitor !== undefined && typeof this.isMonitor !== 'boolean') {
        return new Error("Field isMonitor should be a boolean, but it was a ".concat((0, _typeof2.default)(this.isMonitor)));
      }

      return (0, _ValidateSimpleString.default)(this.name, 'field name');
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Alias for name.
     *
     * @returns Name for this metric
     */

  }, {
    key: "metricKey",
    get: function get() {
      return this._name;
    }
  }, {
    key: "isMonitor",
    set: function set(isMonitor) {
      this._isMonitor = !!isMonitor;
    }
    /**
     * Get the isMonitor flag for this metric.
     *
     * @returns isMonitor flag for this metric.
     */
    ,
    get: function get() {
      return this._isMonitor;
    }
    /**
     * Check if this metric can be meaningfully monitored.
     *
     * Subclasses must override this.
     *
     * @return Whether this metric can be meaningfully monitored
     */

  }, {
    key: "canMonitor",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement canMonitor');
    }
    /**
     * Get the type of this metric.
     *
     * @return Type of this metric (one of: String, Counter, Timer, List)
     */

  }, {
    key: "type",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement type getter');
    }
  }]);
  return KatalMetricObject;
}();

exports.default = KatalMetricObject;
(0, _defineProperty2.default)(KatalMetricObject, "Types", _KatalMetricType.default);

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ../helper/FirstMap */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

/**
 * Abstract metric that contains a list of other metrics; when it is published, the list of metrics is retrieved, and all
 * are published.
 */
var KatalMetricObjectList =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricObjectList, _KatalMetricObject);

  /**
   * Create a new KatalMetricObjectList.
   *
   * @param name Name for this metric.  Not really used, but present for consistency with other metrics.
   */
  function KatalMetricObjectList(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObjectList);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricObjectList).call(this, name));
  }
  /**
   * Get the list of for this object
   *
   * @returns Array of metrics for this object
   */


  (0, _createClass2.default)(KatalMetricObjectList, [{
    key: "validationError",

    /**
     * If any of the contained metrics are invalid, return the first validation error encountered; otherwise return
     * undefined.
     *
     * Note that this isn't called by the publisher; it validates each sub-metric on its own.
     *
     * @returns Error found with submetric, if any; else undefined
     */
    value: function validationError() {
      // Doesn't make sense to check superclass error here, since it is the contained metrics that matter.
      return (0, _FirstMap.default)(this.metricList, function (metric) {
        return metric.validationError();
      });
    }
  }, {
    key: "metricList",
    get: function get() {
      throw new Error('Subclass of KatalMetricObjectList must implement metricList getter');
    }
  }, {
    key: "isMonitor",
    set: function set(isMonitor) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", isMonitor, this, true);
      this.metricList.forEach(function (metric) {
        if (metric.canMonitor) {
          metric.isMonitor = isMonitor;
        }
      });
    } // This just delegates to the superclass, but if we override the setter without overriding the getter
    // getting the property will always return undefined.
    ,
    get: function get() {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", this);
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.List;
    }
  }]);
  return KatalMetricObjectList;
}(_KatalMetricObject2.default);

exports.default = KatalMetricObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

/**
 * String type.
 *
 * Can be used to store arbitrary strings of data.
 */
var KatalMetricString =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricString, _KatalMetricObject);

  /**
   * Create a string with the given name and value.
   *
   * @param name String name
   * @param value String value
   */
  function KatalMetricString(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricString);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricString).call(this, name));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "truncate", false);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this string metric.
   *
   * @return Value for this metric
   */


  (0, _createClass2.default)(KatalMetricString, [{
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricString.prototype), "validationError", this).call(this);
      if (superError) return superError;

      if (typeof this.value !== 'string') {
        return new Error("Expected field value in String metrics object '".concat(this.name, "' to be type string, but it was ").concat((0, _typeof2.default)(this.value)));
      }

      if (this.value.length > KatalMetricString.MAX_SIZE) {
        if (this.truncate) {
          this.value = this.value.substring(0, KatalMetricString.MAX_SIZE);
        } else {
          return new Error("Expected field value in String metrics object '".concat(this.name, "' to be ").concat(KatalMetricString.MAX_SIZE, " characters or less, but it was ").concat(this.value.length, " characters."));
        }
      } // Didn't find anything wrong, implicitly return undefined

    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this string metric.
     *
     * The new value should be a string, but number and boolean types will be automatically converted to strings.
     * For other types, including undefined and null, the value will be accepted, but will fail validation when publishing.
     *
     * @param value New value for this metric
     */
    ,
    set: function set(value) {
      if (typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
      }

      this._value = value;
    }
    /**
     * Truncation flag for this string metric.
     *
     * If set, the value here will be automatically truncated to the maximum size allowed by the current schema.
     * Otherwise, sending a value larger than allowed will result in a failure.
     *
     * @param value True to automatically truncate metrics, otherwise false
     */

  }, {
    key: "type",

    /**
     * Gets the type for this metric.
     *
     * @return Always returns "String".
     */
    get: function get() {
      return _KatalMetricObject2.default.Types.String;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return false;
    }
  }]);
  return KatalMetricString;
}(_KatalMetricObject2.default);

exports.default = KatalMetricString;
(0, _defineProperty2.default)(KatalMetricString, "MAX_SIZE", 256);

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricNamedObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricNamedObjectList */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

/**
 * Metric that pairs a timer and a failure counter to record the time and status of an attempt to do something.
 */
var KatalMetricTimedAttempt =
/*#__PURE__*/
function (_KatalMetricNamedObje) {
  (0, _inherits2.default)(KatalMetricTimedAttempt, _KatalMetricNamedObje);

  /** The sub-metric name for latency. */

  /** The sub-metric name for failure count. */

  /**
   * Create a new timed attempt with the given name
   *
   * This will create two inner metrics, a KatalMetricCounter that has the given name with ".Failure" appended,
   * and a KatalMetricTimerStopwatch that has the given name with ".Latency" appended.
   *
   * @param name Name of this attempt
   */
  function KatalMetricTimedAttempt(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimedAttempt);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimedAttempt).call(this, name));

    _this.setNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX, function (name) {
      return new _KatalMetricTimerStopwatch.default(name);
    });

    _this.setNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX, function (name) {
      return new _KatalMetricCounter.default(name, 1);
    });

    return _this;
  }
  /**
   * Set the failure counter metric based on the given failure status.
   *
   * If failure is true the counter will have a value of 1; if it is false the counter will have a value of 0.
   *
   * @param failure Whether this is a failure or not; default true
   */


  (0, _createClass2.default)(KatalMetricTimedAttempt, [{
    key: "setFailure",
    value: function setFailure() {
      var failure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var failureCount = failure ? 1 : 0;
      var metric = this.failureMetric;
      metric.value = failureCount;
    }
    /**
     * Set the failure status to false.
     */

  }, {
    key: "setSuccess",
    value: function setSuccess() {
      this.setFailure(false);
    }
    /**
     * Set the latency metric to the given value, in milliseconds.
     *
     * Note you don't normally have to set this, the underlying metric is a KatalMetricTimerStopwatch that will start
     * and stop automatically.
     *
     * @param latencyMs Latency in milliseconds
     */

  }, {
    key: "setLatency",
    value: function setLatency(latencyMs) {
      var metric = this.latencyMetric;
      metric.value = latencyMs;
    }
    /**
     * Get the timer stopwatch metric for this attempt.
     *
     * @return Timer stopwatch metric for this attempt
     */

  }, {
    key: "latencyMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX);
    }
    /**
     * Get the failure counter metric for this attempt.
     *
     * @return Failure counter metric for this event
     */

  }, {
    key: "failureMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX);
    }
  }]);
  return KatalMetricTimedAttempt;
}(_KatalMetricNamedObjectList.default);

exports.default = KatalMetricTimedAttempt;
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "LATENCY_SUFFIX", 'Latency');
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "FAILURE_SUFFIX", 'Failure');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

/**
 * Timer type.
 *
 * Can be used to record a time.  This class requires explicit value; see KatalMetricTimerStopwatch for automatic
 * timing.
 */
var KatalMetricTimer =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricTimer, _KatalMetricObject);

  /**
   * Create a new timer metric.
   *
   * @param name Name for the metric
   * @param value Timer value in milliseconds
   */
  function KatalMetricTimer(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimer).call(this, name));
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this timer
   *
   * @return Timer value in milliseconds
   */


  (0, _createClass2.default)(KatalMetricTimer, [{
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimer.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Timer metrics object '".concat(this.name, "'"));
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this timer
     *
     * @param value New timer value in milliseconds
     */
    ,
    set: function set(value) {
      if (value == undefined) {
        this._value = value;
        return;
      } // Math.round will also coerce from a string if necessary, and return NaN if invalid


      this._value = Math.round(value);
    }
    /**
     * Get the type for this timer.
     *
     * @return Always returns "Timer".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Timer;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }]);
  return KatalMetricTimer;
}(_KatalMetricObject2.default);

exports.default = KatalMetricTimer;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricTimer2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

/**
 * Subclass of KatalMetricTimer that can be started and stopped, and will record the elapsed time between starting and
 * stopping.  By default it will start when the object is created, and stopped when the value is retrieved with
 * the getter "value".
 */
var KatalMetricTimerStopwatch =
/*#__PURE__*/
function (_KatalMetricTimer) {
  (0, _inherits2.default)(KatalMetricTimerStopwatch, _KatalMetricTimer);

  /**
   * Create a new timer with the given name and starting time.  If no starting time is given, the current time is used.
   *
   * @param name Name for this timer
   * @param startTime Millisecond epoch time for the start time; defaults to now
   */
  function KatalMetricTimerStopwatch(name, startTime) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimerStopwatch);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch).call(this, name, undefined));

    _this.start(startTime);

    _this._value = undefined;
    return _this;
  }
  /**
   * Re-start timer with the given start time, or the current time if none is given.
   *
   * @param startTime When the timer was started, in epoch milliseconds; defaults to now
   */


  (0, _createClass2.default)(KatalMetricTimerStopwatch, [{
    key: "start",
    value: function start(startTime) {
      this._startTime = startTime || this.now();
    }
    /**
     * Stop the timer and record the elapsed time.
     *
     * @param stopTime When the timer was stopped, in epoch milliseconds; defaults to now
     */

  }, {
    key: "stop",
    value: function stop(stopTime) {
      return this._stopTime = stopTime || this.now();
    }
    /**
     * Check if the timer has been stopped.
     *
     * @returns Whether the timer has been stopped yet
     */

  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }, {
    key: "isStopped",
    get: function get() {
      return this._stopTime !== undefined;
    }
    /**
     * Get the elapsed time between when the timer was started and stopped; if the timer has not yet been stopped,
     * stop it first.
     *
     * @returns Elapsed time between when timer was started and stopped
     */

  }, {
    key: "value",
    get: function get() {
      if ((0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this) === undefined) {
        if (!this.isStopped) {
          this.stop();
        } // Rely on super.value setter to round


        (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this.stopTime - this.startTime, this, true);
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this);
    }
    /**
     * Get when this timer was started.
     *
     * @return Start time, in epoch milliseconds
     */
    ,

    /**
     * Set the value for this metric.  Note this will override the stopwatch behavior and just use the given value.
     *
     * @param value Value for this metric
     */
    set: function set(value) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", value, this, true);
    }
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    }
    /**
     * Get when this timer was stopped (or undefined if it is still running)
     *
     * @return Stop time, in epoch millseconds, or undefined if the stopwatch is still running
     */

  }, {
    key: "stopTime",
    get: function get() {
      return this._stopTime;
    }
  }]);
  return KatalMetricTimerStopwatch;
}(_KatalMetricTimer2.default);

exports.default = KatalMetricTimerStopwatch;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Metric types.
 */
var KatalMetricType;

(function (KatalMetricType) {
  KatalMetricType["String"] = "String";
  KatalMetricType["Counter"] = "Counter";
  KatalMetricType["Timer"] = "Timer";
  KatalMetricType["List"] = "List";
})(KatalMetricType || (KatalMetricType = {}));

;
var _default = KatalMetricType;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function get() {
    return _KatalMetricObject.default;
  }
});
Object.defineProperty(exports, "String", {
  enumerable: true,
  get: function get() {
    return _KatalMetricString.default;
  }
});
Object.defineProperty(exports, "Counter", {
  enumerable: true,
  get: function get() {
    return _KatalMetricCounter.default;
  }
});
Object.defineProperty(exports, "Timer", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimer.default;
  }
});
Object.defineProperty(exports, "TimerStopwatch", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimerStopwatch.default;
  }
});
Object.defineProperty(exports, "TimedAttempt", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimedAttempt.default;
  }
});
Object.defineProperty(exports, "Initialization", {
  enumerable: true,
  get: function get() {
    return _KatalMetricInitialization.default;
  }
});
Object.defineProperty(exports, "HttpRequest", {
  enumerable: true,
  get: function get() {
    return _KatalMetricHttpRequest.default;
  }
});

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

var _KatalMetricTimer = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricInitialization = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricInitialization */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js"));

var _KatalMetricHttpRequest = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricHttpRequest */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js"));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This class encapsulates two IIFEs that the Sushi library contains. A fake CSM and Window object are created and provided
 * to the functions so that they actually execute in a controlled environment away from any CSM code that might be executing
 * at the platform level within the page.
 *
 * The basic run order is the following:
 * 1. Build the mock CSM object, then build a mock Window object that references the CSM object as ue_csm
 * 2. Run the transportation-clients.js Script from SushiJavascriptClient providing the mocks. It will modify globals on the mock objects.
 * 3. Run the sushi-client.js script from SushiJavaScriptClient providing the mocks. It will create an instance of the sushi client and inject it into the CSM globals in the mocks.
 * 4. whenever event() is called, refer to the encapsulated csm object to add the event to the queue.
 */
var SushiClient =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(SushiClient, null, [{
    key: "createSushiUrl",
    value: function createSushiUrl(region, sourceGroup) {
      if (!sourceGroup) {
        throw new Error("Sushi Driver was not provided with a source group.");
      }

      var domain;

      switch (region) {
        case SushiClient.REGIONS.NA:
          domain = "unagi-na";
          break;

        case SushiClient.REGIONS.EU:
          domain = "unagi-eu";
          break;

        case SushiClient.REGIONS.FE:
          domain = "unagi-fe";
          break;

        case SushiClient.REGIONS.CN:
          domain = "unagi-cn";
          break;

        default:
          throw new Error("Unrecognized region '".concat(region, "' provided to SushiClient."));
      }

      return "https://".concat(domain, ".amazon.com/1/events/").concat(sourceGroup);
    }
  }, {
    key: "createCsmUserContext",
    value: function createCsmUserContext(sushiUrl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _objectSpread({
        hiPriFlushInterval: 1000,
        lowPriFlushInterval: 10000,
        requestId: "1",
        errorChannel: "jserr",
        sessionStorageWrapper: undefined,
        errorHandlerFunction: console.log,
        sushiUrl: sushiUrl
      }, options);
    }
    /**
     * Create a Sushi Client for a region and source group
     *
     * @param region Region in SushiClient.REGIONS
     * @param sourceGroup Sushi Eel source group
     * @param errorHandler Error handler function
     * @param options Additional CSM context overrides
     * @param clientOverride An optional transportation client for overriding the default clients (navigator.sendBeacon and XDomainRequest or XMLHttpRequest)
     */

  }, {
    key: "REGIONS",
    get: function get() {
      return {
        NA: "NA",
        EU: "EU",
        FE: "FE",
        CN: "CN"
      };
    }
  }]);

  function SushiClient() {
    var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SushiClient.REGIONS.NA;
    var sourceGroup = arguments.length > 1 ? arguments[1] : undefined;
    var errorHandler = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var clientOverride = arguments.length > 4 ? arguments[4] : undefined;
    (0, _classCallCheck2.default)(this, SushiClient);
    var sushiUrl = SushiClient.createSushiUrl(region, sourceGroup);
    var csmUserContext = SushiClient.createCsmUserContext(sushiUrl, options);
    this.ue_csm = this.setupMockCSMObject(csmUserContext);
    this.encapsulatedWindow = this.setupMockWindow(this.ue_csm);
    this.transportationClientCode(this.ue_csm, window);

    if (clientOverride) {
      this.ue_csm.ue._sBcn = {
        isSupported: true,
        send: function send(endpoint, payload) {
          clientOverride(endpoint, payload);
          return true;
        }
      };
    }

    this.clientCode(this.ue_csm, this.encapsulatedWindow);
    this.errorHandler = errorHandler;
  }

  (0, _createClass2.default)(SushiClient, [{
    key: "event",
    value: function event(data, producerId, schemaId, options) {
      var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (debug) {
        console.log("SushiClient wrapper publishing the following:", {
          data: data,
          producerId: producerId,
          schemaId: schemaId,
          options: options
        });
      }

      return this.ue_csm.ue.event(data, producerId, schemaId, options);
    }
    /**
     * If you plan to emit 1000 or more events per instantiated client,
     * call reset after calling event to allow the CSM client to continue sending events.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.ue_csm.ue.event.reset();
    }
    /**
     * Register a callback that will be called just before each time metrics are
     * flushed to the network.
     * @param callback A function that sushi will call before flushes.
     */

  }, {
    key: "onSushiFlush",
    value: function onSushiFlush(callback) {
      this.ue_csm.ue.onSushiFlush(callback);
    }
    /**
     * Register a callback that will be called just before the page unloads.
     * This can be used to send any final metrics to sushi, such as page visit
     * duration or batched counters.
     * @param callback A function that sushi will call before unload.
     */

  }, {
    key: "onSushiUnload",
    value: function onSushiUnload(callback) {
      this.ue_csm.ue.onSushiUnload(callback);
    }
  }, {
    key: "setupMockCSMObject",
    value: function setupMockCSMObject(csmUserContext) {
      var _this = this;

      var execStub = function execStub(callback, attribution) {
        return callback;
      };

      var eventStub = function eventStub(log, producer, eventType) {
        console.warn("SushiClient CSM stub called in unsupported manner: event()");
      };

      var errorHandler = function errorHandler(logEvent, channel) {
        if (_this.errorHandler) {
          _this.errorHandler(logEvent);
        } else {
          console.log("An error has occurred in SushiClient channel " + channel, logEvent);
        }
      };

      var attachHandler = function attachHandler(evt, handler, container) {
        //TODO might be able to just use window.ue.attach?
        container = container || window; //ok to use real window global here.

        if (window.EventTarget && window.EventTarget.prototype && window.EventTarget.prototype.addEventListener) {
          window.EventTarget.prototype.addEventListener.call(container, evt, handler, !!window.ue_clf);
        } else if (container.addEventListener) {
          container.addEventListener(evt, handler, !!window.ue_clf);
        } else if (container.attachEvent) {
          container.attachEvent("on" + evt, handler);
        }
      };

      return {
        ue_hpsi: csmUserContext.hiPriFlushInterval,
        ue_lpsi: csmUserContext.lowPriFlushInterval,
        ue: {
          ssw: csmUserContext.sessionStorageWrapper,
          log: errorHandler,
          exec: execStub,
          event: eventStub,
          attach: attachHandler
        },
        ueLogError: csmUserContext.errorHandlerFunction,
        ue_surl: csmUserContext.sushiUrl,
        ue_id: csmUserContext.requestId,
        ue_err_chan: csmUserContext.errorChannel
      };
    }
  }, {
    key: "setupMockWindow",
    value: function setupMockWindow(ue_csm) {
      //apparently cannot ref the setTimeout function directly in some browsers so we have to wrap it.
      var timeoutWrapper = function timeoutWrapper(fn, timeout) {
        return window.setTimeout(fn, timeout);
      };

      return {
        ue_csm: ue_csm,
        ueLogError: ue_csm.ueLogError,
        ue: ue_csm.ue,
        setTimeout: timeoutWrapper
      };
    }
    /**
     * Code within function pulled directly from
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/sushi-client.js
     */

  }, {
    key: "clientCode",
    value: function clientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, k) {
        function A() {
          for (var a = 0; a < arguments.length; a++) {
            var c = arguments[a];

            try {
              var h;

              if (c.isSupported) {
                var b = t.buildPayload(l, e);
                h = c.send(J, b);
              } else throw dummyException;

              return h;
            } catch (d) {}
          }

          B({
            m: "All supported clients failed",
            attribution: "CSMSushiClient_TRANSPORTATION_FAIL",
            f: "sushi-client.js",
            logLevel: "ERROR"
          }, k.ue_err_chan || "jserr");
        }

        function m() {
          if (e.length) {
            for (var a = 0; a < n.length; a++) {
              n[a]();
            }

            A(d._sBcn || {}, d._ajx || {});
            e = [];
            f = {};
            l = {};
            u = v = q = w = 0;
          }
        }

        function K() {
          var a = new Date(),
              c = function c(a) {
            return 10 > a ? "0" + a : a;
          };

          return Date.prototype.toISOString ? a.toISOString() : a.getUTCFullYear() + "-" + c(a.getUTCMonth() + 1) + "-" + c(a.getUTCDate()) + "T" + c(a.getUTCHours()) + ":" + c(a.getUTCMinutes()) + ":" + c(a.getUTCSeconds()) + "." + String((a.getUTCMilliseconds() / 1E3).toFixed(3)).slice(2, 5) + "Z";
        }

        function x(a) {
          try {
            return JSON.stringify(a);
          } catch (c) {}

          return null;
        }

        function C(a, c, h, g) {
          var p = !1;
          g = g || {};
          r++;
          r == D && B({
            m: "Max number of Sushi Logs exceeded",
            f: "sushi-client.js",
            logLevel: "ERROR",
            attribution: "CSMSushiClient_MAX_CALLS"
          }, k.ue_err_chan || "jserr");
          var f;
          if (f = !(r >= D)) (f = a && -1 < a.constructor.toString().indexOf("Object") && c && -1 < c.constructor.toString().indexOf("String") && h && -1 < h.constructor.toString().indexOf("String")) || L++;
          f && (d.count && d.count("Event:" + h, 1), a.producerId = a.producerId || c, a.schemaId = a.schemaId || h, a.timestamp = K(), c = Date.now ? Date.now() : +new Date(), h = Math.random().toString().substring(2, 12), a.messageId = b.ue_id + "-" + c + "-" + h, g && !g.ssd && (a.sessionId = a.sessionId || b.ue_sid, a.requestId = a.requestId || b.ue_id, a.obfuscatedMarketplaceId = a.obfuscatedMarketplaceId || b.ue_mid), (c = x(a)) ? (c = c.length, (e.length == M || q + c > N) && m(), q += c, a = {
            data: t.compressEvent(a)
          }, e.push(a), (g || {}).n ? 0 === E ? m() : u || (u = k.setTimeout(m, E)) : v || (v = k.setTimeout(m, O)), p = !0) : p = !1);
          !p && b.ue_int && console.error("Invalid JS Nexus API call");
          return p;
        }

        function F() {
          if (!G) {
            for (var a = 0; a < y.length; a++) {
              y[a]();
            }

            for (a = 0; a < n.length; a++) {
              n[a]();
            }

            e.length && (b.ue_sbuimp && b.ue && b.ue.ssw && (a = x({
              dct: l,
              evt: e
            }), b.ue.ssw("eeldata", a), b.ue.ssw("eelsts", "unk")), A(d._sBcn || {}));
            G = !0;
          }
        }

        function H(a) {
          y.push(a);
        }

        function I(a) {
          n.push(a);
        }

        var D = 1E3,
            M = 499,
            N = 524288,
            s = function s() {},
            d = b.ue || {},
            B = d.log || s,
            P = b.uex || s;

        (b.uet || s)("bb", "ue_sushi_v1", {
          wb: 1
        });

        var J = b.ue_surl || "https://unagi-na.amazon.com/1/events/com.amazon.csm.nexusclient.gamma",
            Q = ["messageId", "timestamp"],
            z = "#",
            e = [],
            f = {},
            l = {},
            q = 0,
            w = 0,
            L = 0,
            r = 0,
            y = [],
            n = [],
            G = !1,
            u,
            v,
            E = void 0 === b.ue_hpsi ? 1E3 : b.ue_hpsi,
            O = void 0 === b.ue_lpsi ? 1E4 : b.ue_lpsi,
            t = function () {
          function a(a) {
            f[a] = z + w++;
            l[f[a]] = a;
            return f[a];
          }

          function c(b) {
            if (!(b instanceof Function)) {
              if (b instanceof Array) {
                for (var g = [], d = b.length, e = 0; e < d; e++) {
                  g[e] = c(b[e]);
                }

                return g;
              }

              if (b instanceof Object) {
                g = {};

                for (d in b) {
                  b.hasOwnProperty(d) && (g[f[d] ? f[d] : a(d)] = -1 === Q.indexOf(d) ? c(b[d]) : b[d]);
                }

                return g;
              }

              return "string" === typeof b && (b.length > (z + w).length || b.charAt(0) === z) ? f[b] ? f[b] : a(b) : b;
            }
          }

          return {
            compressEvent: c,
            buildPayload: function buildPayload() {
              return x({
                cs: {
                  dct: l
                },
                events: e
              });
            }
          };
        }();

        (function () {
          if (d.event && d.event.isStub) {
            if (b.ue_sbuimp && b.ue && b.ue.ssw) {
              var a = b.ue.ssw("eelsts").val;

              if (a && "unk" === a && (a = b.ue.ssw("eeldata").val)) {
                var c;

                a: {
                  try {
                    c = JSON.parse(a);
                    break a;
                  } catch (f) {}

                  c = null;
                }

                c && c.evt instanceof Array && c.dct instanceof Object && (e = c.evt, l = c.dct, e && l && (m(), b.ue.ssw("eeldata", "{}"), b.ue.ssw("eelsts", "scs")));
              }
            }

            d.event.replay(function (a) {
              a[3] = a[3] || {};
              a[3].n = 1;
              C.apply(this, a);
            });
            d.onSushiUnload.replay(function (a) {
              H(a[0]);
            });
            d.onSushiFlush.replay(function (a) {
              I(a[0]);
            });
          }
        })();

        d.attach("beforeunload", F);
        d.attach("pagehide", F);
        d._cmps = t;
        d.event = C;

        d.event.reset = function () {
          r = 0;
        };

        d.onSushiUnload = H;
        d.onSushiFlush = I;

        try {
          k.P && k.P.register && k.P.register("sushi-client", s);
        } catch (R) {
          b.ueLogError(R, {
            logLevel: "WARN"
          });
        }

        P("ld", "ue_sushi_v1", {
          wb: 1
        });
      }, "Nxs-JS-Client")(ue_csm, window);
    }
    /**
     * The code in this function is pulled directly from:
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/transportation-clients.js
     */

  }, {
    key: "transportationClientCode",
    value: function transportationClientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, c) {
        var e = function e() {},
            f = function () {
          return {
            send: function send(b, d) {
              if (d && b) {
                var a;
                if (c.XDomainRequest) a = new XDomainRequest(), a.onerror = e, a.ontimeout = e, a.onprogress = e, a.onload = e, a.timeout = 0;else if (c.XMLHttpRequest) {
                  if (a = new XMLHttpRequest(), !("withCredentials" in a)) throw "";
                } else a = void 0;
                if (!a) throw "";
                a.open("POST", b, !0);
                a.setRequestHeader && a.setRequestHeader("Content-type", "text/plain");
                a.send(d);
              }
            },
            isSupported: !0
          };
        }(),
            g = function () {
          return {
            send: function send(c, d) {
              if (c && d) if (navigator.sendBeacon(c, d)) b.ue_sbuimp && b.ue && b.ue.ssw && b.ue.ssw("eelsts", "scs");else throw "";
            },
            isSupported: !!navigator.sendBeacon && !(c.cordova && c.cordova.platformId && "ios" == c.cordova.platformId)
          };
        }();

        b.ue._ajx = f;
        b.ue._sBcn = g;
      }, "Transportation-clients")(ue_csm, window);
    }
  }]);
  return SushiClient;
}();

exports.default = SushiClient;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js")["default"];

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js")["default"];

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js");

var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js");

function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;

      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }

      desc = Object.getOwnPropertyDescriptor(receiver, property);

      if (desc) {
        if (!desc.writable) {
          return false;
        }

        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }

      return true;
    };
  }

  return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);

  if (!s && isStrict) {
    throw new Error('failed to set property');
  }

  return value;
}

module.exports = _set;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                    .replace(/<anonymous function(: (\w+))?>/, '$2')
                    .replace(/\([^)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

/* harmony default export */ __webpack_exports__["default"] = (finallyConstructor);


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./finally */ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js");


// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_0__["default"];

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ __webpack_exports__["default"] = (Promise);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = util.toSetString(aStr);
  var isDuplicate = has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = util.toSetString(aStr);
  return has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = util.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js").ArraySet;
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js");
var quickSort = __webpack_require__(/*! ./quick-sort */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js").quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js").ArraySet;
var MappingList = __webpack_require__(/*! ./mapping-list */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js").MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function() {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(StackFrame) {
    return {
        backtrace: function StackGenerator$$backtrace(opts) {
            var stack = [];
            var maxStackSize = 10;

            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {
                maxStackSize = opts.maxStackSize;
            }

            var curr = arguments.callee;
            while (curr && stack.length < maxStackSize && curr['arguments']) {
                // Allow V8 optimizations
                var args = new Array(curr['arguments'].length);
                for (var i = 0; i < args.length; ++i) {
                    args[i] = curr['arguments'][i];
                }
                if (/function(?:\s+([\w$]+))+\s*\(/.test(curr.toString())) {
                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));
                } else {
                    stack.push(new StackFrame({args: args}));
                }

                try {
                    curr = curr.caller;
                } catch (e) {
                    break;
                }
            }
            return stack;
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! source-map */ "./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js"), __webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(SourceMap, StackFrame) {
    'use strict';

    /**
     * Make a X-Domain request to url and callback.
     *
     * @param {String} url
     * @returns {Promise} with response text if fulfilled
     */
    function _xdr(url) {
        return new Promise(function(resolve, reject) {
            var req = new XMLHttpRequest();
            req.open('get', url);
            req.onerror = reject;
            req.onreadystatechange = function onreadystatechange() {
                if (req.readyState === 4) {
                    if ((req.status >= 200 && req.status < 300) ||
                        (url.substr(0, 7) === 'file://' && req.responseText)) {
                        resolve(req.responseText);
                    } else {
                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));
                    }
                }
            };
            req.send();
        });

    }

    /**
     * Convert a Base64-encoded string into its original representation.
     * Used for inline sourcemaps.
     *
     * @param {String} b64str Base-64 encoded string
     * @returns {String} original representation of the base64-encoded string.
     */
    function _atob(b64str) {
        if (typeof window !== 'undefined' && window.atob) {
            return window.atob(b64str);
        } else {
            throw new Error('You must supply a polyfill for window.atob in this environment');
        }
    }

    function _parseJson(string) {
        if (typeof JSON !== 'undefined' && JSON.parse) {
            return JSON.parse(string);
        } else {
            throw new Error('You must supply a polyfill for JSON.parse in this environment');
        }
    }

    function _findFunctionName(source, lineNumber/*, columnNumber*/) {
        var syntaxes = [
            // {name} = function ({args}) TODO args capture
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/,
            // function {name}({args}) m[1]=name m[2]=args
            /function\s+([^('"`]*?)\s*\(([^)]*)\)/,
            // {name} = eval()
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/,
            // fn_name() {
            /\b(?!(?:if|for|switch|while|with|catch)\b)(?:(?:static)\s+)?(\S+)\s*\(.*?\)\s*\{/,
            // {name} = () => {
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*\(.*?\)\s*=>/
        ];
        var lines = source.split('\n');

        // Walk backwards in the source lines until we find the line which matches one of the patterns above
        var code = '';
        var maxLines = Math.min(lineNumber, 20);
        for (var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            var line = lines[lineNumber - i - 1];
            var commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }

            if (line) {
                code = line + code;
                var len = syntaxes.length;
                for (var index = 0; index < len; index++) {
                    var m = syntaxes[index].exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                }
            }
        }
        return undefined;
    }

    function _ensureSupportedEnvironment() {
        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {
            throw new Error('Unable to consume source maps in older browsers');
        }
    }

    function _ensureStackFrameIsLegit(stackframe) {
        if (typeof stackframe !== 'object') {
            throw new TypeError('Given StackFrame is not an object');
        } else if (typeof stackframe.fileName !== 'string') {
            throw new TypeError('Given file name is not a String');
        } else if (typeof stackframe.lineNumber !== 'number' ||
            stackframe.lineNumber % 1 !== 0 ||
            stackframe.lineNumber < 1) {
            throw new TypeError('Given line number must be a positive integer');
        } else if (typeof stackframe.columnNumber !== 'number' ||
            stackframe.columnNumber % 1 !== 0 ||
            stackframe.columnNumber < 0) {
            throw new TypeError('Given column number must be a non-negative integer');
        }
        return true;
    }

    function _findSourceMappingURL(source) {
        var sourceMappingUrlRegExp = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/mg;
        var lastSourceMappingUrl;
        var matchSourceMappingUrl;
        // eslint-disable-next-line no-cond-assign
        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {
            lastSourceMappingUrl = matchSourceMappingUrl[1];
        }
        if (lastSourceMappingUrl) {
            return lastSourceMappingUrl;
        } else {
            throw new Error('sourceMappingURL not found');
        }
    }

    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {
        return new Promise(function(resolve, reject) {
            var loc = sourceMapConsumer.originalPositionFor({
                line: stackframe.lineNumber,
                column: stackframe.columnNumber
            });

            if (loc.source) {
                // cache mapped sources
                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);
                if (mappedSource) {
                    sourceCache[loc.source] = mappedSource;
                }

                resolve(
                    // given stackframe and source location, update stackframe
                    new StackFrame({
                        functionName: loc.name || stackframe.functionName,
                        args: stackframe.args,
                        fileName: loc.source,
                        lineNumber: loc.line,
                        columnNumber: loc.column
                    }));
            } else {
                reject(new Error('Could not get original source for given stackframe and source map'));
            }
        });
    }

    /**
     * @constructor
     * @param {Object} opts
     *      opts.sourceCache = {url: "Source String"} => preload source cache
     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}
     *      opts.offline = True to prevent network requests.
     *              Best effort without sources or source maps.
     *      opts.ajax = Promise returning function to make X-Domain requests
     */
    return function StackTraceGPS(opts) {
        if (!(this instanceof StackTraceGPS)) {
            return new StackTraceGPS(opts);
        }
        opts = opts || {};

        this.sourceCache = opts.sourceCache || {};
        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};

        this.ajax = opts.ajax || _xdr;

        this._atob = opts.atob || _atob;

        this._get = function _get(location) {
            return new Promise(function(resolve, reject) {
                var isDataUrl = location.substr(0, 5) === 'data:';
                if (this.sourceCache[location]) {
                    resolve(this.sourceCache[location]);
                } else if (opts.offline && !isDataUrl) {
                    reject(new Error('Cannot make network requests in offline mode'));
                } else {
                    if (isDataUrl) {
                        // data URLs can have parameters.
                        // see http://tools.ietf.org/html/rfc2397
                        var supportedEncodingRegexp =
                            /^data:application\/json;([\w=:"-]+;)*base64,/;
                        var match = location.match(supportedEncodingRegexp);
                        if (match) {
                            var sourceMapStart = match[0].length;
                            var encodedSource = location.substr(sourceMapStart);
                            var source = this._atob(encodedSource);
                            this.sourceCache[location] = source;
                            resolve(source);
                        } else {
                            reject(new Error('The encoding of the inline sourcemap is not supported'));
                        }
                    } else {
                        var xhrPromise = this.ajax(location, {method: 'get'});
                        // Cache the Promise to prevent duplicate in-flight requests
                        this.sourceCache[location] = xhrPromise;
                        xhrPromise.then(resolve, reject);
                    }
                }
            }.bind(this));
        };

        /**
         * Creating SourceMapConsumers is expensive, so this wraps the creation of a
         * SourceMapConsumer in a per-instance cache.
         *
         * @param {String} sourceMappingURL = URL to fetch source map from
         * @param {String} defaultSourceRoot = Default source root for source map if undefined
         * @returns {Promise} that resolves a SourceMapConsumer
         */
        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {
            return new Promise(function(resolve) {
                if (this.sourceMapConsumerCache[sourceMappingURL]) {
                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);
                } else {
                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {
                        return this._get(sourceMappingURL).then(function(sourceMapSource) {
                            if (typeof sourceMapSource === 'string') {
                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\)\]\}'/, ''));
                            }
                            if (typeof sourceMapSource.sourceRoot === 'undefined') {
                                sourceMapSource.sourceRoot = defaultSourceRoot;
                            }

                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));
                        }, reject);
                    }.bind(this));
                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;
                    resolve(sourceMapConsumerPromise);
                }
            }.bind(this));
        };

        /**
         * Given a StackFrame, enhance function name and use source maps for a
         * better StackFrame.
         *
         * @param {StackFrame} stackframe object
         * @returns {Promise} that resolves with with source-mapped StackFrame
         */
        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {
            return new Promise(function(resolve, reject) {
                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {
                    function resolveMappedStackFrame() {
                        resolve(mappedStackFrame);
                    }

                    this.findFunctionName(mappedStackFrame)
                        .then(resolve, resolveMappedStackFrame)
                        // eslint-disable-next-line no-unexpected-multiline
                        ['catch'](resolveMappedStackFrame);
                }.bind(this), reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, guess function name from location information.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureStackFrameIsLegit(stackframe);
                this._get(stackframe.fileName).then(function getSourceCallback(source) {
                    var lineNumber = stackframe.lineNumber;
                    var columnNumber = stackframe.columnNumber;
                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);
                    // Only replace functionName if we found something
                    if (guessedFunctionName) {
                        resolve(new StackFrame({
                            functionName: guessedFunctionName,
                            args: stackframe.args,
                            fileName: stackframe.fileName,
                            lineNumber: lineNumber,
                            columnNumber: columnNumber
                        }));
                    } else {
                        resolve(stackframe);
                    }
                }, reject)['catch'](reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureSupportedEnvironment();
                _ensureStackFrameIsLegit(stackframe);

                var sourceCache = this.sourceCache;
                var fileName = stackframe.fileName;
                this._get(fileName).then(function(source) {
                    var sourceMappingURL = _findSourceMappingURL(source);
                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';
                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);

                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\/\/|^\/\//i).test(sourceMappingURL)) {
                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;
                    }

                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)
                        .then(function(sourceMapConsumer) {
                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)
                                .then(resolve)['catch'](function() {
                                    resolve(stackframe);
                                });
                        });
                }.bind(this), reject)['catch'](reject);
            }.bind(this));
        };
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! error-stack-parser */ "./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js"), __webpack_require__(/*! stack-generator */ "./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js"), __webpack_require__(/*! stacktrace-gps */ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {
    var _options = {
        filter: function(stackframe) {
            // Filter out stackframes for this library by default
            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&
                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;
        },
        sourceCache: {}
    };

    var _generateError = function StackTrace$$GenerateError() {
        try {
            // Error must be thrown to get stack in IE
            throw new Error();
        } catch (err) {
            return err;
        }
    };

    /**
     * Merge 2 given Objects. If a conflict occurs the second object wins.
     * Does not do deep merges.
     *
     * @param {Object} first base object
     * @param {Object} second overrides
     * @returns {Object} merged first and second
     * @private
     */
    function _merge(first, second) {
        var target = {};

        [first, second].forEach(function(obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    target[prop] = obj[prop];
                }
            }
            return target;
        });

        return target;
    }

    function _isShapedLikeParsableError(err) {
        return err.stack || err['opera#sourceloc'];
    }

    function _filtered(stackframes, filter) {
        if (typeof filter === 'function') {
            return stackframes.filter(filter);
        }
        return stackframes;
    }

    return {
        /**
         * Get a backtrace from invocation point.
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        get: function StackTrace$$get(opts) {
            var err = _generateError();
            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);
        },

        /**
         * Get a backtrace from invocation point.
         * IMPORTANT: Does not handle source maps or guess function names!
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        getSync: function StackTrace$$getSync(opts) {
            opts = _merge(_options, opts);
            var err = _generateError();
            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);
            return _filtered(stack, opts.filter);
        },

        /**
         * Given an error object, parse it.
         *
         * @param {Error} error object
         * @param {Object} opts
         * @returns {Promise} for Array[StackFrame}
         */
        fromError: function StackTrace$$fromError(error, opts) {
            opts = _merge(_options, opts);
            var gps = new StackTraceGPS(opts);
            return new Promise(function(resolve) {
                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);
                resolve(Promise.all(stackframes.map(function(sf) {
                    return new Promise(function(resolve) {
                        function resolveOriginal() {
                            resolve(sf);
                        }

                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);
                    });
                })));
            }.bind(this));
        },

        /**
         * Use StackGenerator to generate a backtrace.
         *
         * @param {Object} opts
         * @returns {Promise} of Array[StackFrame]
         */
        generateArtificially: function StackTrace$$generateArtificially(opts) {
            opts = _merge(_options, opts);
            var stackFrames = StackGenerator.backtrace(opts);
            if (typeof opts.filter === 'function') {
                stackFrames = stackFrames.filter(opts.filter);
            }
            return Promise.resolve(stackFrames);
        },

        /**
         * Given a function, wrap it such that invocations trigger a callback that
         * is called with a stack trace.
         *
         * @param {Function} fn to be instrumented
         * @param {Function} callback function to call with a stack trace on invocation
         * @param {Function} errback optional function to call with error if unable to get stack trace.
         * @param {Object} thisArg optional context object (e.g. window)
         */
        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                // Already instrumented, return given Function
                return fn;
            }

            var instrumented = function StackTrace$$instrumented() {
                try {
                    this.get().then(callback, errback)['catch'](errback);
                    return fn.apply(thisArg || this, arguments);
                } catch (e) {
                    if (_isShapedLikeParsableError(e)) {
                        this.fromError(e).then(callback, errback)['catch'](errback);
                    }
                    throw e;
                }
            }.bind(this);
            instrumented.__stacktraceOriginalFn = fn;

            return instrumented;
        },

        /**
         * Given a function that has been instrumented,
         * revert the function to it's original (non-instrumented) state.
         *
         * @param {Function} fn to de-instrument
         */
        deinstrument: function StackTrace$$deinstrument(fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot de-instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                return fn.__stacktraceOriginalFn;
            } else {
                // Function not instrumented, return original
                return fn;
            }
        },

        /**
         * Given an error message and Array of StackFrames, serialize and POST to given URL.
         *
         * @param {Array} stackframes
         * @param {String} url
         * @param {String} errorMsg
         * @param {Object} requestOptions
         */
        report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {
            return new Promise(function(resolve, reject) {
                var req = new XMLHttpRequest();
                req.onerror = reject;
                req.onreadystatechange = function onreadystatechange() {
                    if (req.readyState === 4) {
                        if (req.status >= 200 && req.status < 400) {
                            resolve(req.responseText);
                        } else {
                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));
                        }
                    }
                };
                req.open('post', url);

                // Set request headers
                req.setRequestHeader('Content-Type', 'application/json');
                if (requestOptions && typeof requestOptions.headers === 'object') {
                    var headers = requestOptions.headers;
                    for (var header in headers) {
                        if (Object.prototype.hasOwnProperty.call(headers, header)) {
                            req.setRequestHeader(header, headers[header]);
                        }
                    }
                }

                var reportPayload = {stack: stackframes};
                if (errorMsg !== undefined && errorMsg !== null) {
                    reportPayload.message = errorMsg;
                }

                req.send(JSON.stringify(reportPayload));
            });
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KatalMetricsDriverSushi = void 0;

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricsDriver2 = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/metricObject/KatalMetricType */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

var _katalSushiClient = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-sushi-client */ "./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var KAT_STANDALONE_NEXUS_PRODUCER_ID = 'katal';
var KAT_STANDALONE_DEFAULT_SOURCE_GROUPS = {
  test: 'com.amazon.eel.katal.metrics.core.nexus.gamma',
  prod: 'com.amazon.eel.katal.metrics.core.nexus'
};

var KatalMetricsDriverSushiBuilder = /*#__PURE__*/function () {
  function KatalMetricsDriverSushiBuilder() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushiBuilder);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(KatalMetricsDriverSushiBuilder, [{
    key: "withSushiClient",
    value: function withSushiClient(sushiClient) {
      console.log('withSushi client...');
      this.context.sushiClient = sushiClient;
      return this;
    }
  }, {
    key: "withDomainRealm",
    value: function withDomainRealm(domain, realm) {
      this.context.domain = domain;
      this.context.realm = realm;
      return this;
    }
  }, {
    key: "withCustomProducer",
    value: function withCustomProducer(sushiProducerId) {
      this.context.sushiProducer = sushiProducerId;
      return this;
    }
  }, {
    key: "withCustomSourceGroup",
    value: function withCustomSourceGroup(sourceGroupId) {
      this.context.sourceGroupId = sourceGroupId;
      return this;
    }
  }, {
    key: "withErrorHandler",
    value: function withErrorHandler(errorHandler) {
      this.context.errorHandler = errorHandler;
      return this;
    }
  }, {
    key: "withSushiClientOptions",
    value: function withSushiClientOptions(sushiClientOptions) {
      this.context.sushiClientOptions = sushiClientOptions;
      return this;
    }
  }, {
    key: "withSushiClientTransportOverride",
    value: function withSushiClientTransportOverride(sushiClientTransportOverride) {
      this.context.sushiClientTransportOverride = sushiClientTransportOverride;
      return this;
    }
  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsDriverSushi(this.context);
    }
  }]);
  return KatalMetricsDriverSushiBuilder;
}();

var KatalMetricsDriverSushi = /*#__PURE__*/function (_KatalMetricsDriver) {
  (0, _inherits2.default)(KatalMetricsDriverSushi, _KatalMetricsDriver);

  var _super = _createSuper(KatalMetricsDriverSushi);

  function KatalMetricsDriverSushi(options) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushi);
    _this = _super.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sushi", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "producerId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sourceGroupId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "errorHandler", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "combinedErrorHandler", function (err) {
      if (_this.errorHandler) {
        try {
          _this.errorHandler(err); // Return to avoid falling through to default error handler


          return;
        } catch (nextErr) {
          console.error("Error handling error publishing metrics:");
          console.error(nextErr); // Fall through
        }
      }

      _this.defaultErrorHandler(err);
    });
    var domain = options.domain,
        realm = options.realm,
        errorHandler = options.errorHandler,
        sushiClient = options.sushiClient,
        _options$sushiProduce = options.sushiProducer,
        producerId = _options$sushiProduce === void 0 ? KAT_STANDALONE_NEXUS_PRODUCER_ID : _options$sushiProduce,
        sushiClientOptions = options.sushiClientOptions,
        sushiClientTransportOverride = options.sushiClientTransportOverride; // custom source group always overrides defaults

    var sourceGroupId = options.sourceGroupId || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS[domain] || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS['test'];
    _this.sushi = sushiClient || _this.buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride);
    _this.errorHandler = errorHandler;
    _this.producerId = producerId;
    _this.sourceGroupId = sourceGroupId;
    return _this;
  }

  (0, _createClass2.default)(KatalMetricsDriverSushi, [{
    key: "beforeUnload",
    value:
    /**
     * Register a callback to be called right before the page unloads. This
     * allows for any final metrics, such as page visit duration, to be sent
     * before the user navigates away from the page or closes the tab.
     * NOTE: This is an experimental API and may change in the future.
     * @param cb The callback to call.
     */
    function beforeUnload(cb) {
      this.sushi.onSushiUnload(cb);
    }
    /**
     * Default error handler if the user-supplied error handler fails or is unset.  Should never be called unless
     * user-provided error handler misbehaves.
     *
     * @param err Unhandled error object
     */

  }, {
    key: "defaultErrorHandler",
    value: function defaultErrorHandler(err) {
      console.error("Error publishing metrics:");
      console.error(err);
    }
    /**
     * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
     * an exception, calls the default error handler as a fallback, which will just log the error to the console.
     *
     * @param err Error object to handle
     */

  }, {
    key: "withErrorHandling",
    value:
    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
  }, {
    key: "buildSushiClient",
    value: function buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride) {
      if (!domain || !realm) {
        throw new Error('KatalMetricsDriverSushi requires a domain and realm to build a sushi client.');
      }

      return new _katalSushiClient.default(KatalMetricsDriverSushi.getRealmName(realm), sourceGroupId, this.combinedErrorHandler, sushiClientOptions, sushiClientTransportOverride);
    }
  }, {
    key: "publish",
    value: // TODO: errorHandler in this method is deprecated and is not referenced.
    // Tech debt: https://issues.amazon.com/issues/KAT-875
    function publish(metricObject, errorHandler, context) {
      var _this2 = this;

      // Support for new 2-argument form of publish, which does not pass the unused errorHandler object (KAT-875)
      var metricsContext = arguments.length < 3 ? arguments[1] : arguments[2];
      this.withErrorHandling(function () {
        // TODO: This logic is now moved into KatalMetricsPublisher, once everybody has that update we can remove this.
        // Tech debt: https://issues.amazon.com/issues/KAT-876
        if (_KatalMetricType.default.List === metricObject.type) {
          metricObject.metricList.forEach(function (metric) {
            _this2.publish(metric, metricsContext);
          });
          return;
        }

        var nexusSchema = _this2.mapObjectTypeToNexusSchema(metricObject.type);

        var fields = _objectSpread(_objectSpread({}, metricsContext.context), {}, {
          metricKey: metricObject.name,
          value: metricObject.value
        });

        if (metricObject.isMonitor) {
          fields.isMonitor = true;
        } // Deleting cloudWatchDimensions field if exists as it applies only for KatalMonitoringAWSDriver.


        if (fields.cloudWatchDimensions) {
          delete fields.cloudWatchDimensions;
        } // Reset the event count back to 0, otherwise Sushi will stop publishing after 1K items (https://issues.amazon.com/issues/KAT-1534)


        _this2.sushi.reset();

        _this2.sushi.event(fields, _this2.producerId, nexusSchema, {
          "ssd": 1
        });
      });
    }
  }, {
    key: "mapObjectTypeToNexusSchema",
    value: function mapObjectTypeToNexusSchema(objectType) {
      switch (objectType) {
        case _KatalMetricType.default.String:
          return 'katal.client.metrics.String.2';

        case _KatalMetricType.default.Counter:
          return 'katal.client.metrics.Counter.3';

        case _KatalMetricType.default.Timer:
          return 'katal.client.metrics.Timer.2';

        default:
          throw new Error("Unknown type ".concat(objectType, " when publishing metric object."));
      }
    }
  }], [{
    key: "getRealmName",
    value: function getRealmName(realm) {
      switch (realm) {
        case 'NAAmazon':
        case 'USAmazon':
          return _katalSushiClient.default.REGIONS.NA;

        case 'EUAmazon':
          return _katalSushiClient.default.REGIONS.EU;

        case 'FEAmazon':
        case 'JPAmazon':
          return _katalSushiClient.default.REGIONS.FE;

        case 'CNAmazon':
          return _katalSushiClient.default.REGIONS.CN;

        default:
          // Let the SushiClient decide if this is bogus or not.
          return realm;
      }
    }
  }]);
  return KatalMetricsDriverSushi;
}(_KatalMetricsDriver2.default);

exports.KatalMetricsDriverSushi = KatalMetricsDriverSushi;
(0, _defineProperty2.default)(KatalMetricsDriverSushi, "Builder", KatalMetricsDriverSushiBuilder);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! ./nodejsShims */ 1);

var _KatalMetricsDriverSushi = __webpack_require__(/*! ./KatalMetricsDriverSushi */ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js");

/* istanbul ignore file */
var _default = _KatalMetricsDriverSushi.KatalMetricsDriverSushi;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ./helper/ValidateSimpleString */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _validateCloudWatchDimensions = _interopRequireDefault(__webpack_require__(/*! ./helper/validateCloudWatchDimensions */ "./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./helper/FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var REQUIRED_FIELDS = ['site', 'serviceName', 'methodName'];

var KatalMetricsContext = /*#__PURE__*/function () {
  /**
   * Create a new metrics context with the given fields.
   *
   * @param contextFields Context fields value (default empty)
   */
  function KatalMetricsContext() {
    var contextFields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, KatalMetricsContext);
    // Copy fields so this is immutable
    this.context = _objectSpread({}, contextFields);
  }
  /**
   * Return a new KatalMetricsContext which is a copy of this context, with values added or overridden from
   * the given context.
   *
   * If the given context is null or empty, this method may return the original object as an optimization.
   *
   * @param thatContext Context to merge values from
   * @return New context with default values from this context, and values overridden or added by the given context.
   */


  (0, _createClass2.default)(KatalMetricsContext, [{
    key: "merge",
    value: function merge(thatContext) {
      if (!thatContext) return this; // Check for a common error

      if (thatContext instanceof KatalMetricsContext.Builder) {
        throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
      }

      var context = thatContext instanceof KatalMetricsContext ? thatContext.context : thatContext;

      var newContext = _objectSpread(_objectSpread(_objectSpread({}, this.context), context), {}, {
        relatedMetrics: (0, _mergeLists.mergeLists)(this.context.relatedMetrics, context.relatedMetrics),
        relatedMetricsSingleAction: (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, context.relatedMetricsSingleAction),
        // Combines the dimensions from base publisher with any child publisher.
        cloudWatchDimensions: (0, _mergeLists.mergeLists)(this.context.cloudWatchDimensions, context.cloudWatchDimensions)
      });

      return new KatalMetricsContext(newContext);
    }
    /**
     * Return a new context which is a copy of this context with relatedMetricsSingleAction removed.
     *
     * This is intended to be called when creating a new child publisher.
     *
     * @return Copy of this context, with relatedMetricsSingleAction removed
     */

  }, {
    key: "withoutRelatedMetricsSingleAction",
    value: function withoutRelatedMetricsSingleAction() {
      return new KatalMetricsContext(_objectSpread(_objectSpread({}, this.context), {}, {
        relatedMetricsSingleAction: undefined
      }));
    }
    /**
     * Get a context suitable for publication to the driver.
     *
     * This method strips out any private fields, and leaves only fields from the schema that the driver should publish.
     *
     * @return Context suitable for driver publication
     */

  }, {
    key: "driverContext",
    value: function driverContext() {
      // Don't publish relatedMetrics to the driver
      var newContextFields = _objectSpread({}, this.context);

      delete newContextFields["relatedMetrics"];
      delete newContextFields["relatedMetricsSingleAction"];
      delete newContextFields["requestId"];

      if (this.context.requestId) {
        newContextFields.actionId = (0, _embedRequestId.embedRequestId)(newContextFields.actionId, this.context.requestId);
      }

      return new KatalMetricsContext(newContextFields);
    }
    /**
     * Get a simple JavaScript object with a copy of the fields for this context.
     *
     * @return Simple Javascript object with a copy of the fields for this context
     */

  }, {
    key: "getFields",
    value: function getFields() {
      // Copy fields so this remains immutable
      return _objectSpread({}, this.context);
    }
    /**
     * Check for a validation error on this context.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns Errors found with this context
     */

  }, {
    key: "validationError",
    value: function validationError() {
      var _this = this;

      var err; // Fields “site”, “serviceName”, “methodName”, and “metricKey” are required.

      err = (0, _FirstMap.default)(REQUIRED_FIELDS, function (field) {
        if (_this.context[field] == undefined) {
          return new Error("Field ".concat(field, " is required, but it is ").concat(_this.context[field]));
        }
      });
      if (err) return err;
      return (0, _FirstMap.default)(Object.keys(this.context), function (field) {
        return _this.validateField(field);
      });
    }
    /**
     * Validate an individual context field.
     *
     * @param field Name of field to validate
     * @returns Error found with this field, or undefined
     */

  }, {
    key: "validateField",
    value: function validateField(field) {
      var val = this.context[field];
      var nameForError = "field ".concat(field);

      switch (field) {
        // Strings which could be used as partition keys ("site" and "serviceName") cannot contain slashes, in
        // addition to the other restictions below.
        case 'site':
        case 'serviceName':
          if (val.indexOf('/') > -1) return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It cannot contain a slash."));
        // Else fall through
        // Strings for fields “site”, “serviceName”, “methodName”, “metricKey” must match be valid PMET field names:
        // maximum length of 256, only letters, numbers, and the dot, colon, at-sign, underscore, forward-slash,
        // and slash characters (in short the regex ^[A-Za-z0-9.:@_/-]+$).

        case 'methodName':
        case 'actionId':
          return (0, _ValidateSimpleString.default)(val, nameForError);

        case 'cloudWatchDimensions':
          return (0, _validateCloudWatchDimensions.default)(val || []);
      } // No error found, implicitly return undefined

    }
    /**
     * Builder class for KatalMetricsContext
     */

  }]);
  return KatalMetricsContext;
}();

exports.default = KatalMetricsContext;
(0, _defineProperty2.default)(KatalMetricsContext, "Builder", /*#__PURE__*/function () {
  function _class2() {
    (0, _classCallCheck2.default)(this, _class2);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_class2, [{
    key: "withSite",
    value: function withSite(site) {
      this.context.site = site;
      return this;
    }
  }, {
    key: "withServiceName",
    value: function withServiceName(serviceName) {
      this.context.serviceName = serviceName;
      return this;
    }
  }, {
    key: "withMethodName",
    value: function withMethodName(methodName) {
      this.context.methodName = methodName;
      return this;
    }
  }, {
    key: "withActionId",
    value: function withActionId(actionId) {
      this.context.actionId = actionId;
      return this;
    }
  }, {
    key: "withRequestId",
    value: function withRequestId(requestId) {
      this.context.requestId = requestId;
      return this;
    }
  }, {
    key: "withCloudWatchDimensions",
    value: function withCloudWatchDimensions(dimensions) {
      this.context.cloudWatchDimensions = dimensions;
      return this;
    }
    /**
     * Replace any related metrics with the given list (see addRelatedMetrics to add instead of replace).
     *
     * Related metrics are metrics that are published whenever a new action is started.  They are used to relate the
     * action back to the context where it is happening, for example a request ID or a user identity.
     *
     * @param relatedMetrics Related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetrics",
    value: function withRelatedMetrics() {
      for (var _len = arguments.length, relatedMetrics = new Array(_len), _key = 0; _key < _len; _key++) {
        relatedMetrics[_key] = arguments[_key];
      }

      this.context.relatedMetrics = relatedMetrics;
      return this;
    }
    /**
     * Add additional related metrics to this builder.  See withRelatedMetrics for more information.
     *
     * @param relatedMetrics Additional related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetrics",
    value: function addRelatedMetrics() {
      for (var _len2 = arguments.length, relatedMetrics = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        relatedMetrics[_key2] = arguments[_key2];
      }

      this.context.relatedMetrics = (0, _mergeLists.mergeLists)(this.context.relatedMetrics, relatedMetrics);
      return this;
    }
    /**
     * Replace single-action related metrics with the given list (see addRelatedMetricsSingleAction to add instead of replace,
     * and withRelatedMetrics for more information about related metrics).
     *
     * Single-action related metrics are published when a new child metric publisher is created, but not included as
     * related metrics for the new child metric publisher, so are not published again if the child metric publisher
     * creates grandchild published metrics.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetricsSingleAction",
    value: function withRelatedMetricsSingleAction() {
      for (var _len3 = arguments.length, metrics = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        metrics[_key3] = arguments[_key3];
      }

      this.context.relatedMetricsSingleAction = metrics;
      return this;
    }
    /**
     * Add additional single-action related metrics to this builder.  See addRelatedMetricsSingleAction for more information.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetricsSingleAction",
    value: function addRelatedMetricsSingleAction() {
      for (var _len4 = arguments.length, metrics = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        metrics[_key4] = arguments[_key4];
      }

      this.context.relatedMetricsSingleAction = (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, metrics);
      return this;
    }
    /**
     * Take the fields set in this builder and use them to create a new KatalMetricsContext.
     *
     * @return KatalMetricsContext object built with the parameters given to this builder
     */

  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsContext(this.context);
    }
  }]);
  return _class2;
}());

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _v = _interopRequireDefault(__webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _metricObject = __webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js");

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _metricsExtension = __webpack_require__(/*! ./helper/metricsExtension */ "./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var INITIALIZATION_METHOD_NAME = 'Initialization';

/**
 * Default error handler if the user-supplied error handler fails or is unset.
 * Should never be called unless user-provided error handler misbehaves.
 */
var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  console.error("Error publishing metrics:");
  console.error(err);
};

var PARENT_ACTION_ID_NAME = 'parentActionId';

var getContextFields = function getContextFields(context) {
  if (context.context) {
    return context.context;
  } else {
    return context;
  }
};
/**
 * Class used for publishing metrics to Katal.  Contains a driver and a context.
 *
 * This class knows how to publish metrics, and how to create new publishers with a modified context.
 */


var KatalMetricsPublisher = /*#__PURE__*/function () {
  /**
   * Create a new metrics publisher with the given driver and context
   *
   * @param driver Subclass of KatalMetricsDriver used to publish the metrics
   * @param errorHandler Handler for errors that occur while using this publisher
   * @param context Context for this metrics publisher; contains data to be included with every
   *     metric published using this publisher object.  Default is an empty context.
   */
  function KatalMetricsPublisher(driver) {
    var _this = this;

    var errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ERROR_HANDLER;
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _KatalMetricsContext.default();
    (0, _classCallCheck2.default)(this, KatalMetricsPublisher);
    (0, _defineProperty2.default)(this, "combinedErrorHandler", function (err) {
      try {
        _this.errorHandler(err);
      } catch (nextErr) {
        console.error("Error handling error publishing metrics:");
        console.error(nextErr);
        DEFAULT_ERROR_HANDLER(err);
      }
    });

    // Check for a common error
    if (context instanceof _KatalMetricsContext.default.Builder) {
      throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
    }

    this.driver = driver;
    this.errorHandler = errorHandler;
    this.context = !(context instanceof _KatalMetricsContext.default) ? new _KatalMetricsContext.default(context) : context;
  }
  /**
   * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
   * an exception, calls the default error handler as a fallback, which will just log the error to the console.
   *
   * @param err Error object to handle
   */


  (0, _createClass2.default)(KatalMetricsPublisher, [{
    key: "withErrorHandling",
    value:
    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
    /**
     * Helper method to return all the related metrics of base publisher and additionalContext.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @return Return all related metrics from base publisher and additionalContext.
     */

  }, {
    key: "getAdditionalRelatedMetrics",
    value: function getAdditionalRelatedMetrics(additionalContext) {
      var newContext = additionalContext instanceof _KatalMetricsContext.default ? additionalContext.context : additionalContext;
      var baseRelatedMetrics = this.getBaseRelatedMetrics();
      return (0, _mergeLists.mergeLists)(baseRelatedMetrics, newContext.relatedMetrics);
    }
    /**
     * Helper method to return all the related metrics of base publisher.
     *
     * @return Return all related metrics from the base publisher.
     */

  }, {
    key: "getBaseRelatedMetrics",
    value: function getBaseRelatedMetrics() {
      return (0, _mergeLists.mergeLists)(this.context.context.relatedMetrics, this.context.context.relatedMetricsSingleAction);
    }
    /**
     * Publish the given metric object.
     *
     * This method is guaranteed never to throw an exception.  If the metric object or context are invalid,
     * or any other exception is thrown while publishing, the publisher's error handler is called.  If the
     * publisher's error handler is unset or fails, the default error handler is called (see defaultErrorHandler).
     *
     * @param katalMetricObject Metric object to publish
     */

  }, {
    key: "publish",
    value: function publish(katalMetricObject) {
      var _this2 = this;

      this.withErrorHandling(function () {
        if (!katalMetricObject) {
          throw new Error("Cannot publish undefined/null metric object");
        }

        if (_metricObject.Object.Types.List === katalMetricObject.type) {
          katalMetricObject.metricList.forEach(function (metric) {
            _this2.publish(metric);
          });
        } else {
          var driverContext = _this2.context.driverContext();

          var contextError = driverContext.validationError();
          if (contextError) throw contextError;
          var objectError = katalMetricObject.validationError();
          if (objectError) throw objectError;
          (0, _metricsExtension.dispatchMetricEvent)(katalMetricObject, driverContext);

          _this2.driver.publish(katalMetricObject, driverContext);
        }
      });
    }
    /**
     * Create a new publisher which is identical to this publisher, but with the given context fields merged into
     * the new publisher's context.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildPublisher",
    value: function newChildPublisher(additionalContext) {
      return new KatalMetricsPublisher(this.driver, this.errorHandler, this.context.merge(additionalContext));
    }
    /**
     * Begin a new action, and return a new publisher for metrics related to that action.
     *
     * Beginning a new action involves the following steps:
     *   1. Generate a new actionId for the action, randomly in the browser
     *   2. If there are any related metrics in the context, publish them
     *   3. Create and return a new publisher with this object's context, merged with any additional context given,
     *      merged with the actionId generated above.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisher",
    value: function newChildActionPublisher(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var newContext = this.context.withoutRelatedMetricsSingleAction().merge({
        actionId: actionId
      }).merge(additionalContext);
      var newPublisher = new KatalMetricsPublisher(this.driver, this.errorHandler, newContext);
      var allRelatedMetrics = additionalContext && !(additionalContext instanceof _KatalMetricsContext.default.Builder) ? this.getAdditionalRelatedMetrics(additionalContext) : this.getBaseRelatedMetrics();

      if (allRelatedMetrics) {
        allRelatedMetrics.forEach(function (metric) {
          newPublisher.publish(metric);
        });
      }

      return newPublisher;
    }
    /**
     * Begin a new chained child action, and return a new publisher for metrics related to that action.
     *
     * A chained action is handled the same way as in newChildActionPublisher, but additionally,
     * the returned publisher has a relatedMetricNoInherit named "parentActionId", with the newly
     * generated actionId as its value.
     *
     * The effect of this is that any further chained child actions can be connected back to this
     * action through the parentActionId, and so on recursively.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChained",
    value: function newChildActionPublisherChained(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var parentActionId = (0, _embedRequestId.embedRequestId)(actionId, this.context.context.requestId);
      var relatedMetricsSingleAction = [new _metricObject.String(PARENT_ACTION_ID_NAME, parentActionId)];
      var newContext = new _KatalMetricsContext.default({
        actionId: actionId,
        relatedMetricsSingleAction: relatedMetricsSingleAction
      }).merge(additionalContext);
      return this.newChildActionPublisher(newContext);
    }
    /**
     * Helper method to create a new chained child action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherChained.
     *
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChainedForMethod",
    value: function newChildActionPublisherChainedForMethod(methodName, additionalContext) {
      return this.newChildActionPublisherChained(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherForMethod.
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForMethod",
    value: function newChildActionPublisherForMethod(methodName, additionalContext) {
      return this.newChildActionPublisher(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action for application initialization.  It will always have a methodName
     * of "Initialization"; otherwise this method is identical to newChildActionPublisherForMethod.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForInitialization",
    value: function newChildActionPublisherForInitialization(additionalContext) {
      return this.newChildActionPublisherForMethod(INITIALIZATION_METHOD_NAME, additionalContext);
    }
    /**
     * Helper method to publish a string with the given name and value.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishString",
    value: function publishString(name, value) {
      this.publish(new _metricObject.String(name, value));
    }
    /**
     * Helper method to publish a string with the given name and value, truncated to the maximum size allowed by the
     * schema.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishStringTruncate",
    value: function publishStringTruncate(name, value) {
      var object = new _metricObject.String(name, value);
      object.truncate = true;
      this.publish(object);
    }
    /**
     * Helper method to publish a counter with the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounter",
    value: function publishCounter(name, value) {
      this.publish(new _metricObject.Counter(name, value));
    }
    /**
     * Helper method to publish a timer with the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimer",
    value: function publishTimer(name, value) {
      this.publish(new _metricObject.Timer(name, value));
    }
    /**
     * Helper method to publish a counter with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounterMonitor",
    value: function publishCounterMonitor(name, value) {
      this.publish(new _metricObject.Counter(name, value).withMonitor());
    }
    /**
     * Helper method to publish a timer with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimerMonitor",
    value: function publishTimerMonitor(name, value) {
      this.publish(new _metricObject.Timer(name, value).withMonitor());
    }
    /**
     * Private helper method to extract an actionId from a context if one is provided, and otherwise generate a new one.
     *
     * @returns Action ID string
     */

  }, {
    key: "_generateActionid",
    value: function _generateActionid(context) {
      if (context) {
        var fields = getContextFields(context);

        if (fields.actionId) {
          return fields.actionId;
        }
      }

      return (0, _v.default)();
    }
  }]);
  return KatalMetricsPublisher;
}();

exports.default = KatalMetricsPublisher;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ERROR_HANDLER = void 0;

var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  throw err;
};

exports.DEFAULT_ERROR_HANDLER = DEFAULT_ERROR_HANDLER;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Abstract base class for a Katal metrics driver.
 */
var KatalMetricsDriver = /*#__PURE__*/function () {
  function KatalMetricsDriver() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriver);
  }

  (0, _createClass2.default)(KatalMetricsDriver, [{
    key: "publish",
    value:
    /**
     * Publish the given metric object with the given error handler and context.
     *
     * @param metricObject Metric object to publish.  Contains metricKey, isMonitor, type, and value.
     * @param context Context for publishing this metric.  Contains all other fields to be published.
     */
    function publish(metricObject, context) {
      throw new Error('KatalMetricsDriver is an abstract class, please choose a driver and use that instead');
    }
  }]);
  return KatalMetricsDriver;
}();

exports.default = KatalMetricsDriver;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = firstMap;

/**
 * Returns the first non-undefined value that results from running each value
 * in the given array through the mapper function.
 * @param array An array of values.
 * @param mapper A mapper function that should return a value or undefined.
 * @returns The first non-undefined value from the mapper function.
 */
function firstMap(array, mapper) {
  var toReturn = undefined;
  array.some(function (val) {
    toReturn = mapper(val);
    return toReturn != null;
  });
  return toReturn;
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectValues = Object.values ? Object.values : function (object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
};
var _default = objectValues;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleInt;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

/**
 * Number.isInteger is not in IE11, and letting Babel polyfill it added too much weight.
 * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 */
var isInteger = function isInteger(val) {
  return isFinite(val) && Math.floor(val) === val;
};
/**
 * Check if the given value is valid to be published to KatalMetrics as an integer (Counter or Timer),
 * and return either undefined (no error), or an Error object describing the problem.
 *
 * @param val Value to check
 * @param nameForError Name to use when constructing the error message, if necessary
 * @returns Error, or undefined if no error
 */


function validateSimpleInt(val, nameForError) {
  if (typeof val !== 'number') {
    return new Error("Expected ".concat(nameForError, " to have type 'number', but it was type '").concat((0, _typeof2.default)(val), "'"));
  }

  if (val < 0) {
    return new Error("Expected ".concat(nameForError, " to be positive, but it was ").concat(val));
  } // This will also catch NaN and Infinity


  if (!isInteger(val)) {
    return new Error("Expected ".concat(nameForError, " to be an integer, but it was ").concat(val));
  } // Couldn't find anything wrong, implicitly return undefined

}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleString;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var SIMPLE_STRING_PAT = /^[A-Za-z0-9.:@_/-]+$/;
var SIMPLE_STRING_MAX_LEN = 127;
/**
 * Check if the given value is valid to be published to KatalMetrics as a field value,
 * such as site, serviceName, methodName, or actionId (note this is not used to check values for string metrics).
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, it must be a non-empty string, less than 256 characters, containing only ASCII
 * letters, numbers, or these characters: .:@_/- (those are the PMET field value requirements).
 *
 * @param val String value to check
 * @param nameForError Name to use in the error message, if one is generated
 * @returns Error, or undefined if no error
 */

function validateSimpleString(val, nameForError) {
  if (typeof val !== "string") {
    return new Error("Expected ".concat(nameForError, " to be a string, but it was a ").concat((0, _typeof2.default)(val)));
  }

  if (val.length > SIMPLE_STRING_MAX_LEN) {
    return new Error("Expected ".concat(nameForError, " to be less than ").concat(SIMPLE_STRING_MAX_LEN, " characters, but it was ").concat(val.length, " characters"));
  }

  if (val.length < 1) {
    return new Error("Expected ".concat(nameForError, " to be non-blank"));
  }

  if (!SIMPLE_STRING_PAT.test(val)) {
    return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It can only contain letters, numbers, and these symbols: .:@_/-"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedRequestId = embedRequestId;

// until we can add a requestId field to the andes schema we will embed it in the actionId
function embedRequestId(actionId, requestId) {
  if (requestId) {
    return [requestId, actionId].join("::");
  }

  return actionId;
}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLists = mergeLists;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));

// Helper method to merge two lists which could be undefined
// Returns merged lists if either is defined, otherwise returns undefined
function mergeLists(list1, list2) {
  if (list1 || list2) {
    return [].concat((0, _toConsumableArray2.default)(list1 || []), (0, _toConsumableArray2.default)(list2 || []));
  } else {
    return undefined;
  }
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchMetricEvent = dispatchMetricEvent;

/**
 * Publish to external parties that are 
 * listening for katal.metrics.publish Custom Events
 */
function dispatchMetricEvent(metric, context) {
  if (typeof window === 'undefined') {
    return;
  }

  dispatchCustomEvent(metric, context); // for legacy purposes, also publish to __KATAL_METRICS_EXTENSION__

  publishToMetricsExtension(metric, context);
}

function dispatchCustomEvent(metric, context) {
  if (typeof CustomEvent !== "function") {
    return;
  }

  var event = new CustomEvent('katal.metrics.publish', {
    detail: {
      metric: metric,
      context: context.getFields()
    }
  });
  window.dispatchEvent(event);
}
/**
 * @Deprecated
 * Publish to https://code.amazon.com/packages/KatalMetricsExtension
 * The extension injects a global __KATAL_METRICS_EXTENSION__ object with a
 * `publish` method.
 */


function publishToMetricsExtension(metric, context) {
  var extension = window.__KATAL_METRICS_EXTENSION__;

  if (extension) {
    extension.publish(metric, context.getFields());
  }
}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateCloudWatchDimensions;

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var PRINTABLE_ASCII_PATTERN = /^[\x20-\x7E]+$/;
var AT_LEAST_ONE_NON_WHITESPACE_PATTERN = /^.*\S+.*$/;
var DIMENSION_NAME_STRING_MAX_LEN = 255;
var DIMENSION_VALUE_STRING_MAX_LEN = 1024;
/**
 * Check if the given dimensions are valid to be published to KatalMonitoring back-end.
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, name and value of string metrics must follow restrictions as described by
 * CloudWatch Dimension API Documentation:
 * https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_Dimension.html
 *
 * @param dimensions Array of string metrics to check
 * @returns Error, or undefined if no error
 */

function validateCloudWatchDimensions(dimensions) {
  return (0, _FirstMap.default)(dimensions, function (dimension) {
    var name = dimension.name,
        value = dimension.value;
    return validateCloudWatchDimension(name, value);
  });
}
/**
 * Check if the given dimension is valid as described by CloudWatch documentation.
 * https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_Dimension.html
 *
 * @param name CloudWatch Dimension Name String to check
 * @param value CloudWatch Dimension Value String to check
 * @returns Error, or undefined if no error
 */


function validateCloudWatchDimension(name, value) {
  if (name.length > DIMENSION_NAME_STRING_MAX_LEN) {
    return new Error("Expected Dimension name for value ".concat(value, " to be ").concat(DIMENSION_NAME_STRING_MAX_LEN, " characters or less, but it was ").concat(name.length, " characters"));
  }

  if (name.length < 1) {
    return new Error("Expected Dimension name for value ".concat(value, " to be non-blank"));
  }

  if (!PRINTABLE_ASCII_PATTERN.test(name)) {
    return new Error("Expected Dimension name for value ".concat(value, " to contain only ASCII characters, but it was ").concat(name));
  }

  if (!AT_LEAST_ONE_NON_WHITESPACE_PATTERN.test(name)) {
    return new Error("Expected Dimension name for value ".concat(value, " to contain at least one non whitespace character, but it was ").concat(name));
  }

  if (name.startsWith(":")) {
    return new Error("Expected Dimension name for value ".concat(value, " to not start with a colon (\":\"), but it was ").concat(name));
  }

  if (value.length > DIMENSION_VALUE_STRING_MAX_LEN) {
    return new Error("Expected Dimension value for name ".concat(name, " to be ").concat(DIMENSION_VALUE_STRING_MAX_LEN, " characters or less, but it was ").concat(value.length, " characters"));
  }

  if (value.length < 1) {
    return new Error("Expected Dimension value for name ".concat(name, " to be non-blank"));
  }

  if (!PRINTABLE_ASCII_PATTERN.test(value)) {
    return new Error("Expected Dimension value for name ".concat(name, " to contain only ASCII characters, but it was ").concat(value));
  }

  if (!AT_LEAST_ONE_NON_WHITESPACE_PATTERN.test(value)) {
    return new Error("Expected Dimension value for name ".concat(name, " to contain at least one non whitespace character, but it was ").concat(value, "}"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CloudWatchDimensions", {
  enumerable: true,
  get: function get() {
    return _CloudWatchDimensions.CloudWatchDimensions;
  }
});
Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsContext.default;
  }
});
Object.defineProperty(exports, "ErrorHandler", {
  enumerable: true,
  get: function get() {
    return _ErrorHandler.ErrorHandler;
  }
});
exports.Metric = void 0;
Object.defineProperty(exports, "MetricsDriver", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsDriver.default;
  }
});
Object.defineProperty(exports, "Publisher", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsPublisher.default;
  }
});

var Metric = _interopRequireWildcard(__webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js"));

exports.Metric = Metric;

var _KatalMetricsPublisher = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsPublisher */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricsDriver = _interopRequireDefault(__webpack_require__(/*! ./driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _ErrorHandler = __webpack_require__(/*! ./driver/ErrorHandler */ "./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js");

var _CloudWatchDimensions = __webpack_require__(/*! ./types/CloudWatchDimensions */ "./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Counter type.
 *
 * Can be used to count the number of times an event happened on a page, or as a simple 1/0 counter to track
 * success and failure.
 */
var KatalMetricCounter = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricCounter, _KatalMetricObject);

  var _super = _createSuper(KatalMetricCounter);

  /**
   * Create a new counter with the given name and value.
   *
   * @param name Counter name
   * @param value Counter value
   */
  function KatalMetricCounter(name) {
    var _this;

    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, KatalMetricCounter);
    _this = _super.call(this, name);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this counter
   *
   * @return Counter value
   */


  (0, _createClass2.default)(KatalMetricCounter, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set a new value for this counter
     *
     * @param value New value for this counter
     */
    ,
    set: function set(value) {
      // Math.round will also coerce from a string if necessary, and return NaN if invalid
      this._value = Math.round(value);
    }
    /**
     * Gets the type for this counter.
     *
     * @return Always returns "Counter".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Counter;
    }
    /**
     * Add a number to this counter.
     *
     * Can also be negative to subtract.
     *
     * @param addValue Amount to add to this counter
     */

  }, {
    key: "add",
    value: function add(addValue) {
      this.value += addValue;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricCounter.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Counter metrics object '".concat(this.name, "'"));
    }
  }]);
  return KatalMetricCounter;
}(_KatalMetricObject2.default);

exports.default = KatalMetricCounter;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Standardized metric for instrumenting HTTP requests.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name you provide prefixed with "HTTPRequest.".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * It has additional properties which will be emitted if set; see url, statusCode, and statusText.
 *
 * For example, if you gave the name "Search", these metrics will be created:
 *   HTTPRequest.Search.Latency - Latency for this request
 *   HTTPRequest.Search.Failure - Failure for this request (1 for failure, 0 for success)
 */
var KatalMetricHttpRequest = /*#__PURE__*/function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricHttpRequest, _KatalMetricTimedAtte);

  var _super = _createSuper(KatalMetricHttpRequest);

  /** The prefix for this metric. */

  /** The suffix for URL metrics of this class. */

  /** The suffix for HTTP response code metrics of this class. */

  /** The suffix for HTTP response text metrics of this class. */

  /**
   * Create a new HTTP Request timed attempt metric incorporating the given name.
   *
   * The name you give will be used to create a KatalMetricTimedAttempt with the provided name prefixed with "HTTPRequest.".
   *
   * @param name Name of this metric; resulting metrics will prefix this name with "HTTPRequest."
   */
  function KatalMetricHttpRequest(name) {
    (0, _classCallCheck2.default)(this, KatalMetricHttpRequest);
    return _super.call(this, "".concat(KatalMetricHttpRequest.HTTP_REQUEST_PREFIX, ".").concat(name));
  }
  /**
   * Set the url for this metric.
   *
   * A string metric will be added to the list of objects that will be published for this metric.  Its name will
   * be this metrics name suffixed with '.URL', and its value will be the URL value given here.
   *
   * @param value URL for this metric
   */


  (0, _createClass2.default)(KatalMetricHttpRequest, [{
    key: "url",
    get:
    /**
     * Get the URL for this metric, if defined.
     *
     * @return The URL for this metric, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Get the URL metric object associated with this metric, if defined.
     *
     * @return Associated URL metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "urlMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Set the HTTP response status code for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusCode', and its value will be the status code value given here.
     *
     * @param value HTTP response status code for this metric
     */

  }, {
    key: "statusCode",
    get:
    /**
     * Get the HTTP response status code for this metric, if defined.
     *
     * @return Associated HTTP response status code metric object, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Get the HTTP response status code metric object associated with this metric, if defined.
     *
     * @return HTTP response status code metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "statusCodeMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Set the HTTP response status text for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusText', and its value will be the status text value given here.
     *
     * @param statusText HTTP response status text for this metric, or undefined to remove
     */

  }, {
    key: "statusText",
    get:
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "statusTextMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
  }]);
  return KatalMetricHttpRequest;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricHttpRequest;
(0, _defineProperty2.default)(KatalMetricHttpRequest, "HTTP_REQUEST_PREFIX", 'HTTPRequest');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "URL_SUFFIX", 'URL');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_CODE_SUFFIX", 'StatusCode');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_TEXT_SUFFIX", 'StatusText');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Standardized metric for instrumenting application initialization.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name "Initialization".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * By default, these metrics will be created:
 *   Initialization.Latency - Latency for application initialization
 *   Initialization.Failure - Failure for this application initialization (1 for failure, 0 for success)
 */
var KatalMetricInitialization = /*#__PURE__*/function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricInitialization, _KatalMetricTimedAtte);

  var _super = _createSuper(KatalMetricInitialization);

  /** The name for this metric. */

  /**
   * Create a new timed attempt metric named "Initialization", for recording latency and failure information about
   * your application's initialization.
   */
  function KatalMetricInitialization() {
    (0, _classCallCheck2.default)(this, KatalMetricInitialization);
    return _super.call(this, KatalMetricInitialization.INITIALIZE_METRIC_NAME);
  }

  return KatalMetricInitialization;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricInitialization;
(0, _defineProperty2.default)(KatalMetricInitialization, "INITIALIZE_METRIC_NAME", 'Initialization');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObjectList */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js"));

var _ObjectValuesPonyfill = _interopRequireDefault(__webpack_require__(/*! ../helper/ObjectValuesPonyfill */ "./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Metric object list that tracks metrics by name, and generates metrics prefixed with the name of this object.
 */
var KatalMetricNamedObjectList = /*#__PURE__*/function (_KatalMetricObjectLis) {
  (0, _inherits2.default)(KatalMetricNamedObjectList, _KatalMetricObjectLis);

  var _super = _createSuper(KatalMetricNamedObjectList);

  /**
   * Create a new named object list.
   *
   * The name given here will be used to prefix all metrics.
   *
   * @param name Name of this metric
   */
  function KatalMetricNamedObjectList(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricNamedObjectList);
    _this = _super.call(this, name);
    _this.namedMetrics = {};
    return _this;
  }

  (0, _createClass2.default)(KatalMetricNamedObjectList, [{
    key: "metricList",
    get: function get() {
      return (0, _ObjectValuesPonyfill.default)(this.namedMetrics);
    }
    /**
     * Replace the metric with the given name with a new metric generated by the given function.
     *
     * If the newly created metric supports monitoring, its isMonitor flag will be set to the value of the
     * isMonitor flag for this containing object.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     */

  }, {
    key: "setNamedMetric",
    value: function setNamedMetric(subName, metricCreator) {
      var fullName = this.getNameForSubMetric(subName);
      var metric = metricCreator(fullName);

      if (metric.canMonitor) {
        metric.isMonitor = this.isMonitor;
      }

      this.namedMetrics[subName] = metric;
    }
    /**
     * If the given value is undefined or null, delete the metric with the give name; otherwise if the given named
     * metric already exists update its value; otherwise create a new metric of the given type and set its value.
     *
     * This specialized helper method is designed to deal with the common case of a value setter in a more complex
     * metric.  Outside of subclasses, other methods will probably prove more useful.
     *
     * If the value is null the metric will also be deleted.
     *
     * @param subName Name of metric to create or delete
     * @param newValueClass Class of new metric to create
     * @param newValue New value for this metric (or undefined to delete the metric)
     */

  }, {
    key: "setOrDeleteNamedMetricValue",
    value: function setOrDeleteNamedMetricValue(subName, newValueClass, newValue) {
      if (newValue == undefined) {
        this.deleteNamedMetric(subName);
      } else {
        var metric = this.getOrCreateNamedMetric(subName, function (name) {
          return new newValueClass(name, newValue);
        });
        metric.value = newValue;
      }
    }
    /**
     * Get the sub-metric with the given name if it exists, otherwise use the given function to create a new metric and
     * store and return that.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     * @return Metric object which was retrieved or created
     */

  }, {
    key: "getOrCreateNamedMetric",
    value: function getOrCreateNamedMetric(subName, metricCreator) {
      if (!this.namedMetrics[subName]) {
        this.setNamedMetric(subName, metricCreator);
      }

      return this.namedMetrics[subName];
    }
    /**
     * Return the given named sub-metric, if it exists.
     *
     * @param {string} subName Name of this sub-metric
     * @return {KatalMetricObject | undefined} Metric object with this name if it exists, otherwise undefined
     */

  }, {
    key: "getNamedMetric",
    value: function getNamedMetric(subName) {
      return this.namedMetrics[subName];
    }
    /**
     * Delete the given named sub-metric.
     *
     * @param subName Name of this sub-metric
     */

  }, {
    key: "deleteNamedMetric",
    value: function deleteNamedMetric(subName) {
      delete this.namedMetrics[subName];
    }
    /**
     * Get the value for the given metric, or undefined if the metric does not exist.
     *
     * @param subName Name of this sub-metric
     * @return Value for the given metric, or undefined if the metric does not exist
     */

  }, {
    key: "getNamedMetricValue",
    value: function getNamedMetricValue(subName) {
      var metric = this.getNamedMetric(subName);
      if (!metric) return undefined;
      return metric.value;
    }
    /**
     * Generate a name for the given sub-metric.
     *
     * @param subName Name of this sub-metric
     * @return Full name for this sub-metric
     */

  }, {
    key: "getNameForSubMetric",
    value: function getNameForSubMetric(subName) {
      return "".concat(this.name, ".").concat(subName);
    }
  }]);
  return KatalMetricNamedObjectList;
}(_KatalMetricObjectList.default);

exports.default = KatalMetricNamedObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleString */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricType */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

/**
 * Abstract base class for a single metric in Katal.
 *
 * A single metric contains the name (metricKey), value, type, and the isMonitor flag; everything else is in the
 * KatalMetricsContext it is published to.
 */
var KatalMetricObject = /*#__PURE__*/function () {
  /**
   * Metric types.
   */

  /**
   * Create a new KatalMetricObject with the given name.
   *
   * @param name Name for this metric; published as metricKey field
   */
  function KatalMetricObject(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObject);
    this._name = name;
    this._isMonitor = false;
  }
  /**
   * Get the name for this metric.
   *
   * Note that the name is immutable, and this cannot be set.
   *
   * @returns Name for this metric
   */


  (0, _createClass2.default)(KatalMetricObject, [{
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Alias for name.
     *
     * @returns Name for this metric
     */

  }, {
    key: "metricKey",
    get: function get() {
      return this._name;
    }
    /**
     * Set the isMonitor flag for this metric, and returns this object for continued use.
     *
     * This flag determines if the metric can be used for dashboards and alarms (i.e. if it will be published to PMET)
     * @param isMonitor New value for the isMonitor flag; defaults to true
     * @returns This object
     */

  }, {
    key: "withMonitor",
    value: function withMonitor() {
      var isMonitor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isMonitor = isMonitor;
      return this;
    }
    /**
     * Set the isMonitor flag for this metric.
     *
     * The value is forced to a boolean based on its truthiness.
     *
     * @param isMonitor New value for the isMonitor flag
     */

  }, {
    key: "isMonitor",
    get:
    /**
     * Get the isMonitor flag for this metric.
     *
     * @returns isMonitor flag for this metric.
     */
    function get() {
      return this._isMonitor;
    }
    /**
     * Check if this metric can be meaningfully monitored.
     *
     * Subclasses must override this.
     *
     * @return Whether this metric can be meaningfully monitored
     */
    ,
    set: function set(isMonitor) {
      this._isMonitor = !!isMonitor;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement canMonitor');
    }
    /**
     * Get the type of this metric.
     *
     * @return Type of this metric (one of: String, Counter, Timer, List)
     */

  }, {
    key: "type",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement type getter');
    }
    /**
     * Check for a validation error on this object.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns {Error | undefined} Error found with this object, or undefined if no error is found
     */

  }, {
    key: "validationError",
    value: function validationError() {
      if (this.isMonitor !== undefined && typeof this.isMonitor !== 'boolean') {
        return new Error("Field isMonitor should be a boolean, but it was a ".concat((0, _typeof2.default)(this.isMonitor)));
      }

      return (0, _ValidateSimpleString.default)(this.name, 'field name');
    }
  }]);
  return KatalMetricObject;
}();

exports.default = KatalMetricObject;
(0, _defineProperty2.default)(KatalMetricObject, "Types", _KatalMetricType.default);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@babel/runtime/helpers/set.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ../helper/FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Abstract metric that contains a list of other metrics; when it is published, the list of metrics is retrieved, and all
 * are published.
 */
var KatalMetricObjectList = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricObjectList, _KatalMetricObject);

  var _super = _createSuper(KatalMetricObjectList);

  /**
   * Create a new KatalMetricObjectList.
   *
   * @param name Name for this metric.  Not really used, but present for consistency with other metrics.
   */
  function KatalMetricObjectList(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObjectList);
    return _super.call(this, name);
  }
  /**
   * Get the list of for this object
   *
   * @returns Array of metrics for this object
   */


  (0, _createClass2.default)(KatalMetricObjectList, [{
    key: "metricList",
    get: function get() {
      throw new Error('Subclass of KatalMetricObjectList must implement metricList getter');
    }
  }, {
    key: "isMonitor",
    get: // This just delegates to the superclass, but if we override the setter without overriding the getter
    // getting the property will always return undefined.
    function get() {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", this);
    },
    set: function set(isMonitor) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", isMonitor, this, true);
      this.metricList.forEach(function (metric) {
        if (metric.canMonitor) {
          metric.isMonitor = isMonitor;
        }
      });
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.List;
    }
    /**
     * If any of the contained metrics are invalid, return the first validation error encountered; otherwise return
     * undefined.
     *
     * Note that this isn't called by the publisher; it validates each sub-metric on its own.
     *
     * @returns Error found with submetric, if any; else undefined
     */

  }, {
    key: "validationError",
    value: function validationError() {
      // Doesn't make sense to check superclass error here, since it is the contained metrics that matter.
      return (0, _FirstMap.default)(this.metricList, function (metric) {
        return metric.validationError();
      });
    }
  }]);
  return KatalMetricObjectList;
}(_KatalMetricObject2.default);

exports.default = KatalMetricObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * String type.
 *
 * Can be used to store arbitrary strings of data.
 */
var KatalMetricString = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricString, _KatalMetricObject);

  var _super = _createSuper(KatalMetricString);

  /**
   * Create a string with the given name and value.
   *
   * @param name String name
   * @param value String value
   */
  function KatalMetricString(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricString);
    _this = _super.call(this, name);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "truncate", false);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this string metric.
   *
   * @return Value for this metric
   */


  (0, _createClass2.default)(KatalMetricString, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this string metric.
     *
     * The new value should be a string, but number and boolean types will be automatically converted to strings.
     * For other types, including undefined and null, the value will be accepted, but will fail validation when publishing.
     *
     * @param value New value for this metric
     */
    ,
    set: function set(value) {
      if (typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
      }

      this._value = value;
    }
    /**
     * Truncation flag for this string metric.
     *
     * If set, the value here will be automatically truncated to the maximum size allowed by the current schema.
     * Otherwise, sending a value larger than allowed will result in a failure.
     *
     * @param value True to automatically truncate metrics, otherwise false
     */

  }, {
    key: "type",
    get:
    /**
     * Gets the type for this metric.
     *
     * @return Always returns "String".
     */
    function get() {
      return _KatalMetricObject2.default.Types.String;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return false;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricString.prototype), "validationError", this).call(this);
      if (superError) return superError;

      if (typeof this.value !== 'string') {
        return new Error("Expected field value in String metrics object '".concat(this.name, "' to be type string, but it was ").concat((0, _typeof2.default)(this.value)));
      }

      if (this.value.length > KatalMetricString.MAX_SIZE) {
        if (this.truncate) {
          this.value = this.value.substring(0, KatalMetricString.MAX_SIZE);
        } else {
          return new Error("Expected field value in String metrics object '".concat(this.name, "' to be ").concat(KatalMetricString.MAX_SIZE, " characters or less, but it was ").concat(this.value.length, " characters."));
        }
      } // Didn't find anything wrong, implicitly return undefined

    }
  }]);
  return KatalMetricString;
}(_KatalMetricObject2.default);

exports.default = KatalMetricString;
(0, _defineProperty2.default)(KatalMetricString, "MAX_SIZE", 256);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricNamedObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricNamedObjectList */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Metric that pairs a timer and a failure counter to record the time and status of an attempt to do something.
 */
var KatalMetricTimedAttempt = /*#__PURE__*/function (_KatalMetricNamedObje) {
  (0, _inherits2.default)(KatalMetricTimedAttempt, _KatalMetricNamedObje);

  var _super = _createSuper(KatalMetricTimedAttempt);

  /** The sub-metric name for latency. */

  /** The sub-metric name for failure count. */

  /**
   * Create a new timed attempt with the given name
   *
   * This will create two inner metrics, a KatalMetricCounter that has the given name with ".Failure" appended,
   * and a KatalMetricTimerStopwatch that has the given name with ".Latency" appended.
   *
   * @param name Name of this attempt
   */
  function KatalMetricTimedAttempt(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimedAttempt);
    _this = _super.call(this, name);

    _this.setNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX, function (name) {
      return new _KatalMetricTimerStopwatch.default(name);
    });

    _this.setNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX, function (name) {
      return new _KatalMetricCounter.default(name, 1);
    });

    return _this;
  }
  /**
   * Set the failure counter metric based on the given failure status.
   *
   * If failure is true the counter will have a value of 1; if it is false the counter will have a value of 0.
   *
   * @param failure Whether this is a failure or not; default true
   */


  (0, _createClass2.default)(KatalMetricTimedAttempt, [{
    key: "setFailure",
    value: function setFailure() {
      var failure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var failureCount = failure ? 1 : 0;
      var metric = this.failureMetric;
      metric.value = failureCount;
    }
    /**
     * Set the failure status to false.
     */

  }, {
    key: "setSuccess",
    value: function setSuccess() {
      this.setFailure(false);
    }
    /**
     * Set the latency metric to the given value, in milliseconds.
     *
     * Note you don't normally have to set this, the underlying metric is a KatalMetricTimerStopwatch that will start
     * and stop automatically.
     *
     * @param latencyMs Latency in milliseconds
     */

  }, {
    key: "setLatency",
    value: function setLatency(latencyMs) {
      var metric = this.latencyMetric;
      metric.value = latencyMs;
    }
    /**
     * Get the timer stopwatch metric for this attempt.
     *
     * @return Timer stopwatch metric for this attempt
     */

  }, {
    key: "latencyMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX);
    }
    /**
     * Get the failure counter metric for this attempt.
     *
     * @return Failure counter metric for this event
     */

  }, {
    key: "failureMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX);
    }
  }]);
  return KatalMetricTimedAttempt;
}(_KatalMetricNamedObjectList.default);

exports.default = KatalMetricTimedAttempt;
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "LATENCY_SUFFIX", 'Latency');
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "FAILURE_SUFFIX", 'Failure');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Timer type.
 *
 * Can be used to record a time.  This class requires explicit value; see KatalMetricTimerStopwatch for automatic
 * timing.
 */
var KatalMetricTimer = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricTimer, _KatalMetricObject);

  var _super = _createSuper(KatalMetricTimer);

  /**
   * Create a new timer metric.
   *
   * @param name Name for the metric
   * @param value Timer value in milliseconds
   */
  function KatalMetricTimer(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimer);
    _this = _super.call(this, name);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this timer
   *
   * @return Timer value in milliseconds
   */


  (0, _createClass2.default)(KatalMetricTimer, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this timer
     *
     * @param value New timer value in milliseconds
     */
    ,
    set: function set(value) {
      if (value == undefined) {
        this._value = value;
        return;
      } // Math.round will also coerce from a string if necessary, and return NaN if invalid


      this._value = Math.round(value);
    }
    /**
     * Get the type for this timer.
     *
     * @return Always returns "Timer".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Timer;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimer.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Timer metrics object '".concat(this.name, "'"));
    }
  }]);
  return KatalMetricTimer;
}(_KatalMetricObject2.default);

exports.default = KatalMetricTimer;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@babel/runtime/helpers/set.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricTimer2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Subclass of KatalMetricTimer that can be started and stopped, and will record the elapsed time between starting and
 * stopping.  By default it will start when the object is created, and stopped when the value is retrieved with
 * the getter "value".
 */
var KatalMetricTimerStopwatch = /*#__PURE__*/function (_KatalMetricTimer) {
  (0, _inherits2.default)(KatalMetricTimerStopwatch, _KatalMetricTimer);

  var _super = _createSuper(KatalMetricTimerStopwatch);

  /**
   * Create a new timer with the given name and starting time.  If no starting time is given, the current time is used.
   *
   * @param name Name for this timer
   * @param startTime Millisecond epoch time for the start time; defaults to now
   */
  function KatalMetricTimerStopwatch(name, startTime) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimerStopwatch);
    _this = _super.call(this, name, undefined);

    _this.start(startTime);

    _this._value = undefined;
    return _this;
  }
  /**
   * Re-start timer with the given start time, or the current time if none is given.
   *
   * @param startTime When the timer was started, in epoch milliseconds; defaults to now
   */


  (0, _createClass2.default)(KatalMetricTimerStopwatch, [{
    key: "start",
    value: function start(startTime) {
      this._startTime = startTime || this.now();
    }
    /**
     * Stop the timer and record the elapsed time.
     *
     * @param stopTime When the timer was stopped, in epoch milliseconds; defaults to now
     */

  }, {
    key: "stop",
    value: function stop(stopTime) {
      return this._stopTime = stopTime || this.now();
    }
    /**
     * Check if the timer has been stopped.
     *
     * @returns Whether the timer has been stopped yet
     */

  }, {
    key: "isStopped",
    get: function get() {
      return this._stopTime !== undefined;
    }
    /**
     * Get the elapsed time between when the timer was started and stopped; if the timer has not yet been stopped,
     * stop it first.
     *
     * @returns Elapsed time between when timer was started and stopped
     */

  }, {
    key: "value",
    get: function get() {
      if ((0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this) === undefined) {
        if (!this.isStopped) {
          this.stop();
        } // Rely on super.value setter to round


        (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this.stopTime - this.startTime, this, true);
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this);
    }
    /**
     * Get when this timer was started.
     *
     * @return Start time, in epoch milliseconds
     */
    ,
    set:
    /**
     * Set the value for this metric.  Note this will override the stopwatch behavior and just use the given value.
     *
     * @param value Value for this metric
     */
    function set(value) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", value, this, true);
    }
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    }
    /**
     * Get when this timer was stopped (or undefined if it is still running)
     *
     * @return Stop time, in epoch millseconds, or undefined if the stopwatch is still running
     */

  }, {
    key: "stopTime",
    get: function get() {
      return this._stopTime;
    }
  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }]);
  return KatalMetricTimerStopwatch;
}(_KatalMetricTimer2.default);

exports.default = KatalMetricTimerStopwatch;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Metric types.
 */
var KatalMetricType;

(function (KatalMetricType) {
  KatalMetricType["String"] = "String";
  KatalMetricType["Counter"] = "Counter";
  KatalMetricType["Timer"] = "Timer";
  KatalMetricType["List"] = "List";
})(KatalMetricType || (KatalMetricType = {}));

;
var _default = KatalMetricType;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Counter", {
  enumerable: true,
  get: function get() {
    return _KatalMetricCounter.default;
  }
});
Object.defineProperty(exports, "HttpRequest", {
  enumerable: true,
  get: function get() {
    return _KatalMetricHttpRequest.default;
  }
});
Object.defineProperty(exports, "Initialization", {
  enumerable: true,
  get: function get() {
    return _KatalMetricInitialization.default;
  }
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function get() {
    return _KatalMetricObject.default;
  }
});
Object.defineProperty(exports, "String", {
  enumerable: true,
  get: function get() {
    return _KatalMetricString.default;
  }
});
Object.defineProperty(exports, "TimedAttempt", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimedAttempt.default;
  }
});
Object.defineProperty(exports, "Timer", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimer.default;
  }
});
Object.defineProperty(exports, "TimerStopwatch", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimerStopwatch.default;
  }
});

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

var _KatalMetricTimer = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricInitialization = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricInitialization */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js"));

var _KatalMetricHttpRequest = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricHttpRequest */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js"));

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This class encapsulates two IIFEs that the Sushi library contains. A fake CSM and Window object are created and provided
 * to the functions so that they actually execute in a controlled environment away from any CSM code that might be executing
 * at the platform level within the page.
 *
 * The basic run order is the following:
 * 1. Build the mock CSM object, then build a mock Window object that references the CSM object as ue_csm
 * 2. Run the transportation-clients.js Script from SushiJavascriptClient providing the mocks. It will modify globals on the mock objects.
 * 3. Run the sushi-client.js script from SushiJavaScriptClient providing the mocks. It will create an instance of the sushi client and inject it into the CSM globals in the mocks.
 * 4. whenever event() is called, refer to the encapsulated csm object to add the event to the queue.
 */
var SushiClient =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(SushiClient, null, [{
    key: "createSushiUrl",
    value: function createSushiUrl(region, sourceGroup) {
      if (!sourceGroup) {
        throw new Error("Sushi Driver was not provided with a source group.");
      }

      var domain;

      switch (region) {
        case SushiClient.REGIONS.NA:
          domain = "unagi-na";
          break;

        case SushiClient.REGIONS.EU:
          domain = "unagi-eu";
          break;

        case SushiClient.REGIONS.FE:
          domain = "unagi-fe";
          break;

        case SushiClient.REGIONS.CN:
          domain = "unagi-cn";
          break;

        default:
          throw new Error("Unrecognized region '".concat(region, "' provided to SushiClient."));
      }

      return "https://".concat(domain, ".amazon.com/1/events/").concat(sourceGroup);
    }
  }, {
    key: "createCsmUserContext",
    value: function createCsmUserContext(sushiUrl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _objectSpread({
        hiPriFlushInterval: 1000,
        lowPriFlushInterval: 10000,
        requestId: "1",
        errorChannel: "jserr",
        sessionStorageWrapper: undefined,
        errorHandlerFunction: console.log,
        sushiUrl: sushiUrl
      }, options);
    }
    /**
     * Create a Sushi Client for a region and source group
     *
     * @param region Region in SushiClient.REGIONS
     * @param sourceGroup Sushi Eel source group
     * @param errorHandler Error handler function
     * @param options Additional CSM context overrides
     * @param clientOverride An optional transportation client for overriding the default clients (navigator.sendBeacon and XDomainRequest or XMLHttpRequest)
     */

  }, {
    key: "REGIONS",
    get: function get() {
      return {
        NA: "NA",
        EU: "EU",
        FE: "FE",
        CN: "CN"
      };
    }
  }]);

  function SushiClient() {
    var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SushiClient.REGIONS.NA;
    var sourceGroup = arguments.length > 1 ? arguments[1] : undefined;
    var errorHandler = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var clientOverride = arguments.length > 4 ? arguments[4] : undefined;
    (0, _classCallCheck2.default)(this, SushiClient);
    var sushiUrl = SushiClient.createSushiUrl(region, sourceGroup);
    var csmUserContext = SushiClient.createCsmUserContext(sushiUrl, options);
    this.ue_csm = this.setupMockCSMObject(csmUserContext);
    this.encapsulatedWindow = this.setupMockWindow(this.ue_csm);
    this.transportationClientCode(this.ue_csm, window);

    if (clientOverride) {
      this.ue_csm.ue._sBcn = {
        isSupported: true,
        send: function send(endpoint, payload) {
          clientOverride(endpoint, payload);
          return true;
        }
      };
    }

    this.clientCode(this.ue_csm, this.encapsulatedWindow);
    this.errorHandler = errorHandler;
  }

  (0, _createClass2.default)(SushiClient, [{
    key: "event",
    value: function event(data, producerId, schemaId, options) {
      var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (debug) {
        console.log("SushiClient wrapper publishing the following:", {
          data: data,
          producerId: producerId,
          schemaId: schemaId,
          options: options
        });
      }

      return this.ue_csm.ue.event(data, producerId, schemaId, options);
    }
    /**
     * If you plan to emit 1000 or more events per instantiated client,
     * call reset after calling event to allow the CSM client to continue sending events.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.ue_csm.ue.event.reset();
    }
    /**
     * Register a callback that will be called just before each time metrics are
     * flushed to the network.
     * @param callback A function that sushi will call before flushes.
     */

  }, {
    key: "onSushiFlush",
    value: function onSushiFlush(callback) {
      this.ue_csm.ue.onSushiFlush(callback);
    }
    /**
     * Register a callback that will be called just before the page unloads.
     * This can be used to send any final metrics to sushi, such as page visit
     * duration or batched counters.
     * @param callback A function that sushi will call before unload.
     */

  }, {
    key: "onSushiUnload",
    value: function onSushiUnload(callback) {
      this.ue_csm.ue.onSushiUnload(callback);
    }
  }, {
    key: "setupMockCSMObject",
    value: function setupMockCSMObject(csmUserContext) {
      var _this = this;

      var execStub = function execStub(callback, attribution) {
        return callback;
      };

      var eventStub = function eventStub(log, producer, eventType) {
        console.warn("SushiClient CSM stub called in unsupported manner: event()");
      };

      var errorHandler = function errorHandler(logEvent, channel) {
        if (_this.errorHandler) {
          _this.errorHandler(logEvent);
        } else {
          console.log("An error has occurred in SushiClient channel " + channel, logEvent);
        }
      };

      var attachHandler = function attachHandler(evt, handler, container) {
        //TODO might be able to just use window.ue.attach?
        container = container || window; //ok to use real window global here.

        if (window.EventTarget && window.EventTarget.prototype && window.EventTarget.prototype.addEventListener) {
          window.EventTarget.prototype.addEventListener.call(container, evt, handler, !!window.ue_clf);
        } else if (container.addEventListener) {
          container.addEventListener(evt, handler, !!window.ue_clf);
        } else if (container.attachEvent) {
          container.attachEvent("on" + evt, handler);
        }
      };

      return {
        ue_hpsi: csmUserContext.hiPriFlushInterval,
        ue_lpsi: csmUserContext.lowPriFlushInterval,
        ue: {
          ssw: csmUserContext.sessionStorageWrapper,
          log: errorHandler,
          exec: execStub,
          event: eventStub,
          attach: attachHandler
        },
        ueLogError: csmUserContext.errorHandlerFunction,
        ue_surl: csmUserContext.sushiUrl,
        ue_id: csmUserContext.requestId,
        ue_err_chan: csmUserContext.errorChannel
      };
    }
  }, {
    key: "setupMockWindow",
    value: function setupMockWindow(ue_csm) {
      //apparently cannot ref the setTimeout function directly in some browsers so we have to wrap it.
      var timeoutWrapper = function timeoutWrapper(fn, timeout) {
        return window.setTimeout(fn, timeout);
      };

      return {
        ue_csm: ue_csm,
        ueLogError: ue_csm.ueLogError,
        ue: ue_csm.ue,
        setTimeout: timeoutWrapper
      };
    }
    /**
     * Code within function pulled directly from
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/sushi-client.js
     */

  }, {
    key: "clientCode",
    value: function clientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, k) {
        function A() {
          for (var a = 0; a < arguments.length; a++) {
            var c = arguments[a];

            try {
              var h;

              if (c.isSupported) {
                var b = t.buildPayload(l, e);
                h = c.send(J, b);
              } else throw dummyException;

              return h;
            } catch (d) {}
          }

          B({
            m: "All supported clients failed",
            attribution: "CSMSushiClient_TRANSPORTATION_FAIL",
            f: "sushi-client.js",
            logLevel: "ERROR"
          }, k.ue_err_chan || "jserr");
        }

        function m() {
          if (e.length) {
            for (var a = 0; a < n.length; a++) {
              n[a]();
            }

            A(d._sBcn || {}, d._ajx || {});
            e = [];
            f = {};
            l = {};
            u = v = q = w = 0;
          }
        }

        function K() {
          var a = new Date(),
              c = function c(a) {
            return 10 > a ? "0" + a : a;
          };

          return Date.prototype.toISOString ? a.toISOString() : a.getUTCFullYear() + "-" + c(a.getUTCMonth() + 1) + "-" + c(a.getUTCDate()) + "T" + c(a.getUTCHours()) + ":" + c(a.getUTCMinutes()) + ":" + c(a.getUTCSeconds()) + "." + String((a.getUTCMilliseconds() / 1E3).toFixed(3)).slice(2, 5) + "Z";
        }

        function x(a) {
          try {
            return JSON.stringify(a);
          } catch (c) {}

          return null;
        }

        function C(a, c, h, g) {
          var p = !1;
          g = g || {};
          r++;
          r == D && B({
            m: "Max number of Sushi Logs exceeded",
            f: "sushi-client.js",
            logLevel: "ERROR",
            attribution: "CSMSushiClient_MAX_CALLS"
          }, k.ue_err_chan || "jserr");
          var f;
          if (f = !(r >= D)) (f = a && -1 < a.constructor.toString().indexOf("Object") && c && -1 < c.constructor.toString().indexOf("String") && h && -1 < h.constructor.toString().indexOf("String")) || L++;
          f && (d.count && d.count("Event:" + h, 1), a.producerId = a.producerId || c, a.schemaId = a.schemaId || h, a.timestamp = K(), c = Date.now ? Date.now() : +new Date(), h = Math.random().toString().substring(2, 12), a.messageId = b.ue_id + "-" + c + "-" + h, g && !g.ssd && (a.sessionId = a.sessionId || b.ue_sid, a.requestId = a.requestId || b.ue_id, a.obfuscatedMarketplaceId = a.obfuscatedMarketplaceId || b.ue_mid), (c = x(a)) ? (c = c.length, (e.length == M || q + c > N) && m(), q += c, a = {
            data: t.compressEvent(a)
          }, e.push(a), (g || {}).n ? 0 === E ? m() : u || (u = k.setTimeout(m, E)) : v || (v = k.setTimeout(m, O)), p = !0) : p = !1);
          !p && b.ue_int && console.error("Invalid JS Nexus API call");
          return p;
        }

        function F() {
          if (!G) {
            for (var a = 0; a < y.length; a++) {
              y[a]();
            }

            for (a = 0; a < n.length; a++) {
              n[a]();
            }

            e.length && (b.ue_sbuimp && b.ue && b.ue.ssw && (a = x({
              dct: l,
              evt: e
            }), b.ue.ssw("eeldata", a), b.ue.ssw("eelsts", "unk")), A(d._sBcn || {}));
            G = !0;
          }
        }

        function H(a) {
          y.push(a);
        }

        function I(a) {
          n.push(a);
        }

        var D = 1E3,
            M = 499,
            N = 524288,
            s = function s() {},
            d = b.ue || {},
            B = d.log || s,
            P = b.uex || s;

        (b.uet || s)("bb", "ue_sushi_v1", {
          wb: 1
        });

        var J = b.ue_surl || "https://unagi-na.amazon.com/1/events/com.amazon.csm.nexusclient.gamma",
            Q = ["messageId", "timestamp"],
            z = "#",
            e = [],
            f = {},
            l = {},
            q = 0,
            w = 0,
            L = 0,
            r = 0,
            y = [],
            n = [],
            G = !1,
            u,
            v,
            E = void 0 === b.ue_hpsi ? 1E3 : b.ue_hpsi,
            O = void 0 === b.ue_lpsi ? 1E4 : b.ue_lpsi,
            t = function () {
          function a(a) {
            f[a] = z + w++;
            l[f[a]] = a;
            return f[a];
          }

          function c(b) {
            if (!(b instanceof Function)) {
              if (b instanceof Array) {
                for (var g = [], d = b.length, e = 0; e < d; e++) {
                  g[e] = c(b[e]);
                }

                return g;
              }

              if (b instanceof Object) {
                g = {};

                for (d in b) {
                  b.hasOwnProperty(d) && (g[f[d] ? f[d] : a(d)] = -1 === Q.indexOf(d) ? c(b[d]) : b[d]);
                }

                return g;
              }

              return "string" === typeof b && (b.length > (z + w).length || b.charAt(0) === z) ? f[b] ? f[b] : a(b) : b;
            }
          }

          return {
            compressEvent: c,
            buildPayload: function buildPayload() {
              return x({
                cs: {
                  dct: l
                },
                events: e
              });
            }
          };
        }();

        (function () {
          if (d.event && d.event.isStub) {
            if (b.ue_sbuimp && b.ue && b.ue.ssw) {
              var a = b.ue.ssw("eelsts").val;

              if (a && "unk" === a && (a = b.ue.ssw("eeldata").val)) {
                var c;

                a: {
                  try {
                    c = JSON.parse(a);
                    break a;
                  } catch (f) {}

                  c = null;
                }

                c && c.evt instanceof Array && c.dct instanceof Object && (e = c.evt, l = c.dct, e && l && (m(), b.ue.ssw("eeldata", "{}"), b.ue.ssw("eelsts", "scs")));
              }
            }

            d.event.replay(function (a) {
              a[3] = a[3] || {};
              a[3].n = 1;
              C.apply(this, a);
            });
            d.onSushiUnload.replay(function (a) {
              H(a[0]);
            });
            d.onSushiFlush.replay(function (a) {
              I(a[0]);
            });
          }
        })();

        d.attach("beforeunload", F);
        d.attach("pagehide", F);
        d._cmps = t;
        d.event = C;

        d.event.reset = function () {
          r = 0;
        };

        d.onSushiUnload = H;
        d.onSushiFlush = I;

        try {
          k.P && k.P.register && k.P.register("sushi-client", s);
        } catch (R) {
          b.ueLogError(R, {
            logLevel: "WARN"
          });
        }

        P("ld", "ue_sushi_v1", {
          wb: 1
        });
      }, "Nxs-JS-Client")(ue_csm, window);
    }
    /**
     * The code in this function is pulled directly from:
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/transportation-clients.js
     */

  }, {
    key: "transportationClientCode",
    value: function transportationClientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, c) {
        var e = function e() {},
            f = function () {
          return {
            send: function send(b, d) {
              if (d && b) {
                var a;
                if (c.XDomainRequest) a = new XDomainRequest(), a.onerror = e, a.ontimeout = e, a.onprogress = e, a.onload = e, a.timeout = 0;else if (c.XMLHttpRequest) {
                  if (a = new XMLHttpRequest(), !("withCredentials" in a)) throw "";
                } else a = void 0;
                if (!a) throw "";
                a.open("POST", b, !0);
                a.setRequestHeader && a.setRequestHeader("Content-type", "text/plain");
                a.send(d);
              }
            },
            isSupported: !0
          };
        }(),
            g = function () {
          return {
            send: function send(c, d) {
              if (c && d) if (navigator.sendBeacon(c, d)) b.ue_sbuimp && b.ue && b.ue.ssw && b.ue.ssw("eelsts", "scs");else throw "";
            },
            isSupported: !!navigator.sendBeacon && !(c.cordova && c.cordova.platformId && "ios" == c.cordova.platformId)
          };
        }();

        b.ue._ajx = f;
        b.ue._sBcn = g;
      }, "Transportation-clients")(ue_csm, window);
    }
  }]);
  return SushiClient;
}();

exports.default = SushiClient;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/get.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/get.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/superPropBase.js");
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/set.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/set.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/superPropBase.js");
var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;
      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }
      desc = Object.getOwnPropertyDescriptor(receiver, property);
      if (desc) {
        if (!desc.writable) {
          return false;
        }
        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }
      return true;
    };
  }
  return set(target, property, value, receiver);
}
function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);
  if (!s && isStrict) {
    throw new TypeError('failed to set property');
  }
  return value;
}
module.exports = _set, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/toPrimitive.js");
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/build-url-ts/dist/build-url.js":
/*!*****************************************************!*\
  !*** ./node_modules/build-url-ts/dist/build-url.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
function buildQueryString(r,n,a){var o=[];for(var t in r)!function(t){var e;Object.prototype.hasOwnProperty.call(r,t)&&void 0!==r[t]&&(a&&Array.isArray(r[t])&&r[t].length?r[t].forEach(function(r){e=0!==r?r||"":0,o.push("".concat(t,"=").concat(encodeURIComponent(String(e).trim())))}):(e=n?String(r[t]).toLowerCase()||"":0!==r[t]?r[t]||"":0,o.push("".concat(t,"=").concat(encodeURIComponent(String(e).trim())))))}(t);return"?".concat(o.join("&"))}function appendPath(r,t,e){void 0===t&&(t=""),"/"===t[t.length-1]&&(t=t.slice(0,-1));var n=String(r).trim();return e&&(n=n.toLowerCase()),0===n.indexOf("/")?t+=n:t+="/".concat(n),t}function buildHash(r,t){var e="#".concat(String(r).trim());return t?e.toLowerCase():e}function buildUrl(r,t){var e;return null===r?e="":"object"==typeof r?(e="",t=r):e=r,null!=t&&t.path&&(e=appendPath(t.path,e,t.lowerCase)),null!=t&&t.queryParams&&(e+=buildQueryString(t.queryParams,t.lowerCase,t.disableCSV)),null!=t&&t.hash&&(e+=buildHash(t.hash,t.lowerCase)),e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.appendPath=appendPath,exports.buildHash=buildHash,exports.buildQueryString=buildQueryString,exports.buildUrl=buildUrl,exports.default=buildUrl;
//# sourceMappingURL=build-url.js.map


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "#aa-challenge-whole-page-iframe {\n    overflow:hidden;\n    opacity:1.0;\n    position:fixed;\n    top:0px;\n    bottom:0px;\n    right:0px;\n    border:none;\n    margin:0;\n    padding:0;\n    height:100%;\n    width:100%;\n    z-index:999999;\n}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/HostnameResolver.ts":
/*!*********************************!*\
  !*** ./src/HostnameResolver.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var HostnameResolver=function(){var _000=['\x65\x67\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x75\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x69\x6e','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x69\x74','\x61\x74\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x67','\x6e\x6c','\x6a\x70\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x65\x73','\x66\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x6e\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x75\x6b\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x62\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x63\x61','\x64\x65','\x62\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x6e','\x70\x6c\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x6c\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x74\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6d\x78\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x61','\x65\x73\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x64\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x70\x6c','\x70\x6c','\x75\x73','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x64\x65','\x61\x75','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x66\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x63\x61\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x65\x67','\x69\x6e\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x74','\x61\x75\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6d\x78\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x74\x72','\x75\x6b','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x61','\x73\x61\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x64\x65\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x61\x74','\x63\x61\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x74\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6a\x70\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x61\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x75\x6b\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x65\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x61','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x2e\x75\x6b','\x66\x72','\x65\x73\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x74\x72','\x69\x74','\x74\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x61\x65','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x62\x72','\x6e\x6c\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x65\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x74\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x65\x75','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x65','\x61\x65','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x6d\x78','\x73\x65','\x6a\x70','\x73\x67\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x6e\x6c','\x65\x67\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x67\x2d\x70\x72\x65\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x65\x67','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x2e\x6a\x70','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x61\x75','\x73\x67','\x62\x72','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x66\x72','\x69\x74\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6e\x6c\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6d\x78','\x65\x73'];function HostnameResolver(){var _l1iiILLi=function(_0Q0Q0o0Q,_0OO0Q0Oo){var _L1L=['\x62\x6f\x64\x79','\x61',.9422167020630363,2310];var _QO000oQ0=_L1L[3],_oQ00QQOO=_L1L[2];var _QooQoQ00=_L1L[0];return _L1L[1];};}HostnameResolver.getServiceHostnameByConfiguration=function(configuration){var _S$=['\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d'];var _lILlLiIL=function(_s$ssS2zz,_oOOoQOOQ){var _o00=['\x62\x6c\x6f\x62\x41',.7733434681755895,'\x62\x6c\x6f\x62\x4f\x62\x66\x75\x73\x63\x61\x74\x65',.49741181595186545];var _ZssSszzZ=_o00[1];var _szsZZs$S=_o00[3];var _00Oo0oOO=_o00[0];return _o00[2];};if(configuration in HostnameResolver.DOMAIN_REALM_HOSTNAME){return HostnameResolver.DOMAIN_REALM_HOSTNAME[configuration];}else{return _S$[0];}};HostnameResolver.getServiceHostnameByHostname=function(hostname){var _Q00=['\x70\x72\x6f\x64','\x74\x65\x73\x74','\x6d\x61\x73\x74\x65\x72'];if(HostnameResolver.isDevelopment(hostname)){var _sSsssss2=function(_szZzsZ$S,_i1I11111){var _il1=['\x6e\x6f\x64\x65',47993,.7158952453897305,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65',19796];var _iLlIillI=_il1[3],_OOoOOQoQ=_il1[4];var _iiL1llll=_il1[1],_0O0ooQoo=_il1[2];return _il1[0];};return this.getServiceHostByCountryCode(_Q00[1],this.getCountryCodePrefix(hostname));}else if(HostnameResolver.isPreProd(hostname)){return this.getServiceHostByCountryCode(_Q00[2],this.getCountryCodePrefix(hostname));}else{var countryCode=HostnameResolver.getCountryCodeSuffix(hostname);return this.getServiceHostByCountryCode(_Q00[0],countryCode);}};HostnameResolver.getServiceHostByCountryCode=function(domain,countryCode){var _1l=['\x2e','\x41\x6d\x61\x7a\x6f\x6e'];return this.getServiceHostnameByConfiguration(domain+_1l[0]+countryCode.toUpperCase()+_1l[1]);};HostnameResolver.isDevelopment=function(hostname){var _11i=['\x6c\x6f\x63\x61\x6c\x68\x6f\x73\x74','\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d',.6705131369018136,'\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d',.11976044516881812,'\x64\x65\x76\x2d\x64\x73\x6b'];var _0OO0OQ0O=_11i[3],_liLIlilI=_11i[5];return hostname.startsWith(_11i[6])&&hostname.endsWith(_11i[1])||hostname.startsWith(_11i[0])||hostname.endsWith(_11i[2])||hostname.endsWith(_11i[4]);};HostnameResolver.isPreProd=function(hostname){var _OQ0=['\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d'];return hostname.endsWith(_OQ0[2])||hostname.endsWith(_OQ0[0])||hostname.endsWith(_OQ0[3])||hostname.endsWith(_OQ0[4])||hostname.endsWith(_OQ0[1]);};HostnameResolver.getCountryCodePrefix=function(hostname){var _2S2=['\x2e',0,33665,'\x2d',.5207574585410732,'\x64\x6f\x6d\x48\x61\x73\x68','\x75\x73',1];var splits=hostname.split(_2S2[3]);if(splits.length>_2S2[7]){var prefix_1=splits[_2S2[1]];var _2ZZSs$22=_2S2[2];if(this.COUNTRY_CODES.some(function(e){var _zz=[.8419813504458586,'\x6f\x62\x66\x75\x73\x63\x61\x74\x65','\x6a\x73\x6f\x6e\x44\x6f\x6d\x48\x61\x73\x68'];var _$ZzS$2ZS=_zz[1],_Q0QO0QQ0=_zz[2],_O00OO0O0=_zz[0];return e===prefix_1;})){var _o0OQOooo=function(_zsS2ssz$,_00OOQQ0O){var _QQ0=[.37338833023274187,4428,21031,'\x65\x78\x65\x63\x75\x74\x65\x4a\x73\x6f\x6e',36752,'\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x44\x61\x74\x61\x4c\x69\x73\x74'];var _L11II1i1=_QQ0[1],_ll11ILi1=_QQ0[4];var _QQoQQ0oo=_QQ0[5],_LilIIili=_QQ0[0],_iLlLiiLL=_QQ0[2];return _QQ0[3];};return prefix_1;}}splits=hostname.split(_2S2[0]);if(splits.length>_2S2[7]){var _s$$ZZ$S$=_2S2[4],_QQQoo0OO=_2S2[5];var prefix_2=splits[_2S2[1]];if(this.COUNTRY_CODES.some(function(e){var _Zz=[];var _zzzS2sSZ=function(_LiiiL1lI,_S2z2SsSS,_zzS$$zzs){var _ZzZ=['\x6c\x69\x73\x74\x46\x77\x63\x69\x6d\x46\x77\x63\x69\x6d','\x61\x6d\x61\x7a\x6f\x6e\x4a\x73\x6f\x6e',.7578415928146696,10085];var _zzSs2ssZ=_ZzZ[2];var _s22$SSs2=_ZzZ[0],_oOOoQ0oO=_ZzZ[3];return _ZzZ[1];};return e===prefix_2;})){return prefix_2;}}return _2S2[6];};HostnameResolver.getCountryCodeSuffix=function(hostname){var _ZZ=['\x75\x73','\x2e',1];var splits=hostname.split(_ZZ[1]);var _Lli1L1LL=function(_2S$2sSSz,_0oooQ00O){var _iiL=[.3063546286493364,28395,'\x66\x77\x63\x69\x6d\x4f\x62\x66\x75\x73\x63\x61\x74\x65',9517,'\x64\x6f\x63\x75\x6d\x65\x6e\x74\x44\x6f\x63\x75\x6d\x65\x6e\x74\x44\x61\x74\x61',6866];var _LlLLliII=_iiL[4],_1Illlli1=_iiL[0],_IlillI1l=_iiL[3];var _l1lilL11=_iiL[5],_Zs$s$$S2=_iiL[2];return _iiL[1];};if(splits.length>_ZZ[2]){var suffix_1=splits[splits.length-_ZZ[2]];if(this.COUNTRY_CODES.some(function(e){var _Ll=[];return e===suffix_1;})){return suffix_1;}}return _ZZ[0];};HostnameResolver.DOMAIN_REALM_HOSTNAME={'\x74\x65\x73\x74\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_000[23],'\x6d\x61\x73\x74\x65\x72\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_000[25],'\x70\x72\x6f\x64\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_000[31],'\x74\x65\x73\x74\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_000[23],'\x6d\x61\x73\x74\x65\x72\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_000[25],'\x70\x72\x6f\x64\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_000[31],'\x74\x65\x73\x74\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_000[33],'\x6d\x61\x73\x74\x65\x72\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_000[46],'\x70\x72\x6f\x64\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_000[42],'\x74\x65\x73\x74\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_000[39],'\x6d\x61\x73\x74\x65\x72\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_000[20],'\x70\x72\x6f\x64\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_000[68],'\x74\x65\x73\x74\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_000[64],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_000[4],'\x70\x72\x6f\x64\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_000[45],'\x74\x65\x73\x74\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_000[71],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_000[74],'\x70\x72\x6f\x64\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_000[5],'\x74\x65\x73\x74\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_000[38],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_000[1],'\x70\x72\x6f\x64\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_000[77],'\x74\x65\x73\x74\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_000[44],'\x6d\x61\x73\x74\x65\x72\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_000[24],'\x70\x72\x6f\x64\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_000[29],'\x74\x65\x73\x74\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_000[44],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_000[24],'\x70\x72\x6f\x64\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_000[29],'\x74\x65\x73\x74\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_000[18],'\x6d\x61\x73\x74\x65\x72\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_000[17],'\x70\x72\x6f\x64\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_000[26],'\x74\x65\x73\x74\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_000[59],'\x6d\x61\x73\x74\x65\x72\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_000[19],'\x70\x72\x6f\x64\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_000[40],'\x74\x65\x73\x74\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_000[47],'\x6d\x61\x73\x74\x65\x72\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_000[81],'\x70\x72\x6f\x64\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_000[3],'\x74\x65\x73\x74\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_000[63],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_000[49],'\x70\x72\x6f\x64\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_000[60],'\x74\x65\x73\x74\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_000[48],'\x6d\x61\x73\x74\x65\x72\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_000[7],'\x70\x72\x6f\x64\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_000[76],'\x74\x65\x73\x74\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_000[48],'\x6d\x61\x73\x74\x65\x72\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_000[7],'\x70\x72\x6f\x64\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_000[76],'\x74\x65\x73\x74\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_000[51],'\x6d\x61\x73\x74\x65\x72\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_000[11],'\x70\x72\x6f\x64\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_000[54],'\x74\x65\x73\x74\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_000[51],'\x6d\x61\x73\x74\x65\x72\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_000[11],'\x70\x72\x6f\x64\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_000[54],'\x74\x65\x73\x74\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_000[50],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_000[43],'\x70\x72\x6f\x64\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_000[53],'\x74\x65\x73\x74\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_000[10],'\x6d\x61\x73\x74\x65\x72\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_000[36],'\x70\x72\x6f\x64\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_000[2],'\x74\x65\x73\x74\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_000[0],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_000[73],'\x70\x72\x6f\x64\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_000[75],'\x74\x65\x73\x74\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_000[9],'\x6d\x61\x73\x74\x65\x72\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_000[32],'\x70\x72\x6f\x64\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_000[80],'\x74\x65\x73\x74\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_000[56],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_000[22],'\x70\x72\x6f\x64\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_000[8],'\x74\x65\x73\x74\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_000[82],'\x6d\x61\x73\x74\x65\x72\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_000[62],'\x70\x72\x6f\x64\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_000[72],'\x74\x65\x73\x74\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_000[52],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_000[34],'\x70\x72\x6f\x64\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_000[66],'\x74\x65\x73\x74\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_000[15],'\x6d\x61\x73\x74\x65\x72\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_000[12],'\x70\x72\x6f\x64\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_000[61]};HostnameResolver.COUNTRY_CODES=[_000[37],_000[78],_000[30],_000[14],_000[27],_000[57],_000[58],_000[13],_000[67],_000[83],_000[70],_000[41],_000[65],_000[21],_000[28],_000[16],_000[35],_000[55],_000[84],_000[6],_000[69],_000[79]];return HostnameResolver;}();exports.HostnameResolver=HostnameResolver;

/***/ }),

/***/ "./src/KatalEndpointResolver.ts":
/*!**************************************!*\
  !*** ./src/KatalEndpointResolver.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var HostnameResolver_1=__webpack_require__(/*! ./HostnameResolver */ "./src/HostnameResolver.ts");var KatalEndpointResolver=function(){var _OO=['\x61\x70','\x68\x74\x74\x70\x73\x3a\x2f\x2f\x76\x33\x32\x62\x67\x67\x62\x6d\x6a\x61\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x77\x65\x73\x74\x2d\x32\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x61\x6d\x61\x7a\x6f\x6e\x41\x6d\x61\x7a\x6f\x6e','\x68\x74\x74\x70\x73\x3a\x2f\x2f\x6d\x62\x64\x76\x67\x6f\x6a\x32\x37\x68\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x65\x61\x73\x74\x2d\x31\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x68\x74\x74\x70\x73\x3a\x2f\x2f\x79\x33\x6a\x35\x67\x39\x65\x36\x79\x34\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x65\x61\x73\x74\x2d\x31\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x67\x61\x6d\x6d\x61','\x62\x65\x74\x61','\x70\x72\x6f\x64'];function KatalEndpointResolver(){var _2$2Z$Sz2=_OO[2];}KatalEndpointResolver.getKatalLoggerEndpoint=function(){var _I1=[];var stage=this.getStageByHostname(window.location.hostname.toLowerCase());return this.KATAL_LOGGER_ENDPOINTS_MAP[stage];};KatalEndpointResolver.getStageByHostname=function(hostname){var _s$z=[42431,'\x65\x6e\x63\x72\x79\x70\x74\x45\x6e\x63\x72\x79\x70\x74','\x61\x6d\x61\x7a\x6f\x6e','\x64\x6f\x63\x75\x6d\x65\x6e\x74\x44\x61\x74\x61','\x64\x6f\x6d'];if(HostnameResolver_1.HostnameResolver.isDevelopment(hostname)){var _sZsSZ2$Z=function(_l1lIliIl){var _$2=['\x62','\x66\x77\x63\x69\x6d\x4e\x6f\x64\x65','\x64\x6f\x63\x75\x6d\x65\x6e\x74\x44\x6f\x63\x75\x6d\x65\x6e\x74\x48\x61\x73\x68'];var _2zS2zS$$=_$2[2],_z$sSS2ZS=_$2[0];return _$2[1];};return this.BETA_STAGE;}else if(HostnameResolver_1.HostnameResolver.isPreProd(hostname)){var _oQOOoooQ=_s$z[2],_Qo00QQQ0=_s$z[4];return this.GAMMA_STAGE;}var _1LlLLLli=_s$z[3],_OoOQO000=_s$z[1],_Qoo0Q00O=_s$z[0];return this.PROD_STAGE;};KatalEndpointResolver.getStageByHostConfig=function(hostConfig){var _o0=['\x6e\x75\x6c\x6c\x48\x6f\x73\x74\x43\x6f\x6e\x66\x69\x67','\x70\x72\x6f\x64','\x62\x45\x78\x65\x63\x75\x74\x65','\x2e',0,'\x74\x65\x73\x74','\x6d\x61\x73\x74\x65\x72'];var _OQoOQoo0=_o0[2];var configuration=_o0[0];if(hostConfig){var _iLIL1lIl=function(_s$$2sZzs,_LliLI1LI,_O0QQOOQ0){var _0o=[13367,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72\x45\x6c',29986,40312];var _iL11Iili=_0o[2];var _II1iILii=_0o[0],_0OQoQ0o0=_0o[3];return _0o[1];};configuration=hostConfig.split(_o0[3])[_o0[4]];}switch(configuration){case _o0[5]:return this.BETA_STAGE;case _o0[6]:return this.GAMMA_STAGE;case _o0[1]:return this.PROD_STAGE;default:return this.getStageByHostname(window.location.hostname.toLowerCase());}};KatalEndpointResolver.getPageTypeMetricName=function(clientData,logger){var _QO=['\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x70\x61\x72\x73\x65\x20\x63\x6c\x69\x65\x6e\x74\x43\x6f\x6e\x74\x65\x78\x74\x2e','\x6e\x6f\x64\x65\x4a\x73\x6f\x6e\x45\x78\x65\x63\x75\x74\x65','\x64\x61\x74\x61\x2d\x63\x6f\x6e\x74\x65\x78\x74','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64',28918,45586,'\x2e'];var _sZ$ZsSsZ=function(_oOoo0Q0o,_lI11llLI){var _zs=['\x61\x44\x6f\x6d',32618,10774,'\x61\x6d\x61\x7a\x6f\x6e'];var _22Szs$s2=_zs[3];var _oQ0QQ0o0=_zs[0];var _illII11L=_zs[1];return _zs[2];};if(clientData[_QO[3]]==this.AP_CLIENT_ID&&clientData[_QO[2]]){try{var _iiLL11il=_QO[5],_$Ss2$2s2=_QO[4];var clientContext=JSON.parse(clientData[_QO[2]]);return clientContext.pageType?_QO[6]+clientContext.pageType:this.EMPTY_STRING;}catch(err){logger.error(_QO[0],err.message);var _l1iLLlLl=_QO[1];return this.EMPTY_STRING;}}return this.EMPTY_STRING;};KatalEndpointResolver.BETA_STAGE=_OO[6];KatalEndpointResolver.GAMMA_STAGE=_OO[5];KatalEndpointResolver.PROD_STAGE=_OO[7];KatalEndpointResolver.KATAL_LOGGER_ENDPOINTS_MAP={'\x62\x65\x74\x61':_OO[1],'\x67\x61\x6d\x6d\x61':_OO[4],'\x70\x72\x6f\x64':_OO[3]};KatalEndpointResolver.EMPTY_STRING='';KatalEndpointResolver.AP_CLIENT_ID=_OO[0];var _s2ZS$SSZ=function(_z2Z2sSSs,_2SZ2z$Z$){var _Z$z=[.3019193368295918,.96361751101232,'\x75\x73\x65\x72\x61\x67\x65\x6e\x74',6531];var _OQoO0QoO=_Z$z[3],_$S2z$$2z=_Z$z[0];var _0O0oOOoO=_Z$z[1];return _Z$z[2];};return KatalEndpointResolver;}();exports.KatalEndpointResolver=KatalEndpointResolver;

/***/ }),

/***/ "./src/acic.ts":
/*!*********************!*\
  !*** ./src/acic.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var build_url_ts_1=__webpack_require__(/*! build-url-ts */ "./node_modules/build-url-ts/dist/build-url.js");__webpack_require__(/*! ./css/iframe.css */ "./src/css/iframe.css");var ACICSessionContext_1=__webpack_require__(/*! ./data/ACICSessionContext */ "./src/data/ACICSessionContext.ts");var ACICClientRequest_1=__webpack_require__(/*! ./data/ACICClientRequest */ "./src/data/ACICClientRequest.ts");var AAmationResult_1=__webpack_require__(/*! ./data/AAmationResult */ "./src/data/AAmationResult.ts");var ACICUserResponse_1=__webpack_require__(/*! ./data/ACICUserResponse */ "./src/data/ACICUserResponse.ts");var HostnameResolver_1=__webpack_require__(/*! ./HostnameResolver */ "./src/HostnameResolver.ts");var ACICError_1=__webpack_require__(/*! ./data/ACICError */ "./src/data/ACICError.ts");var katal_logger_1=__webpack_require__(/*! @amzn/katal-logger */ "./node_modules/@amzn/katal-logger/dist/index.js");var KatalEndpointResolver_1=__webpack_require__(/*! ./KatalEndpointResolver */ "./src/KatalEndpointResolver.ts");var katal_metrics_1=__webpack_require__(/*! @amzn/katal-metrics */ "./node_modules/@amzn/katal-metrics/lib/index.js");var katal_metrics_driver_sushi_1=__webpack_require__(/*! @amzn/katal-metrics-driver-sushi */ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js");var ACIC=function(){var _L1=[true,'\x2f\x61\x61\x75\x74\x2f\x76\x65\x72\x69\x66\x79\x2f','\x73\x74\x61\x74\x69\x63\x53\x65\x73\x73\x69\x6f\x6e\x54\x6f\x6b\x65\x6e',null,'\x73\x74\x61\x74\x69\x63\x43\x6c\x69\x65\x6e\x74\x43\x6f\x6e\x74\x65\x78\x74',3,'\x41\x43\x49\x43','\x61\x6d\x7a\x2d\x61\x61\x6d\x61\x74\x69\x6f\x6e\x2d\x72\x65\x73\x70',15e3,'\x31','\x50\x41\x53\x53','\x6f\x6e\x65\x72\x72\x6f\x72'];function ACIC(acicKatalLogger){this.logger={log:function(args){var _sS=[];}};this.sessionContext=new ACICSessionContext_1.ACICSessionContext();this._onerror=_L1[3];if(acicKatalLogger!=_L1[3]){var _0QoOQO00=function(_11ll1Lll){var _LL=[.7533883619346493,9050,'\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x42\x6c\x6f\x62',.8967673006120804];var _lIili1L1=_LL[1],_zszZSSSZ=_LL[2],_OOoOQOo0=_LL[3];return _LL[0];};this.acicKatalLogger=acicKatalLogger;}else{var _o00oQOOO=function(_s2zsSs$$,_zZ22zSZ$){var _ll=['\x66\x77\x63\x69\x6d',.9254049100633823,.6639454035898613];var _LIiliILl=_ll[1],_OoQoQOOo=_ll[2];return _ll[0];};this.acicKatalLogger=this.setupKatalLogger();}this.setupIframeEventListener();}ACIC.prototype.setupACIC=function(clientInputData){var _sSZ=['\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67','\x62\x42\x6f\x64\x79','\x64\x61\x74\x61\x2d\x75\x73\x65\x2d\x70\x6f\x73\x74\x2d\x72\x65\x71\x75\x65\x73\x74\x2d\x6d\x65\x74\x68\x6f\x64',null,'\x64\x61\x74\x61\x2d\x74\x69\x6d\x65\x6f\x75\x74',.3605155234740065,'\x64\x61\x74\x61\x2d\x69\x66\x72\x61\x6d\x65\x2d\x69\x64','\x64\x61\x74\x61\x2d\x65\x72\x72\x6f\x72\x2d\x63\x61\x6c\x6c\x62\x61\x63\x6b','\x64\x61\x74\x61\x2d\x6d\x6f\x64\x65','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74',false];var serviceHost=clientInputData[_sSZ[9]]||_sSZ[3];var configuration=clientInputData[_sSZ[0]]||_sSZ[3];this.setServiceHost(serviceHost,configuration);this._onerror=clientInputData[_sSZ[7]]||_sSZ[3];this.setClientRequest(clientInputData);this.mode=clientInputData[_sSZ[8]]||_sSZ[3];this.timeout=clientInputData[_sSZ[4]]||ACIC.DEFAULT_REQUEST_TIMEOUT;var _Sz$ZZ2z$=function(_oo0OOQ0O,_Z$s$Ss$Z){var _QQ=[16609,38886,.9903228185267519,.08276458743289439,.19232820114770122,'\x64\x6f\x63\x75\x6d\x65\x6e\x74'];var _QO0O0O0o=_QQ[2],_0oQoQOoo=_QQ[0],_LiIIl1ll=_QQ[3];var _I1IIL1Il=_QQ[4],_iiiI1iI1=_QQ[5];return _QQ[1];};this.useRequestMethodPost=clientInputData[_sSZ[2]]||_sSZ[10];this.enableCustomizedIframe=clientInputData[_sSZ[6]];if(this.enableCustomizedIframe){var _sz$$S2zZ=_sSZ[1],_OOo00Ooo=_sSZ[5];this.iframe=document.getElementById(clientInputData[_sSZ[6]]);}this.setKatalMetrics(clientInputData);this.sendArnoldHttpRequest(this.createNewSessionRequestURL(),this.timeout);};ACIC.prototype.setupACICforAsyncReporting=function(clientInputData){var _O0=['\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74',null];var serviceHost=clientInputData[_O0[1]]||_O0[2];var configuration=clientInputData[_O0[0]]||_O0[2];this.setServiceHost(serviceHost,configuration);this.setClientRequest(clientInputData);if(window.navigator&&navigator.sendBeacon){navigator.sendBeacon(this.createNewSessionRequestURL(),JSON.stringify(this.clientRequest));}};Object.defineProperty(ACIC.prototype,_L1[11],{set:function(onError){var _oO=['\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x49\x64',.9378437985325945];var _00QQQOoO=_oO[0],_zzSs2SZs=_oO[1];this._onerror=onError;},enumerable:_L1[0],configurable:_L1[0]});ACIC.prototype.setServiceHost=function(serviceHost,configuration){var _2S=['\x61\x6d\x61\x7a\x6f\x6e','\x68\x74\x74\x70\x73\x3a\x2f\x2f',null];if(serviceHost==_2S[2]){if(configuration!=_2S[2]){serviceHost=HostnameResolver_1.HostnameResolver.getServiceHostnameByConfiguration(configuration);}else{var _LLlI1LIL=_2S[0];serviceHost=HostnameResolver_1.HostnameResolver.getServiceHostnameByHostname(window.location.hostname.toLowerCase());}}var _O0OoQOO0=function(_ILILIL11){var _iI=[34375,.24582612765998202,.035885807413825965,18076,'\x62\x6f\x64\x79\x53\x74\x61\x74\x65\x6d\x65\x6e\x74\x46\x77\x63\x69\x6d'];var _OQQ00QQQ=_iI[2];var _1iIi1ii1=_iI[4],_z22Ss$sZ=_iI[3],_00OOQQOo=_iI[1];return _iI[0];};this.serviceEndpoint=_2S[1]+serviceHost+ACIC.SERVICE_BASE_PATH;};ACIC.prototype.setupKatalLogger=function(){var _00=['\x64\x6f\x6d',.3210268923184667,.08655167388532736];var _ZzZZZzsz=_00[1],_l1iII1Ii=_00[2],_IL1I1ILl=_00[0];var acicKatalLogger=new katal_logger_1.default({url:KatalEndpointResolver_1.KatalEndpointResolver.getKatalLoggerEndpoint()});acicKatalLogger.addErrorListener(function(error){var _iL=[true];return _iL[0];});return acicKatalLogger;};ACIC.prototype.setKatalMetrics=function(clientInputData){var _iI1=['\x65\x6e\x63\x72\x79\x70\x74\x53\x74\x61\x74\x65\x6d\x65\x6e\x74','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64','\x2e','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67','\x55\x53\x41\x6d\x61\x7a\x6f\x6e',37594];var _this=this;var metricsErrorHandler=function(err){var _2z=['\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x70\x75\x62\x6c\x69\x73\x68\x20\x74\x68\x65\x20\x6d\x65\x74\x72\x69\x63\x73\x2e'];_this.acicKatalLogger.error(_2z[0],err);};var domain=KatalEndpointResolver_1.KatalEndpointResolver.getStageByHostConfig(clientInputData[_iI1[3]]);var _o0QoOQQ0=_iI1[5],_o00QO0QO=_iI1[0];var metricsDriver=new katal_metrics_driver_sushi_1.default.Builder().withDomainRealm(domain,_iI1[4]).withErrorHandler(metricsErrorHandler).build();var katalMetricsServiceName=clientInputData[_iI1[1]]+KatalEndpointResolver_1.KatalEndpointResolver.getPageTypeMetricName(clientInputData,this.acicKatalLogger)+_iI1[2]+window.location.hostname;var initialMetricsContext=new katal_metrics_1.Context.Builder().withSite(ACIC.KATAL_METRICS_SERVICE_NAME).withServiceName(katalMetricsServiceName).build();this.acicKatalMetricsPublisher=new katal_metrics_1.Publisher(metricsDriver,metricsErrorHandler,initialMetricsContext);};ACIC.prototype.setClientRequest=function(data){var _11=['\x62','\x64\x61\x74\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x74\x79\x70\x65','\x64\x61\x74\x61\x2d\x65\x76\x65\x6e\x74\x2d\x74\x72\x69\x67\x67\x65\x72','\x64\x61\x74\x61\x2d\x6d\x6f\x64\x61\x6c','\x64\x61\x74\x61\x2d\x66\x77\x63\x69\x6d','\x64\x61\x74\x61\x2d\x63\x6f\x6e\x74\x65\x78\x74','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64','\x64\x61\x74\x61\x2d\x66\x6f\x72\x63\x65\x2d\x6a\x73\x2d\x66\x6c\x75\x73\x68','\x64\x61\x74\x61\x2d\x6d\x6f\x64\x65',3884,'\x64\x61\x74\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x4c\x6f\x61\x64\x43\x61\x6c\x6c\x62\x61\x63\x6b','\x43\x6c\x69\x65\x6e\x74\x20\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x69\x64\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x72\x6f\x76\x69\x64\x65\x64','\x64\x61\x74\x61\x2d\x63\x61\x6c\x6c\x62\x61\x63\x6b','\x64\x61\x74\x61\x2d\x61\x61\x2d\x65\x78\x74\x65\x72\x6e\x61\x6c\x2d\x74\x6f\x6b\x65\x6e','\x64\x61\x74\x61\x2d\x65\x78\x74\x65\x72\x6e\x61\x6c\x2d\x69\x64','\x43\x6c\x69\x65\x6e\x74\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x72\x6f\x76\x69\x64\x65\x64','\x64\x61\x74\x61\x2d\x62\x79\x70\x61\x73\x73\x2d\x6d\x65\x63\x68\x61\x6e\x69\x73\x6d','\x64\x61\x74\x61\x2d\x64\x69\x73\x6d\x69\x73\x73\x43\x61\x6c\x6c\x62\x61\x63\x6b','\x64\x61\x74\x61\x2d\x6c\x6f\x63\x61\x6c\x65','\x64\x61\x74\x61\x2d\x68\x65\x61\x64\x65\x72\x2d\x66\x6f\x6f\x74\x65\x72'];if(!data[_11[6]]){throw new Error(_11[11]);}if(!data[_11[12]]){var _0oOOQQoo=_11[0],_00OOOQoo=_11[9];throw new Error(_11[15]);}this.clientRequest=new ACICClientRequest_1.ACICClientRequest(data[_11[6]],data[_11[12]],data[_11[17]],data[_11[10]],data[_11[5]],data[_11[18]],data[_11[4]],data[_11[14]],data[_11[19]],data[_11[16]],data[_11[3]],data[_11[1]],data[_11[8]],data[_11[2]],data[_11[13]],data[_11[7]]);};ACIC.prototype.setupIframeEventListener=function(){var _Ooo=['\x73\x65\x74\x75\x70\x49\x66\x72\x61\x6d\x65\x45\x76\x65\x6e\x74\x4c\x69\x73\x74\x65\x6e\x65\x72','\x6d\x65\x73\x73\x61\x67\x65'];var _this=this;this.logger.log(_Ooo[0]);window.addEventListener(_Ooo[1],function(event){var _Il=[];return _this.handleIframeMessage(event);});};ACIC.prototype.handleIframeMessage=function(event){var _oo=['\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x43\x6f\x6d\x70\x6c\x65\x74\x65\x64',12993,'\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x73\x68\x6f\x77\x6e','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x53\x68\x6f\x77\x6e','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x72\x65\x6d\x6f\x76\x65','\x52\x65\x6d\x6f\x76\x65\x20\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x20\x69\x66\x72\x61\x6d\x65\x20\x62\x65\x66\x6f\x72\x65\x20\x68\x61\x73\x68\x20\x63\x68\x61\x6e\x67\x65\x20\x66\x6f\x72\x20\x6d\x6f\x64\x65\x6c\x20\x76\x69\x65\x77\x20\x69\x6e\x20\x75\x72\x6c','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x64\x69\x73\x6d\x69\x73\x73','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x53\x75\x70\x70\x72\x65\x73\x73\x65\x64','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x6c\x6f\x61\x64\x65\x64','\x65\x76\x65\x6e\x74\x20\x64\x61\x74\x61\x3a\x20','\x4c\x6f\x61\x64\x20\x41\x6c\x74\x65\x72\x6e\x61\x74\x65\x20\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x57\x69\x74\x68\x20\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x54\x79\x70\x65\x3a\x20','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x44\x69\x73\x6d\x69\x73\x73\x65\x64',0,'\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x73\x75\x70\x70\x72\x65\x73\x73\x65\x64','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x4c\x6f\x61\x64\x65\x64','\x61\x61\x2d\x6c\x6f\x61\x64\x2d\x61\x6c\x74\x65\x72\x6e\x61\x74\x65\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x63\x6f\x6d\x70\x6c\x65\x74\x65'];if(event.data){var _$2$2ss$Z=_oo[1];this.logger.log(_oo[9]+event.data);var jsonParsedEvent=void _oo[12];try{jsonParsedEvent=JSON.parse(event.data);}catch(err){var _oOo0oO0Q=function(_i1iLilL1,_ooooQo00){var _Sz2=[25419,29034,33384];var _szszS2Zz=_Sz2[2];var _QOOoQ0Qo=_Sz2[0];return _Sz2[1];};this.logger.log(err.message);return;}switch(jsonParsedEvent.eventId){case _oo[2]:this.logger.log(_oo[3]);break;case _oo[8]:this.logger.log(_oo[14]);this.resizeIframe();this.executeChallengeLoadCallback(jsonParsedEvent.payload);break;case _oo[15]:this.logger.log(_oo[10]+jsonParsedEvent.payload.challengeType);this.clientRequest.challengeTypeValue=jsonParsedEvent.payload.challengeType;this.sendArnoldHttpRequest(this.createNewSessionRequestURL());break;case _oo[13]:this.logger.log(_oo[7]);this.addResponse(jsonParsedEvent.payload);this.sendArnoldHttpRequest(this.createUserAnswerRequestURL());break;case _oo[16]:this.logger.log(_oo[0]);this.addResponse(jsonParsedEvent.payload);this.logger.log(this.currentAAmationResult);this.sendArnoldHttpRequest(this.createUserAnswerRequestURL());break;case _oo[6]:this.logger.log(_oo[11]);this.executeDismissCallback();break;case _oo[4]:this.logger.log(_oo[5]);this.removeWholePageIframe();break;}}};ACIC.prototype.resizeIframe=function(){var _2zZ=['\x70\x78'];if(this.enableCustomizedIframe){var _zzZ2ZZz2=function(_oQQQoQQo){var _$$=['\x65\x78\x65\x63\x75\x74\x65\x55\x73\x65\x72\x61\x67\x65\x6e\x74',.8888162551618759,21589,'\x64\x6f\x6d\x42\x6c\x6f\x62','\x66\x77\x63\x69\x6d\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72',.591038269324142];var _SzzZsZzz=_$$[5];var _LiII1lI1=_$$[2],_l1L1lLLl=_$$[3],_$$ZzS2$2=_$$[4];var _lIlII1il=_$$[0];return _$$[1];};this.iframe.width=this.iframe.contentWindow.document.body.scrollWidth+_2zZ[0];this.iframe.height=this.iframe.contentWindow.document.body.scrollHeight+_2zZ[0];}};ACIC.prototype.addResponse=function(userResponseData){var _i1=[];var userResponse=new ACICUserResponse_1.ACICUserResponse(this.currentAAmationResult.actionTypeValue,JSON.stringify(userResponseData));this.currentUserResponse=userResponse;this.sessionContext.addResponse(userResponse);};ACIC.prototype.addResult=function(resultString){var _s$=[null];if(!resultString){var _0O0ooOQO=function(_$sSSSs$$){var _oO0=['\x64\x6f\x63\x75\x6d\x65\x6e\x74',40752,.7935341531617175];var _QoQOQO0O=_oO0[1],_iIiLiLii=_oO0[2];return _oO0[0];};return _s$[0];}var resultJson=JSON.parse(resultString);var result=new AAmationResult_1.AAmationResult(resultJson.clientSideContext,resultJson.sessionToken,resultJson.actionType);var _sS2ZZ$z2=function(_Ooo0QoQO){var _il=[.7699942270019104,21135];var _zZS2Z$s2=_il[0];return _il[1];};this.currentAAmationResult=result;this.sessionContext.addResult(result);return result;};ACIC.prototype.createNewSessionRequestURL=function(){var _1I=['\x62\x6c\x6f\x62\x44\x61\x74\x61\x4c\x69\x73\x74','\x43\x72\x65\x61\x74\x65\x4e\x65\x77\x53\x65\x73\x73\x69\x6f\x6e\x52\x65\x71\x75\x65\x73\x74\x55\x52\x4c\x3a\x20'];var _1i1lLiiI=_1I[0];var url=build_url_ts_1.default(this.serviceEndpoint,{path:this.clientRequest.clientReferenceIdValue,queryParams:{context:undefined,options:JSON.stringify(this.clientRequest.clientOptions)}});this.logger.log(_1I[1]+url);return url;};ACIC.prototype.createUserAnswerRequestURL=function(){var _llI=['\x2f','\x43\x72\x65\x61\x74\x65\x55\x73\x65\x72\x41\x6e\x73\x77\x65\x72\x52\x65\x71\x75\x65\x73\x74\x55\x52\x4c\x3a\x20'];var url=build_url_ts_1.default(this.serviceEndpoint,{path:this.clientRequest.clientReferenceIdValue+_llI[0]+this.currentAAmationResult.sessionTokenValue,queryParams:{context:this.currentAAmationResult.clientSideContextValue,options:JSON.stringify(this.clientRequest.clientOptions),response:JSON.stringify(this.currentUserResponse)}});this.logger.log(_llI[1]+url);return url;};ACIC.prototype.loadChallengeView=function(view){var _ooO=[37139,'\x65\x6c\x45\x78\x65\x63\x75\x74\x65\x4a\x73\x6f\x6e','\x75\x6e\x64\x65\x66\x69\x6e\x65\x64','\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x45\x78\x65\x63\x75\x74\x65'];if(typeof this.iframe===_ooO[2]&&!this.enableCustomizedIframe){var _L1I1IL11=_ooO[0];this.iframe=this.createIframe();}var _OO0QQOQ0=_ooO[3],_OQOQ0Q0o=_ooO[1];var iframeDocument=this.iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(view);iframeDocument.close();};ACIC.prototype.removeWholePageIframe=function(){var _Z2=['\x52\x65\x6d\x6f\x76\x69\x6e\x67\x20\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x20\x69\x66\x72\x61\x6d\x65\x20\x66\x72\x6f\x6d\x20\x70\x61\x67\x65\x21','\x72\x65\x6d\x6f\x76\x65\x57\x68\x6f\x6c\x65\x50\x61\x67\x65\x49\x66\x72\x61\x6d\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x2d\x69\x66\x72\x61\x6d\x65'];this.logger.log(_Z2[1]);var iframe=document.getElementById(_Z2[2]);if(iframe){this.logger.log(_Z2[0]);iframe.remove();this.iframe=undefined;}};ACIC.prototype.executeDismissCallback=function(){var _$s=[.7494213778493826];this.removeWholePageIframe();var _ss2$SZz$=_$s[0];this.clientRequest.dismissCallbackFunction({});};ACIC.prototype.executeChallengeLoadCallback=function(challengeLoadData){var _ii=[null,'\x62\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72\x43\x61\x70\x74\x63\x68\x61'];if(challengeLoadData==_ii[0]){this.clientRequest.challengeLoadCallbackFunction({height:'',width:''});}else{var _IIllL1iI=_ii[1];this.clientRequest.challengeLoadCallbackFunction({height:challengeLoadData.frameHeight,width:challengeLoadData.frameWidth});}};ACIC.prototype.executeACICCallback=function(aamationResult){var _Oo0=['\x65\x6c\x46\x77\x63\x69\x6d',null,'\x62\x6c\x6f\x62\x43\x61\x70\x74\x63\x68\x61','\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x41\x6d\x61\x7a\x6f\x6e'];if(aamationResult==_Oo0[1]){var _iL1l1IIi=_Oo0[2],_o00QQQoQ=_Oo0[3],_$$z$ZZ$2=_Oo0[0];aamationResult=new AAmationResult_1.AAmationResult(ACIC.STATIC_CLIENT_CONTEXT,ACIC.STATIC_SESSION_TOKEN,ACIC.STATIC_ACTION_TYPE);}this.clientRequest.callbackFunction(aamationResult);};ACIC.prototype.createIframe=function(){var _Q0=['\x69\x66\x72\x61\x6d\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x2d\x69\x66\x72\x61\x6d\x65'];var ifrm=document.createElement(_Q0[0]);ifrm.id=_Q0[1];document.body.appendChild(ifrm);return ifrm;};ACIC.prototype.sendArnoldHttpRequest=function(url,timeout,retryTimes){var _ZS=[28656,'\x50\x4f\x53\x54','\x61\x6e\x74\x69\x2d\x63\x73\x72\x66\x74\x6f\x6b\x65\x6e\x2d\x61\x32\x7a',true,'\x2e\x72\x65\x73\x70\x6f\x6e\x73\x65\x54\x69\x6d\x65','\x73\x65\x6e\x64\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x71\x75\x65\x73\x74','\x63\x6f\x6e\x74\x65\x6e\x74','\x43\x6f\x6e\x74\x65\x6e\x74\x2d\x54\x79\x70\x65',29050,'\x63\x73\x72\x66\x20\x74\x6f\x6b\x65\x6e\x3a\x20','\x66\x77\x63\x69\x6d','\x61\x70','\x47\x45\x54','\x61\x70\x70\x6c\x69\x63\x61\x74\x69\x6f\x6e\x2f\x6a\x73\x6f\x6e','\x6d\x65\x74\x61\x5b\x6e\x61\x6d\x65\x3d\x22\x63\x73\x72\x66\x2d\x74\x6f\x6b\x65\x6e\x22\x5d',0,.9411129797565374];var _this=this;if(timeout===void _ZS[15]){timeout=ACIC.DEFAULT_REQUEST_TIMEOUT;}if(retryTimes===void _ZS[15]){retryTimes=ACIC.DEFAULT_RETRY_TIMES;}this.logger.log(_ZS[5]);var responseTimeMetricName=_ZS[4];var xhr=new XMLHttpRequest();if(this.clientRequest.clientReferenceIdValue===_ZS[11]||this.useRequestMethodPost){xhr.open(_ZS[1],url,_ZS[3]);responseTimeMetricName=_ZS[1]+responseTimeMetricName;}else{var _0OQO00Oo=_ZS[16],_oo0Qoo0Q=_ZS[0],_$$2zZsSS=_ZS[10];xhr.open(_ZS[12],url,_ZS[3]);responseTimeMetricName=_ZS[12]+responseTimeMetricName;}xhr.setRequestHeader(_ZS[7],_ZS[13]);if(this.iframe){var csrfTokenTag=this.iframe.contentDocument.head.querySelector(_ZS[14]);var _ILilLllI=_ZS[8];if(csrfTokenTag){this.csrfToken=csrfTokenTag.getAttribute(_ZS[6]);this.logger.log(_ZS[9]+this.csrfToken);xhr.setRequestHeader(_ZS[2],this.csrfToken);}}xhr.timeout=timeout;var requestStartTime=new Date().valueOf();xhr.send(JSON.stringify({context:this.getclientSideContext(),options:JSON.stringify(this.clientRequest.clientOptions),response:JSON.stringify(this.currentUserResponse),fwcimBlob:this.clientRequest.fwcimBlobValue}));xhr.onerror=function(){var _li=[.2111331040576232,'\x4e\x65\x74\x77\x6f\x72\x6b\x20\x45\x72\x72\x6f\x72\x3a\x20',0,'\x63\x61\x70\x74\x63\x68\x61',null,38711,'\x20\x72\x65\x74\x72\x69\x65\x73\x20\x72\x65\x6d\x61\x69\x6e\x69\x6e\x67\x2e',1,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72\x45\x6e\x63\x72\x79\x70\x74','\x75\x73\x65\x72\x61\x67\x65\x6e\x74','\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x63\x6f\x6e\x6e\x65\x63\x74\x20\x74\x6f\x20\x74\x68\x65\x20\x73\x65\x72\x76\x65\x72\x2e'];var _Li1LIl1I=_li[5],_QQQ0o0OO=_li[3],_LlIllilL=_li[9];if(retryTimes==_li[2]){var _oOQoQoQ0=_li[0],_Sz$Z2sSs=_li[8];_this.acicKatalLogger.error(_li[10],{'\x55\x52\x4c':url});if(_this._onerror){_this._onerror(new ACICError_1.ACICError());}else{_this.executeACICCallback(_li[4]);}}else{_this.acicKatalLogger.error(_li[1]+retryTimes+_li[6],{'\x55\x52\x4c':url});_this.sendArnoldHttpRequest(url,undefined,retryTimes-_li[7]);}};xhr.ontimeout=function(){var _$z=['\x54\x69\x6d\x65\x6f\x75\x74\x3a\x20\x72\x65\x71\x75\x65\x73\x74\x20\x74\x6f\x6f\x6b\x20\x6c\x6f\x6e\x67\x65\x72\x20\x74\x68\x61\x6e\x20\x65\x78\x70\x65\x63\x74\x65\x64\x2e',null];_this.acicKatalLogger.error(_$z[0],{'\x55\x52\x4c':url});if(_this._onerror){var _O0QQ0QQQ=function(_0QOoQOoo,_1i1LlLII,_OQ0ooQO0){var _IL=[39425,45369,24404];var _S$SSzss$=_IL[2];var _QQo0QOOQ=_IL[0];return _IL[1];};_this._onerror(new ACICError_1.ACICError());}else{_this.executeACICCallback(_$z[1]);}};xhr.onload=function(){var _SZ=['\x73\x65\x6e\x64\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x71\x75\x65\x73\x74'];var requestEndTime=new Date().valueOf();_this.acicKatalMetricsPublisher.newChildActionPublisherForMethod(_SZ[0]).publishTimerMonitor(responseTimeMetricName,requestEndTime-requestStartTime);var _$Z$Z2sz$=function(_1lLIL1L1){var _0Q=['\x6f\x62\x66\x75\x73\x63\x61\x74\x65\x44\x6f\x63\x75\x6d\x65\x6e\x74','\x64\x6f\x63\x75\x6d\x65\x6e\x74\x42\x4c\x69\x73\x74',.8280518592196542,5197,35752,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72','\x62\x49\x64\x4e\x6f\x64\x65',.02684578971659124];var _1IIIIIl1=_0Q[1],_$SZZzzZ$=_0Q[3];var _LlIIlliL=_0Q[4],_oOQ0Q0o0=_0Q[2],_OQO0O0oo=_0Q[6];var _zzz$SSZz=_0Q[0],_QooQOQOQ=_0Q[7];return _0Q[5];};_this.processArnoldHttpResponse(xhr);};};ACIC.prototype.getclientSideContext=function(){var _zZ=[42517,null,34509,'\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x45\x78\x65\x63\x75\x74\x65\x55\x73\x65\x72\x61\x67\x65\x6e\x74',.0822776495163915];var _llLiiIiI=_zZ[3],_1LI11iLI=_zZ[0];if(this.currentAAmationResult){var _2$$$z2zZ=_zZ[4],_oQQQOQoQ=_zZ[2];return this.currentAAmationResult.clientSideContextValue;}return _zZ[1];};ACIC.prototype.processArnoldHttpResponse=function(xhr){var _Z$=['\x2e','\x48\x54\x54\x50\x20\x45\x72\x72\x6f\x72\x20',200,null,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x48\x65\x61\x64\x65\x72\x20\x69\x73\x20\x6e\x75\x6c\x6c\x2e',.7520621267443994,14479,44079,'\x70\x72\x6f\x63\x65\x73\x73\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x73\x70\x6f\x6e\x73\x65'];this.logger.log(_Z$[8]);var status=xhr.status;var _zZS22SsZ=_Z$[6],_lllllil1=_Z$[5];this.logger.log(status);if(status!=_Z$[2]){this.acicKatalLogger.error(_Z$[1]+status+_Z$[0],{'\x53\x74\x61\x74\x75\x73':xhr.statusText});this.executeACICCallback(_Z$[3]);}else{var aamationResult=this.addResult(xhr.getResponseHeader(ACIC.AAMATION_SERVICE_RESPONSE_HEADER));this.logger.log(aamationResult);if(!aamationResult){this.acicKatalLogger.error(_Z$[4],{'\x52\x65\x73\x70\x6f\x6e\x73\x65\x55\x52\x4c':xhr.responseURL,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x54\x65\x78\x74':!!xhr.responseText,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x48\x65\x61\x64\x65\x72':xhr.getResponseHeader(ACIC.AAMATION_SERVICE_RESPONSE_HEADER)});var _il1iilL1=function(_ooQ0o00o,_zSs$Szz2,_11ILILlI){var _OQ=[.8854935151205818,.35631540833121234,'\x65\x78\x65\x63\x75\x74\x65\x45\x78\x65\x63\x75\x74\x65','\x6c\x69\x73\x74\x42\x6f\x64\x79'];var _S$S$SZZz=_OQ[2],_li1i11Il=_OQ[3],_Oo0QOO0o=_OQ[1];return _OQ[0];};this.executeACICCallback(_Z$[3]);}else if(aamationResult.actionTypeValue==ACIC.AAMATION_PASS_ACTION_TYPE){this.executeACICCallback(aamationResult);}else if(this.mode&&ACIC.DETECTION_ONLY_MODEL===this.mode){var _ZS$Sz2zZ=_Z$[7];this.executeACICCallback(aamationResult);}else{var view=xhr.responseText;var _IlIiiili=function(_l1li1iLI,_lI1iiLLl){var _0O=[.43032885925341735,.001198775914940775,.3857665903890972,1691,'\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x48\x61\x73\x68'];var _0Q00QQ00=_0O[3];var _ss$ZZ22$=_0O[2],_l1L11ILI=_0O[0],_1i1li1Li=_0O[4];return _0O[1];};this.loadChallengeView(view);}}};ACIC.DEFAULT_REQUEST_TIMEOUT=_L1[8];ACIC.DEFAULT_RETRY_TIMES=_L1[5];ACIC.AAMATION_SERVICE_RESPONSE_HEADER=_L1[7];ACIC.AAMATION_PASS_ACTION_TYPE=_L1[10];ACIC.SERVICE_BASE_PATH=_L1[1];ACIC.STATIC_CLIENT_CONTEXT=_L1[4];ACIC.STATIC_SESSION_TOKEN=_L1[2];ACIC.STATIC_ACTION_TYPE=_L1[10];ACIC.DETECTION_ONLY_MODEL=_L1[9];ACIC.KATAL_METRICS_SERVICE_NAME=_L1[6];return ACIC;}();exports.ACIC=ACIC;

/***/ }),

/***/ "./src/css/iframe.css":
/*!****************************!*\
  !*** ./src/css/iframe.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./iframe.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./src/data/AAmationResult.ts":
/*!************************************!*\
  !*** ./src/data/AAmationResult.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var AAmationResult=function(){var _OOO=['\x61\x63\x74\x69\x6f\x6e\x54\x79\x70\x65\x56\x61\x6c\x75\x65','\x73\x65\x73\x73\x69\x6f\x6e\x54\x6f\x6b\x65\x6e\x56\x61\x6c\x75\x65','\x63\x6c\x69\x65\x6e\x74\x53\x69\x64\x65\x43\x6f\x6e\x74\x65\x78\x74\x56\x61\x6c\x75\x65',true];var _zsZ2$szZ=function(_11ii11l1,_Zzs22Z2z){var _00Q=[.3865820730971814,'\x61\x42\x6c\x6f\x62',.3897875665080004,'\x64\x6f\x63\x75\x6d\x65\x6e\x74\x42\x6f\x64\x79'];var _2sS2$S$2=_00Q[2],_lIIiI11i=_00Q[0],_QQ0oOo0o=_00Q[3];return _00Q[1];};function AAmationResult(clientSideContext,sessionToken,actionType){this.clientSideContext=clientSideContext;this.sessionToken=sessionToken;this.actionType=actionType;}Object.defineProperty(AAmationResult.prototype,_OOO[2],{get:function(){var _oOo=[];return this.clientSideContext;},enumerable:_OOO[3],configurable:_OOO[3]});Object.defineProperty(AAmationResult.prototype,_OOO[1],{get:function(){var _S$s=[];var _QO0QoOOo=function(_ooOOO0O0,_O0O0OOOo){var _sZ2=['\x62\x6c\x6f\x62','\x68\x61\x73\x68\x4a\x73\x6f\x6e',26175];var _0OOOOQQo=_sZ2[2],_$2$Z2S2S=_sZ2[0];return _sZ2[1];};return this.sessionToken;},enumerable:_OOO[3],configurable:_OOO[3]});Object.defineProperty(AAmationResult.prototype,_OOO[0],{get:function(){var _l1=[];var _LI1i1lli=function(_0O0QoO0Q){var _l1i=[10277,'\x61\x6d\x61\x7a\x6f\x6e\x53\x74\x61\x74\x65\x6d\x65\x6e\x74\x45\x6c','\x62\x6f\x64\x79',47992,'\x64\x61\x74\x61\x45\x78\x65\x63\x75\x74\x65'];var _zSz$$$$z=_l1i[4],_OoooO0QQ=_l1i[3],_QOoO0O0o=_l1i[0];var _oQ000oOQ=_l1i[2];return _l1i[1];};return this.actionType;},enumerable:_OOO[3],configurable:_OOO[3]});return AAmationResult;}();exports.AAmationResult=AAmationResult;

/***/ }),

/***/ "./src/data/ACICClientRequest.ts":
/*!***************************************!*\
  !*** ./src/data/ACICClientRequest.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICClientRequest=function(){var _Z$S=['\x66\x77\x63\x69\x6d\x42\x6c\x6f\x62\x56\x61\x6c\x75\x65','\x63\x6c\x69\x65\x6e\x74\x4f\x70\x74\x69\x6f\x6e\x73',true,.4693134765879985,null,'\x75\x73\x65\x72\x4c\x61\x6e\x67\x75\x61\x67\x65',false,'\x63\x6c\x69\x65\x6e\x74\x52\x65\x66\x65\x72\x65\x6e\x63\x65\x49\x64\x56\x61\x6c\x75\x65','\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x54\x79\x70\x65\x56\x61\x6c\x75\x65','\x63\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e','\x64\x69\x73\x6d\x69\x73\x73\x43\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e','\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x4c\x6f\x61\x64\x43\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e'];function ACICClientRequest(clientReferenceId,callback,dismissCallback,challengeLoadCallback,clientData,locale,fwcimBlob,externalId,enableHeaderFooter,enableBypassMechanism,enableModalView,challengeType,mode,eventTrigger,aaExternalToken,forceJsFlush){this.clientReferenceId=clientReferenceId;this.callback=callback;this.dismissCallback=dismissCallback||this.defaultDismissCallback;this.challengeLoadCallback=challengeLoadCallback||this.defaultChallengeLoadCallback;this.clientData=clientData||_Z$S[4];this.externalId=externalId||_Z$S[4];this.locale=locale||navigator.language||window.navigator[_Z$S[5]];this.fwcimBlob=fwcimBlob||_Z$S[4];this.enableHeaderFooter=enableHeaderFooter==_Z$S[6]?enableHeaderFooter:_Z$S[2];this.enableBypassMechanism=enableBypassMechanism==_Z$S[2]?enableBypassMechanism:_Z$S[6];this.enableModalView=enableModalView==_Z$S[2]?enableModalView:_Z$S[6];this.challengeType=challengeType||_Z$S[4];this.mode=mode||_Z$S[4];this.eventTrigger=eventTrigger||_Z$S[4];this.aaExternalToken=aaExternalToken||_Z$S[4];this.forceJsFlush=forceJsFlush==_Z$S[2]?forceJsFlush:_Z$S[6];}ACICClientRequest.prototype.defaultDismissCallback=function(){var _ZZZ=['\x44\x69\x73\x6d\x69\x73\x73\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x6e\x6f\x74\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64',null];console.log(_ZZZ[0]);return _ZZZ[1];};ACICClientRequest.prototype.defaultChallengeLoadCallback=function(){var _2zs=[null,'\x66\x77\x63\x69\x6d\x49\x64',5528,'\x43\x6c\x69\x65\x6e\x74\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x6e\x6f\x74\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64\x20\x66\x6f\x72\x20\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x70\x61\x67\x65'];var _lLLli11i=_2zs[1],_s$SsSS$$=_2zs[2];console.log(_2zs[3]);return _2zs[0];};Object.defineProperty(ACICClientRequest.prototype,_Z$S[7],{get:function(){var _1L=[];return this.clientReferenceId;},enumerable:_Z$S[2],configurable:_Z$S[2]});Object.defineProperty(ACICClientRequest.prototype,_Z$S[0],{get:function(){var _sZ=[];return this.fwcimBlob;},enumerable:_Z$S[2],configurable:_Z$S[2]});Object.defineProperty(ACICClientRequest.prototype,_Z$S[9],{get:function(){var _Zs=[];return this.callback;},enumerable:_Z$S[2],configurable:_Z$S[2]});var _z22S2S$z=_Z$S[3];Object.defineProperty(ACICClientRequest.prototype,_Z$S[10],{get:function(){var _iiLi=[];var _oQOQ0O0O=function(_QQooOOQo,_ZZSs$sSs){var _zS=[39774,'\x64\x6f\x6d\x4f\x62\x66\x75\x73\x63\x61\x74\x65\x45\x6c','\x68\x61\x73\x68',26385,'\x6e\x6f\x64\x65\x44\x6f\x63\x75\x6d\x65\x6e\x74\x45\x78\x65\x63\x75\x74\x65','\x62\x6c\x6f\x62\x44\x6f\x63\x75\x6d\x65\x6e\x74'];var _2Sz$SSs$=_zS[3],_1Ill1I1L=_zS[0];var _ZS22zZzs=_zS[5],_2z$$$zz$=_zS[2];var _l1llLl1i=_zS[1];return _zS[4];};return this.dismissCallback;},enumerable:_Z$S[2],configurable:_Z$S[2]});Object.defineProperty(ACICClientRequest.prototype,_Z$S[11],{get:function(){var _oOO=['\x69\x64\x44\x6f\x63\x75\x6d\x65\x6e\x74'];var _1lL1i1iL=_oOO[0];return this.challengeLoadCallback;},enumerable:_Z$S[2],configurable:_Z$S[2]});Object.defineProperty(ACICClientRequest.prototype,_Z$S[1],{get:function(){var _oOOO=[];return{clientData:this.clientData,challengeType:this.challengeType,locale:this.locale,externalId:this.externalId,enableHeaderFooter:this.enableHeaderFooter,enableBypassMechanism:this.enableBypassMechanism,enableModalView:this.enableModalView,eventTrigger:this.eventTrigger,aaExternalToken:this.aaExternalToken,forceJsFlush:this.forceJsFlush};},enumerable:_Z$S[2],configurable:_Z$S[2]});Object.defineProperty(ACICClientRequest.prototype,_Z$S[8],{get:function(){var _iIi=['\x65\x6c\x45\x78\x65\x63\x75\x74\x65',29177];var _i1iI1lil=_iIi[0],_QOoQQoQQ=_iIi[1];return this.challengeType;},set:function(challengeType){var _Q0o=[];var _Ll1iIL1l=function(_0oO0QO0O,_ssZ$Zszz){var _2s=[.632888405535416,15192,.5513380974365458,'\x65\x78\x65\x63\x75\x74\x65\x42\x6f\x64\x79'];var _QQ0OOOo0=_2s[1],_0QQOOoQ0=_2s[2],_Ss2z$$Sz=_2s[3];return _2s[0];};this.challengeType=challengeType;},enumerable:_Z$S[2],configurable:_Z$S[2]});return ACICClientRequest;}();exports.ACICClientRequest=ACICClientRequest;

/***/ }),

/***/ "./src/data/ACICError.ts":
/*!*******************************!*\
  !*** ./src/data/ACICError.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICError=function(){var _SZs=[10419,3667,.2132927635595232];function ACICError(){}var _ii1L1LII=_SZs[2],_OOOQ0OOo=_SZs[0],_111LL1Ll=_SZs[1];return ACICError;}();exports.ACICError=ACICError;

/***/ }),

/***/ "./src/data/ACICSessionContext.ts":
/*!****************************************!*\
  !*** ./src/data/ACICSessionContext.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICSessionContext=function(){var _S$z=[];function ACICSessionContext(){this.aamationResults=[];this.userResponses=[];}ACICSessionContext.prototype.addResponse=function(response){var _lI=[.969182924814108,'\x64\x6f\x6d',.2929355795362294];var _QQ0oQoOQ=_lI[2],_sSSZzSZ2=_lI[0],_zzs2Sz2$=_lI[1];this.userResponses.push(response);};ACICSessionContext.prototype.addResult=function(result){var _ss=[.40932928431662696,40382,.9427665524725206];var _Zs2Z$zS$=_ss[1],_SZzss$sZ=_ss[2],_QQ0OOQ00=_ss[0];this.aamationResults.push(result);};var _o0OQQ00Q=function(_$ssZ22z2){var _$sS=[43626,.2762560252066628,46308];var _OOoOQQ0Q=_$sS[1],_s$Z22z$S=_$sS[2];return _$sS[0];};return ACICSessionContext;}();exports.ACICSessionContext=ACICSessionContext;

/***/ }),

/***/ "./src/data/ACICUserResponse.ts":
/*!**************************************!*\
  !*** ./src/data/ACICUserResponse.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICUserResponse=function(){var _lii=[];function ACICUserResponse(challengeType,data){var _IiliiLi1=function(_Z2$ZZs$S){var _OQQ=[.6297529387415097,.33626926327841344];var _ll1lliLi=_OQQ[0];return _OQQ[1];};this.challengeType=challengeType;this.data=data;}return ACICUserResponse;}();exports.ACICUserResponse=ACICUserResponse;

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var acic_1=__webpack_require__(/*! ./acic */ "./src/acic.ts");var katal_logger_1=__webpack_require__(/*! @amzn/katal-logger */ "./node_modules/@amzn/katal-logger/dist/index.js");var KatalEndpointResolver_1=__webpack_require__(/*! ./KatalEndpointResolver */ "./src/KatalEndpointResolver.ts");if(!String.prototype.startsWith){console.log('\x41\x64\x64\x69\x6e\x67\x20\x70\x6f\x6c\x79\x66\x69\x6c\x6c\x20\x66\x6f\x72\x20\x73\x74\x61\x72\x74\x73\x57\x69\x74\x68');Object.defineProperty(String.prototype,'\x73\x74\x61\x72\x74\x73\x57\x69\x74\x68',{value:function(search,rawPos){var _II=[0];var pos=rawPos>_II[0]?rawPos|_II[0]:_II[0];return this.substring(pos,pos+search.length)===search;}});}if(!String.prototype.endsWith){console.log('\x41\x64\x64\x69\x6e\x67\x20\x70\x6f\x6c\x79\x66\x69\x6c\x6c\x20\x66\x6f\x72\x20\x65\x6e\x64\x73\x57\x69\x74\x68');String.prototype.endsWith=function(search,this_len){var _s2=[];var _I1iLIL1I=function(_oO0OQO0o){var _Sz=['\x62\x6c\x6f\x62\x45\x78\x65\x63\x75\x74\x65\x55\x73\x65\x72\x61\x67\x65\x6e\x74',27747,'\x68\x61\x73\x68\x48\x61\x73\x68\x53\x74\x61\x74\x65\x6d\x65\x6e\x74',27605,23163];var _iILL1I1I=_Sz[3];var _ZZSs2sZ$=_Sz[2],_LLI1ILi1=_Sz[0];var _1iLLlLLl=_Sz[4];return _Sz[1];};if(this_len===undefined||this_len>this.length){this_len=this.length;}return this.substring(this_len-search.length,this_len)===search;};}var acicKatalLogger=new katal_logger_1.default({url:KatalEndpointResolver_1.KatalEndpointResolver.getKatalLoggerEndpoint()});acicKatalLogger.addErrorListener(function(error){var _Oo=[true];return _Oo[0];});var acic=new acic_1.ACIC(acicKatalLogger);window.acic=acic;

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** ./nodejsShims (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!*******************************!*\
  !*** ./nodejsShims (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L2hlbHBlci9tZXRyaWNzLWFnZ3JlZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvZGlzdC9tZXRyaWNzL2thdGFsLW1ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L21ldHJpY3MvbWV0cmljcy1wdWJsaXNoZXItc2luZ2xldG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MtZHJpdmVyLXN1c2hpL2Rpc3QvS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy1kcml2ZXItc3VzaGkvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL0thdGFsTWV0cmljc1B1Ymxpc2hlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9kcml2ZXIvRXJyb3JIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL0ZpcnN0TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9PYmplY3RWYWx1ZXNQb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9lbWJlZFJlcXVlc3RJZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWVyZ2VMaXN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWV0cmljc0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNDb3VudGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLXN1c2hpLWNsaWVudC9kaXN0L1N1c2hpQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9lcnJvci1zdGFjay1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9zcmMvZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrLWdlbmVyYXRvci9zdGFjay1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc3RhY2tmcmFtZS9zdGFja2ZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtZ3BzL3N0YWNrdHJhY2UtZ3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtanMvc3RhY2t0cmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzLWRyaXZlci1zdXNoaS9kaXN0L0thdGFsTWV0cmljc0RyaXZlclN1c2hpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzLWRyaXZlci1zdXNoaS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NQdWJsaXNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9FcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9GaXJzdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL09iamVjdFZhbHVlc1BvbnlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9WYWxpZGF0ZVNpbXBsZVN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL2VtYmVkUmVxdWVzdElkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWVyZ2VMaXN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL21ldHJpY3NFeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljQ291bnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljSHR0cFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi90eXBlcy9DbG91ZFdhdGNoRGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtc3VzaGktY2xpZW50L2Rpc3QvU3VzaGlDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1ByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVpbGQtdXJsLXRzL2Rpc3QvYnVpbGQtdXJsLmpzIiwid2VicGFjazovLy8uL3NyYy9jc3MvaWZyYW1lLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvSG9zdG5hbWVSZXNvbHZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvS2F0YWxFbmRwb2ludFJlc29sdmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9hY2ljLnRzIiwid2VicGFjazovLy8uL3NyYy9jc3MvaWZyYW1lLmNzcz9lYmNjIiwid2VicGFjazovLy8uL3NyYy9kYXRhL0FBbWF0aW9uUmVzdWx0LnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL0FDSUNDbGllbnRSZXF1ZXN0LnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL0FDSUNFcnJvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BQ0lDU2Vzc2lvbkNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvQUNJQ1VzZXJSZXNwb25zZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZWpzU2hpbXMgKGlnbm9yZWQpPzQ4ZTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZWpzU2hpbXMgKGlnbm9yZWQpIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7O1FBRUE7UUFDQTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDhDOzs7Ozs7Ozs7Ozs7QUM3QmE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQsd0NBQXdDLFFBQVE7QUFDaEQsd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLHlDQUF5QyxtQkFBTyxDQUFDLHNHQUFrQjtBQUNuRSxzQ0FBc0MsbUJBQU8sQ0FBQyxpR0FBZTtBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBeUI7QUFDdkQsMkJBQTJCLG1CQUFPLENBQUMsd0dBQTZCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiLCtMQUErTDtBQUMvTDtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYix5Q0FBeUMsMkRBQTJEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsWTs7Ozs7Ozs7Ozs7O0FDNVJZOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsbUJBQU8sQ0FBQyxzQkFBZTs7QUFFdkIsK0JBQStCLG1CQUFPLENBQUMsa0pBQTJCOztBQUVsRTtBQUNBO0FBQ0EsMkI7Ozs7Ozs7Ozs7OztBQ2JhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLG9KQUE4Qzs7QUFFbkY7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSw0Q0FBNEMsbUJBQU8sQ0FBQyxrSUFBcUM7O0FBRXpGLDhDQUE4QyxtQkFBTyxDQUFDLHNJQUF1Qzs7QUFFN0YsMkNBQTJDLG1CQUFPLENBQUMsZ0lBQW9DOztBQUV2Riw4Q0FBOEMsbUJBQU8sQ0FBQyxzSUFBdUM7O0FBRTdGLG1EQUFtRCxtQkFBTyxDQUFDLDRJQUErQjs7QUFFMUYsdUNBQXVDLG1CQUFPLENBQUMsb0hBQW1COztBQUVsRSxrQkFBa0IsbUJBQU8sQ0FBQyx3SEFBcUI7O0FBRS9DLHNCQUFzQixtQkFBTyxDQUFDLGdJQUF5Qjs7QUFFdkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWU7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxZOzs7Ozs7Ozs7Ozs7QUN2VFk7O0FBRWIsOEJBQThCLG1CQUFPLENBQUMsc0pBQStDOztBQUVyRiw2QkFBNkIsbUJBQU8sQ0FBQyxvSkFBOEM7O0FBRW5GO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsOENBQThDLG1CQUFPLENBQUMsc0lBQXVDOztBQUU3RiwyQ0FBMkMsbUJBQU8sQ0FBQyxnSUFBb0M7O0FBRXZGLDhDQUE4QyxtQkFBTyxDQUFDLHNJQUF1Qzs7QUFFN0YsZ0NBQWdDLG1CQUFPLENBQUMsMEVBQVM7O0FBRWpELGtEQUFrRCxtQkFBTyxDQUFDLDRIQUF1Qjs7QUFFakYsZ0RBQWdELG1CQUFPLENBQUMsa0pBQWtDOztBQUUxRiwyQ0FBMkMsbUJBQU8sQ0FBQywwRkFBRzs7QUFFdEQsZ0RBQWdELG1CQUFPLENBQUMsa0pBQWtDOztBQUUxRixrQkFBa0IsbUJBQU8sQ0FBQyx3SEFBcUI7O0FBRS9DLHdCQUF3QixtQkFBTyxDQUFDLG9JQUEyQjs7QUFFM0Qsc0JBQXNCLG1CQUFPLENBQUMsZ0lBQXlCOztBQUV2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELHdDOzs7Ozs7Ozs7Ozs7QUM5WWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtB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LDZDQUE2QywyRUFBMkUsRUFBRSxPQUFPLHlDQUF5QyxrRkFBa0YsRUFBRSxFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUVsaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDdkdBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHlGQUFVOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0lBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7O0FBRWhCLG1CQUFtQjtBQUNuQixvQkFBb0I7O0FBRXBCLGdCQUFnQjtBQUNoQixnQkFBZ0I7O0FBRWhCLGdCQUFnQjtBQUNoQixpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlHQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHFGQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUM5RUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pIQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHFGQUFRO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFpQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsK0ZBQWE7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsaUdBQWM7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsaUdBQWM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CLEVBQUU7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNuWkEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixtQkFBTyxDQUFDLHFIQUF3QjtBQUN6RCxXQUFXLG1CQUFPLENBQUMscUZBQVE7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxVQUFVO0FBQ1Y7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3RaQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztB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QUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDekxZOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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IGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0cmljc0FnZ3JlZ2F0b3IgPSB2b2lkIDA7XG52YXIgTWV0cmljc0FnZ3JlZ2F0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWV0cmljc0FnZ3JlZ2F0b3IoZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5maWx0ZXJGdW5jdGlvbiA9IGZpbHRlckZ1bmN0aW9uO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzID0ge307XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrYXRhbC5tZXRyaWNzLnB1Ymxpc2gnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmFnZ3JlZ2F0ZU1ldHJpYyhldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBNZXRyaWNzQWdncmVnYXRvci5wcm90b3R5cGUuYWdncmVnYXRlTWV0cmljID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IGV2ZW50LmRldGFpbCwgbWV0cmljID0gX2EubWV0cmljLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHNlcnZpY2VOYW1lID0gY29udGV4dC5zZXJ2aWNlTmFtZSwgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyRnVuY3Rpb24gJiYgIXRoaXMuZmlsdGVyRnVuY3Rpb24obWV0cmljLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdID1cbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdIHx8IHt9O1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzW3NlcnZpY2VOYW1lXVttZXRob2ROYW1lXSA9XG4gICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzW3NlcnZpY2VOYW1lXVttZXRob2ROYW1lXSB8fCB7fTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVkTWV0cmljc1tzZXJ2aWNlTmFtZV1bbWV0aG9kTmFtZV1bbWV0cmljLm5hbWVdID1cbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdW21ldGhvZE5hbWVdW21ldHJpYy5uYW1lXSB8fCBbXTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVkTWV0cmljc1tzZXJ2aWNlTmFtZV1bbWV0aG9kTmFtZV1bbWV0cmljLm5hbWVdLnB1c2gobWV0cmljLnZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXRyaWNzQWdncmVnYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1ldHJpY3NBZ2dyZWdhdG9yID0gTWV0cmljc0FnZ3JlZ2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzLWFnZ3JlZ2F0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxldmVsID0gdm9pZCAwO1xudmFyIHByb21pc2VfcG9seWZpbGxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvbWlzZS1wb2x5ZmlsbFwiKSk7XG52YXIgc3RhY2t0cmFjZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzdGFja3RyYWNlLWpzXCIpKTtcbnZhciBrYXRhbF9tZXRyaWNzXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL2thdGFsLW1ldHJpY3NcIik7XG52YXIgbWV0cmljc19hZ2dyZWdhdG9yXzEgPSByZXF1aXJlKFwiLi9oZWxwZXIvbWV0cmljcy1hZ2dyZWdhdG9yXCIpO1xudmFyIExldmVsO1xuKGZ1bmN0aW9uIChMZXZlbCkge1xuICAgIExldmVsW1wiREVCVUdcIl0gPSBcImRlYnVnXCI7XG4gICAgTGV2ZWxbXCJJTkZPXCJdID0gXCJpbmZvXCI7XG4gICAgTGV2ZWxbXCJXQVJOXCJdID0gXCJ3YXJuXCI7XG4gICAgTGV2ZWxbXCJFUlJPUlwiXSA9IFwiZXJyb3JcIjtcbiAgICBMZXZlbFtcIkZBVEFMXCJdID0gXCJmYXRhbFwiO1xufSkoTGV2ZWwgPSBleHBvcnRzLkxldmVsIHx8IChleHBvcnRzLkxldmVsID0ge30pKTtcbnZhciBMT0dfTEVWRUxTID0gW1xuICAgIExldmVsLkRFQlVHLFxuICAgIExldmVsLklORk8sXG4gICAgTGV2ZWwuV0FSTixcbiAgICBMZXZlbC5FUlJPUixcbiAgICBMZXZlbC5GQVRBTCxcbl07XG52YXIgREVGQVVMVF9NQVhfTE9HX0xJTkVfU0laRSA9IDEwMDAwOyAvLyAxMCBraWxvYnl0ZXMgZGVmYXVsdFxudmFyIERFRkFVTFRfQkFUQ0hfVElNRU9VVF9EVVJBVElPTiA9IDUwMDA7XG52YXIgREVGQVVMVF9NQVhfTE9HU19QRVJfQkFUQ0ggPSAyNTtcbnZhciBDT05GSUdfREVGQVVMVFMgPSB7XG4gICAgbG9nVGhyZXNob2xkOiBMZXZlbC5ERUJVRyxcbiAgICBtYXhMb2dMaW5lU2l6ZTogREVGQVVMVF9NQVhfTE9HX0xJTkVfU0laRSxcbiAgICBiYXRjaFRpbWVvdXREdXJhdGlvbjogREVGQVVMVF9CQVRDSF9USU1FT1VUX0RVUkFUSU9OLFxuICAgIGRlY29kZVN0YWNrVHJhY2U6IGZhbHNlLFxuICAgIHJlY29yZE1ldHJpY3M6IHRydWUsXG4gICAgY29udGV4dDoge30sXG4gICAgaGVhZGVyczoge30sXG4gICAgbG9nVG9Db25zb2xlOiBmYWxzZSxcbiAgICBtYXhMb2dzUGVyQmF0Y2g6IERFRkFVTFRfTUFYX0xPR1NfUEVSX0JBVENILFxuICAgIHVzZVhNTEh0dHBSZXF1ZXN0OiBmYWxzZSxcbn07XG4vLyBvYnRhaW5lZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFxudmFyIEVWRU5UX1BST1BFUlRJRVMgPSBbXG4gICAgJ2J1YmJsZXMnLFxuICAgICdjYW5jZWxCdWJibGUnLFxuICAgICdjYW5jZWxhYmxlJyxcbiAgICAnY29tcG9zZWQnLFxuICAgICdjdXJyZW50VGFyZ2V0JyxcbiAgICAnZGVlcFBhdGgnLFxuICAgICdkZWZhdWx0UHJldmVudGVkJyxcbiAgICAnZXZlbnRQaGFzZScsXG4gICAgJ2V4cGxpY2l0T3JpZ2luYWxUYXJnZXQnLFxuICAgICdvcmlnaW5hbFRhcmdldCcsXG4gICAgJ3JldHVyblZhbHVlJyxcbiAgICAnc3JjRWxlbWVudCcsXG4gICAgJ3RhcmdldCcsXG4gICAgJ3RpbWVTdGFtcCcsXG4gICAgJ3R5cGUnLFxuICAgICdpc1RydXN0ZWQnLFxuXTtcbnZhciBFUlJPUl9FVkVOVF9QUk9QRVJUSUVTID0gX19zcHJlYWRBcnJheXMoRVZFTlRfUFJPUEVSVElFUywgWydtZXNzYWdlJ10pO1xudmFyIEthdGFsTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIEthdGFsTG9nZ2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gS2F0YWxMb2dnZXIoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzb3VyY2VUaW1pbmdMb2dnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kTG9nc1RvQmFja2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb2dzVG9TZW5kID0gX3RoaXMubG9nTGluZVF1ZXVlO1xuICAgICAgICAgICAgaWYgKGxvZ3NUb1NlbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubG9nTGluZVF1ZXVlID0gW107XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50TG9nQmF0Y2hTaXplID0gMDtcbiAgICAgICAgICAgIHZhciBsb2dzID0ge1xuICAgICAgICAgICAgICAgIGxvZ3M6IGxvZ3NUb1NlbmQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuc2VuZExvZ1RvQmFja2VuZChfdGhpcy50b0pTT04obG9ncykpO1xuICAgICAgICAgICAgX3RoaXMucXVldWVUaW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY29uZmlnV2l0aERlZmF1bHRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIENPTkZJR19ERUZBVUxUUyksIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudXJsID0gY29uZmlnV2l0aERlZmF1bHRzLnVybDtcbiAgICAgICAgdGhpcy5sb2dUaHJlc2hvbGQgPSBjb25maWdXaXRoRGVmYXVsdHMubG9nVGhyZXNob2xkO1xuICAgICAgICB0aGlzLm1heExvZ0xpbmVTaXplID0gY29uZmlnV2l0aERlZmF1bHRzLm1heExvZ0xpbmVTaXplO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb25maWdXaXRoRGVmYXVsdHMuY29udGV4dDtcbiAgICAgICAgdGhpcy5sb2dUb0NvbnNvbGUgPSBjb25maWdXaXRoRGVmYXVsdHMubG9nVG9Db25zb2xlO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBjb25maWdXaXRoRGVmYXVsdHMuaGVhZGVycztcbiAgICAgICAgdGhpcy5yZWNvcmRNZXRyaWNzID0gY29uZmlnV2l0aERlZmF1bHRzLnJlY29yZE1ldHJpY3M7XG4gICAgICAgIHRoaXMuYmF0Y2hUaW1lb3V0RHVyYXRpb24gPSBjb25maWdXaXRoRGVmYXVsdHMuYmF0Y2hUaW1lb3V0RHVyYXRpb247XG4gICAgICAgIHRoaXMuZGVjb2RlU3RhY2tUcmFjZSA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5kZWNvZGVTdGFja1RyYWNlO1xuICAgICAgICB0aGlzLm1heExvZ3NQZXJCYXRjaCA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5tYXhMb2dzUGVyQmF0Y2g7XG4gICAgICAgIHRoaXMubWF4TG9nQmF0Y2hTaXplID1cbiAgICAgICAgICAgIGNvbmZpZy5tYXhMb2dCYXRjaFNpemUgfHwgdGhpcy5tYXhMb2dMaW5lU2l6ZSAqIHRoaXMubWF4TG9nc1BlckJhdGNoO1xuICAgICAgICB0aGlzLmN1cnJlbnRMb2dCYXRjaFNpemUgPSAwO1xuICAgICAgICB0aGlzLnhocldpdGhDcmVkZW50aWFscyA9IGNvbmZpZ1dpdGhEZWZhdWx0cy54aHJXaXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMudXNlWE1MSHR0cFJlcXVlc3QgPSBjb25maWdXaXRoRGVmYXVsdHMudXNlWE1MSHR0cFJlcXVlc3Q7XG4gICAgICAgIHRoaXMubG9nTGluZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckZucyA9IFtdO1xuICAgICAgICB0aGlzLnVubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nVGhyZXNob2xkSW5kZXggPSBNYXRoLm1heChMT0dfTEVWRUxTLmluZGV4T2YoTGV2ZWwuREVCVUcpLCBMT0dfTEVWRUxTLmluZGV4T2YodGhpcy5sb2dUaHJlc2hvbGQpKTtcbiAgICAgICAgaWYgKHRoaXMubWF4TG9nQmF0Y2hTaXplIDwgdGhpcy5tYXhMb2dMaW5lU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4TG9nQmF0Y2hTaXplKFwiICsgdGhpcy5tYXhMb2dCYXRjaFNpemUgKyBcIikgbXVzdCBiZSBncmVhdGVyIHRoYW4gbWF4TG9nTGluZVNpemUoXCIgKyB0aGlzLm1heExvZ0xpbmVTaXplICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWdXaXRoRGVmYXVsdHMuc2VuZFRvQmFja2VuZE92ZXJyaWRlICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnV2l0aERlZmF1bHRzLnNlbmRUb0JhY2tlbmRPdmVycmlkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zZW5kTG9nVG9CYWNrZW5kID0gY29uZmlnV2l0aERlZmF1bHRzLnNlbmRUb0JhY2tlbmRPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvcmRNZXRyaWNzKSB7XG4gICAgICAgICAgICB0aGlzLm1ldHJpY3NQdWJsaXNoZXIgPSBrYXRhbF9tZXRyaWNzXzEuY3JlYXRlTWV0cmljc1B1Ymxpc2hlcignS2F0YWxMb2dnZXI6TG9hZGVkJyk7XG4gICAgICAgICAgICB0aGlzLm1ldHJpY3NQdWJsaXNoZXIucHVibGlzaENvdW50ZXJNb25pdG9yKCdLYXRhbExvZ2dlcjpjb25zdHJ1Y3QnLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyVW5sb2FkQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnNlbmRMb2dzVG9CYWNrZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMudW5sb2FkZWQgdG8gZmFsc2UgdG8gY29udGludWUgcXVldWVpbmcgdGhlIGxvZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVnaXN0ZXJCYWNrVG9QYWdlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3ZlciBhbGwgb2YgdGhlIHVubG9hZCBjYXNlczpcbiAgICAgKiBodHRwczovL3d3dy5pZ3ZpdGEuY29tLzIwMTUvMTEvMjAvZG9udC1sb3NlLXVzZXItYW5kLWFwcC1zdGF0ZS11c2UtcGFnZS12aXNpYmlsaXR5L1xuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5yZWdpc3RlclVubG9hZEFjdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoJ3BhZ2VoaWRlJywgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoJ2JlZm9yZXVubG9hZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB1c2VyIGNvbWVzIGJhY2sgdG8gdGhlIHBhZ2VcbiAgICAgKiBodHRwczovL3QuY29ycC5hbWF6b24uY29tL0Q2OTkyNzQ2MFxuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5yZWdpc3RlckJhY2tUb1BhZ2VBY3Rpb24gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCdwYWdlc2hvdycsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgYSBjb3B5IG9mIEthdGFsIE1ldHJpY3MgZW1pdHRlZCBvbiB0aGlzIHBhZ2VcbiAgICAgKiBAcGFyYW0gZmlsdGVyRnVuY3Rpb246IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGZpbHRlciBtZXRyaWNzIGJlZm9yZSBwdWJsaXNoaW5nXG4gICAgICovXG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmFkZE1ldHJpY3NMaXN0ZW5lciA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWdncmVnYXRvciA9IG5ldyBtZXRyaWNzX2FnZ3JlZ2F0b3JfMS5NZXRyaWNzQWdncmVnYXRvcihmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgIHZhciB1bmxvYWRlZEFscmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclVubG9hZEFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodW5sb2FkZWRBbHJlYWR5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHVubG9hZGVkQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5pbmZvKCdLYXRhbCBNZXRyaWNzJywgYWdncmVnYXRvci5hZ2dyZWdhdGVkTWV0cmljcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIFBlcmZvcm1hbmNlIEFQSSBsb2dzLlxuICAgICAqIFVzZXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlL2dldEVudHJpZXNcbiAgICAgKiB0byBkZXRlcm1pbmUgcmVzb3VyY2UgYW5kIHBhaW50IHRpbWluZ3MuXG4gICAgICovXG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmFkZFBlcmZvcm1hbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJVbmxvYWRBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubG9nUmVzb3VyY2VUaW1pbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUubG9nUmVzb3VyY2VUaW1pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLnJlc291cmNlVGltaW5nTG9nZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvdXJjZVRpbWluZ0xvZ2dlZCA9IHRydWU7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHdpbmRvdy5wZXJmb3JtYW5jZVxuICAgICAgICAgICAgLmdldEVudHJpZXNCeVR5cGUoJ3Jlc291cmNlJylcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcmVzb3VyY2VUaW1pbmcpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHJlc291cmNlVGltaW5nLCBuYW1lID0gX2IubmFtZSwgaW5pdGlhdG9yVHlwZSA9IF9iLmluaXRpYXRvclR5cGUsIGR1cmF0aW9uID0gX2IuZHVyYXRpb247XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBuYW1lLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgICAgICBhY2NbaW5pdGlhdG9yVHlwZV0gPSAoX2EgPSBhY2NbaW5pdGlhdG9yVHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgYWNjW2luaXRpYXRvclR5cGVdW3Jlc291cmNlXSA9IE1hdGgucm91bmQoZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgcGFpbnQgPSB3aW5kb3cucGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzQnlUeXBlKCdwYWludCcpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHN0YXJ0VGltZSA9IF9hLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIGFjY1tuYW1lXSA9IE1hdGgucm91bmQoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIG5hdmlnYXRpb24gPSBPYmplY3QuZW50cmllcygoX2IgPSAoX2EgPSB3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZSgnbmF2aWdhdGlvbicpWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX2EpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgIGFjY1trZXldID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IE1hdGgucm91bmQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuaW5mbyhcIlBlcmZvcm1hbmNlIFRpbWluZ1wiLCB7IHJlc291cmNlOiByZXNvdXJjZSwgcGFpbnQ6IHBhaW50LCBuYXZpZ2F0aW9uOiBuYXZpZ2F0aW9uIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgZXJyb3JzLiBXaWxsIGxvZyB0aGUgZXJyb3IgaWYgdGhlIGZpbHRlciBjYWxsYmFjayByZXR1cm5zIHRydWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXJDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGVycm9yIG9iamVjdCBhbmQgcmV0dXJucyB3aGV0aGVyIGl0IHNob3VsZCBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuYWRkRXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIChmaWx0ZXJDYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBbJ2Vycm9yJywgJ3VuaGFuZGxlZHJlamVjdGlvbiddLm1hcChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyRXZlbnQobGlzdGVuZXIsIFxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSB0aGlzLmV2ZW50TGlzdGVuZXIgdGVzdGVkIHNlcGVyYXRlbHkgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV2ZW50TGlzdGVuZXIoZSwgZmlsdGVyQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcmVnaXN0ZXJlZCBlcnJvciBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBOb3JtYWwgYXBwbGljYXRpb25zIG5lZWQgbm90IGNhbGwgdGhpcy5cbiAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGZvciBtdWx0aXRlbmFudCBTUEFzIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucmVtb3ZlRXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBjYiwgY2FwdHVyZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIGNhcHR1cmUpO1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJGbnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIGNhcHR1cmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5ldmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGUsIGZpbHRlckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2U7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gZSBpcyBhbiBFcnJvckV2ZW50XG4gICAgICAgIGlmIChlLmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBlcnJvciA9IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZSBpcyBQcm9taXNlUmVqZWN0aW9uRXZlbnRcbiAgICAgICAgZWxzZSBpZiAoZS5yZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGUucmVhc29uKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGUucmVhc29uLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlLnJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGUucmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXJyb3IoZSkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZDogXCIgKyB0aGlzLnRvU3RyaW5nT2JqZWN0KGUpO1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHN0YWNrIHRyYWNlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UgIT09ICdLYXRhbExvZ2dlciBlcnJvcicgJiZcbiAgICAgICAgICAgICghZmlsdGVyQ2FsbGJhY2sgfHwgZmlsdGVyQ2FsbGJhY2soZXJyb3IpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihlcnJvck1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wcyBieSBzd2FsbG93aW5nIGVycm9ycyB0aGF0IG9jY3VyIHdoaWxlIGxvZ2dpbmcgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5jcmVhdGVKc29uU3RyaW5naWZ5UmVwbGFjZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmVmZXJlbmNlLWxvb3AsIGFsc28gcmVmZXJlbmNlZCBmcm9tICdcIiArIGNhY2hlLmdldCh2YWx1ZSkgKyBcIidcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXZlbnQgb2JqZWN0cyBhcmUgaGFyZCB0byBzZXJpYWxpemUgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTU0NzY3Mi9ob3ctdG8tc3RyaW5naWZ5LWV2ZW50LW9iamVjdCkgc28gd2UgbmVlZCBhIGhlbHBlciBtZXRob2RcbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUudG9TdHJpbmdPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBvYmplY3QuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0UHJvcGVydGllcyA9IEVWRU5UX1BST1BFUlRJRVM7XG4gICAgICAgICAgICB2YXIgZXZlbnRPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIC8qKiBpZiBlcnJvciBldmVudCwgd2UgbmVlZCB0byBjYXB0dXJlIHRoZSBlcnJvciBtZXNzYWdlICovXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgICAgIG9iamVjdFByb3BlcnRpZXMgPSBFUlJPUl9FVkVOVF9QUk9QRVJUSUVTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvYmplY3RQcm9wZXJ0aWVzXzEgPSBvYmplY3RQcm9wZXJ0aWVzOyBfaSA8IG9iamVjdFByb3BlcnRpZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IG9iamVjdFByb3BlcnRpZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgLyoqIGlnbm9yZSBzZXJpYWxpemluZyBhbmQgbG9nZ2luZyB0aGUgZW50aXJlIHdpbmRvdyBsb2dcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0W3Byb3BdICE9PSB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRPYmplY3RbcHJvcF0gPSBvYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gZXZlbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZSArICc6JyArIHRoaXMudG9KU09OKG9iamVjdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBKU09OLnN0cmluZ2lmeSBjYW4gdGhyb3cgYnV0IHdlIHJlYWxseSBkb24ndCB3YW50IHRvIGVycm9yIHdoZW4gbG9nZ2luZyBlcnJvclxuICAgICAqIHNvIHVzZSBvdXIgb3duIGVycm9yLXNhZmUgc2VyaWFsaXphdGlvblxuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIHRoaXMuY3JlYXRlSnNvblN0cmluZ2lmeVJlcGxhY2VyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBcInsgXFxcIkthdGFsTG9nZ2VyXFxcIjogXFxcIkZhaWxlZCB0byBzZXJpYWxpemUhXFxcIiwgXFxcImRhdGFcXFwiOiBcXFwiXCIgKyBkYXRhICsgXCJcXFwiLCBcXFwiZXJyb3JcXFwiOiBcXFwiXCIgKyBlcnJvciArIFwiXFxcIiB9XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLkRFQlVHLCBtZXNzYWdlLCBlcnJvciwgY29udGV4dCkudGhlbihmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRSZXF1ZXN0KGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLklORk8sIG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZFJlcXVlc3QoYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFyZ3MoTGV2ZWwuV0FSTiwgbWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZW5kUmVxdWVzdChhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFyZ3MoTGV2ZWwuRVJST1IsIG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZFJlcXVlc3QoYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLkZBVEFMLCBtZXNzYWdlLCBlcnJvciwgY29udGV4dCkudGhlbihmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRSZXF1ZXN0KGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5leHRyYWN0QXJncyA9IGZ1bmN0aW9uIChsZXZlbCwgbWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IGlzRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZXJyb3JOYW1lOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yU3RhY2tUcmFjZTogJycsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGxvZ1BheWxvYWQgPSB7XG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9ySW5mbyxcbiAgICAgICAgICAgIGNvbnRleHQ6IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLmNvbnRleHQpLCAoZXJyb3JJbmZvID8gY29udGV4dCA6IGVycm9yKSksIHsgbG9nVGltZTogRGF0ZS5ub3coKSB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxvZ1BheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrVHJhY2VGcm9tRXJyb3IoZXJyb3IpLnRoZW4oZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgbG9nUGF5bG9hZC5lcnJvci5lcnJvclN0YWNrVHJhY2UgPSB0cmFjZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nUGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlX3BvbHlmaWxsXzEuZGVmYXVsdC5yZXNvbHZlKGxvZ1BheWxvYWQpO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmdldFN0YWNrVHJhY2VGcm9tRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlY29kZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlX3BvbHlmaWxsXzEuZGVmYXVsdC5yZXNvbHZlKFN0cmluZyhlcnJvci5zdGFjaykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlX3BvbHlmaWxsXzEuZGVmYXVsdC5yZXNvbHZlKHN0YWNrdHJhY2VfanNfMS5kZWZhdWx0LmZyb21FcnJvcihlcnJvcilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdGFja2ZyYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZnJhbWVzLm1hcChmdW5jdGlvbiAoc2YpIHsgcmV0dXJuIHNmLnRvU3RyaW5nKCk7IH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHdlIGZhaWxlZCB0byBkZWNvZGUgaXQsIGp1c3Qgb3V0cHV0IHJhd1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhlcnJvci5zdGFjaykgK1xuICAgICAgICAgICAgICAgICdcXG5cXG5GYWlsZWQgdG8gZGVjb2RlIHN0YWNrdHJhY2U6XFxuJyArXG4gICAgICAgICAgICAgICAgU3RyaW5nKGVycik7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucXVldWVMb2dMaW5lKHBheWxvYWQpO1xuICAgICAgICBpZiAodGhpcy5sb2dUb0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZExvZ1RvQ29uc29sZShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLnNlbmRMb2dUb0NvbnNvbGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbGV2ZWwgPSBkYXRhLmxldmVsO1xuICAgICAgICBpZiAoIUxPR19MRVZFTFMuaW5jbHVkZXMoZGF0YS5sZXZlbCkgfHwgZGF0YS5sZXZlbCA9PT0gTGV2ZWwuRkFUQUwpIHtcbiAgICAgICAgICAgIGxldmVsID0gTGV2ZWwuRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZVtsZXZlbF0oZGF0YSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucXVldWVMb2dMaW5lID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF5bG9hZElzVmFsaWQocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IHRoaXMuZ2V0UGF5bG9hZFNpemUocGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9nQmF0Y2hTaXplICsgcGF5bG9hZFNpemUgPiB0aGlzLm1heExvZ0JhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZExvZ3NUb0JhY2tlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9RdWV1ZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudExvZ0JhdGNoU2l6ZSArPSBwYXlsb2FkU2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVubG9hZGVkIHx8IHRoaXMubG9nTGluZVF1ZXVlLmxlbmd0aCA+PSB0aGlzLm1heExvZ3NQZXJCYXRjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZExvZ3NUb0JhY2tlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnF1ZXVlVGltZXJJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVUaW1lcklkID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5zZW5kTG9nc1RvQmFja2VuZCwgdGhpcy5iYXRjaFRpbWVvdXREdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5hcHBlbmRUb1F1ZXVlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5sb2dMaW5lUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5kb0NhbGxCZWFjb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5zZW5kQmVhY29uKSAmJlxuICAgICAgICAgICAgIShPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpLmxlbmd0aCB8fCB0aGlzLnVzZVhNTEh0dHBSZXF1ZXN0KSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuc2VuZExvZ1RvQmFja2VuZCA9IGZ1bmN0aW9uIChkYXRhU3RyaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLnVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9DYWxsQmVhY29uKCkpIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iuc2VuZEJlYWNvbih0aGlzLnVybCwgZGF0YVN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyXzEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAvLyB4aHIgcmVxdWVzdCBpcyBzZXQgdG8gYXN5bmMuXG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGlzIG5lZWRzIHRvIGJlIGNoYW5nZWQgdG8gc3luYywgaXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgeGhyLndpdGhDcmVkZW50aWFscyB3aXRoIHN5bmMgcmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkIHNpbmNlIEZpcmVmb3ggMTEuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9Vc2luZ19YTUxIdHRwUmVxdWVzdCNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICB4aHJfMS5vcGVuKCdQT1NUJywgdGhpcy51cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnhocldpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgICAgICB4aHJfMS53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLnhocldpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyTmFtZSA9IF9hWzBdLCBoZWFkZXJWYWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICB4aHJfMS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB4aHJfMS5zZW5kKGRhdGFTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucGF5bG9hZElzVmFsaWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgYSA9IExPR19MRVZFTFMuaW5kZXhPZihkYXRhLmxldmVsKTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmxvZ1RocmVzaG9sZEluZGV4O1xuICAgICAgICB2YXIgcGFzc2VzTG9nTGV2ZWxDaGVjayA9IGEgPj0gYjtcbiAgICAgICAgaWYgKHBhc3Nlc0xvZ0xldmVsQ2hlY2spIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IHRoaXMuZ2V0UGF5bG9hZFNpemUoZGF0YSk7XG4gICAgICAgICAgICBpZiAocGF5bG9hZFNpemUgPD0gdGhpcy5tYXhMb2dMaW5lU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5nZXRQYXlsb2FkU2l6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gdGhpcy50b0pTT04oZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhU3RyaW5nLmxlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBLYXRhbExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbExvZ2dlcjtcbmZ1bmN0aW9uIGlzRXJyb3Iob2JqZWN0KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBpbiBub2RlICh1bml0IHRlc3RzKSB0aGVyZSBpcyBubyBlcnJvci5jb25zdHJ1Y3Rvci4gSW4gaWUsIHRoZXJlIGlzIG5vIGVycm9yLnN0YWNrICovXG4gICAgcmV0dXJuICgob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lm5hbWUpICYmIG9iamVjdC5tZXNzYWdlICYmIChvYmplY3Quc3RhY2sgfHwgISFvYmplY3QuY29uc3RydWN0b3IpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTWV0cmljc1B1Ymxpc2hlciA9IHZvaWQgMDtcbnZhciBtZXRyaWNzX3B1Ymxpc2hlcl9zaW5nbGV0b25fMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MtcHVibGlzaGVyLXNpbmdsZXRvblwiKTtcbmV4cG9ydHMuY3JlYXRlTWV0cmljc1B1Ymxpc2hlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG1ldHJpY3NfcHVibGlzaGVyX3NpbmdsZXRvbl8xLk1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChtZXRob2ROYW1lKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rYXRhbC1tZXRyaWNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbiA9IHZvaWQgMDtcbnZhciBLYXRhbE1ldHJpY3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3NcIikpO1xudmFyIGthdGFsX21ldHJpY3NfZHJpdmVyX3N1c2hpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3MtZHJpdmVyLXN1c2hpXCIpKTtcbnZhciBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGluaXRpYWxpemluZyB0aGUgc2luZ2xldG9uICovXG4gICAgZnVuY3Rpb24gTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbigpIHtcbiAgICB9XG4gICAgTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFRoaXMgaXMgaW52b2tlZCBieSB0aGUgbWV0cmljcyBkcml2ZXIgKi9cbiAgICAgICAgICAgIHZhciBtZXRyaWNzRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbWV0cmljc0RyaXZlciA9IHRoaXMuZ2V0TWV0cmljc0RyaXZlcihtZXRyaWNzRXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgIHZhciBtZXRyaWNzQ29udGV4dCA9IHRoaXMuZ2V0TWV0cmljc0NvbnRleHQoKTtcbiAgICAgICAgICAgIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uaW5zdGFuY2UgPSBuZXcgS2F0YWxNZXRyaWNzLlB1Ymxpc2hlcihtZXRyaWNzRHJpdmVyLCBtZXRyaWNzRXJyb3JIYW5kbGVyLCBtZXRyaWNzQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uaW5zdGFuY2U7XG4gICAgfTtcbiAgICBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmdldE1ldHJpY3NDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsTWF0Y2ggPSAvKFteP10rKS8uZXhlYyh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIHZhciB1cmxNZXRyaWMgPSBuZXcgS2F0YWxNZXRyaWNzLk1ldHJpYy5TdHJpbmcoJ3VybCcsIFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFRoaXMgaXMgaW52b2tlZCBieSB0aGUgbWV0cmljcyBjb250ZXh0ICovXG4gICAgICAgIHVybE1hdGNoID8gdXJsTWF0Y2hbMV0gOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIHVybE1ldHJpYy50cnVuY2F0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzLkNvbnRleHQuQnVpbGRlcigpXG4gICAgICAgICAgICAud2l0aFNpdGUoJ0thdGFsTG9nZ2VySW50ZXJuYWxNZXRyaWNzJylcbiAgICAgICAgICAgIC53aXRoU2VydmljZU5hbWUoJ0thdGFsTG9nZ2VyJylcbiAgICAgICAgICAgIC5hZGRSZWxhdGVkTWV0cmljcyh1cmxNZXRyaWMpXG4gICAgICAgICAgICAuYnVpbGQoKTtcbiAgICB9O1xuICAgIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uZ2V0TWV0cmljc0RyaXZlciA9IGZ1bmN0aW9uIChtZXRyaWNzRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcga2F0YWxfbWV0cmljc19kcml2ZXJfc3VzaGlfMS5kZWZhdWx0LkJ1aWxkZXIoKVxuICAgICAgICAgICAgLndpdGhEb21haW5SZWFsbSgncHJvZCcsICdVU0FtYXpvbicpXG4gICAgICAgICAgICAud2l0aEVycm9ySGFuZGxlcihtZXRyaWNzRXJyb3JIYW5kbGVyKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbjtcbn0oKSk7XG5leHBvcnRzLk1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24gPSBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljcy1wdWJsaXNoZXItc2luZ2xldG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSB2b2lkIDA7XG5cbnZhciBfb2JqZWN0U3ByZWFkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NEcml2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvZHJpdmVyL0thdGFsTWV0cmljc0RyaXZlclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbnZhciBfa2F0YWxTdXNoaUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLXN1c2hpLWNsaWVudFwiKSk7XG5cbnZhciBfdGVtcDtcblxudmFyIEtBVF9TVEFOREFMT05FX05FWFVTX1BST0RVQ0VSX0lEID0gJ2thdGFsJztcbnZhciBLQVRfU1RBTkRBTE9ORV9ERUZBVUxUX1NPVVJDRV9HUk9VUFMgPSB7XG4gIHRlc3Q6ICdjb20uYW1hem9uLmVlbC5rYXRhbC5tZXRyaWNzLmNvcmUubmV4dXMuZ2FtbWEnLFxuICBwcm9kOiAnY29tLmFtYXpvbi5lZWwua2F0YWwubWV0cmljcy5jb3JlLm5leHVzJ1xufTtcblxudmFyIEthdGFsTWV0cmljc0RyaXZlclN1c2hpID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNzRHJpdmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBfS2F0YWxNZXRyaWNzRHJpdmVyKTtcblxuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaShvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSkuY2FsbCh0aGlzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJzdXNoaVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwicHJvZHVjZXJJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwic291cmNlR3JvdXBJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiZXJyb3JIYW5kbGVyXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJjb21iaW5lZEVycm9ySGFuZGxlclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoX3RoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGVycik7IC8vIFJldHVybiB0byBhdm9pZCBmYWxsaW5nIHRocm91Z2ggdG8gZGVmYXVsdCBlcnJvciBoYW5kbGVyXG5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAobmV4dEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBlcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV4dEVycik7IC8vIEZhbGwgdGhyb3VnaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9KTtcbiAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW4sXG4gICAgICAgIHJlYWxtID0gb3B0aW9ucy5yZWFsbSxcbiAgICAgICAgZXJyb3JIYW5kbGVyID0gb3B0aW9ucy5lcnJvckhhbmRsZXIsXG4gICAgICAgIHN1c2hpQ2xpZW50ID0gb3B0aW9ucy5zdXNoaUNsaWVudCxcbiAgICAgICAgX29wdGlvbnMkc3VzaGlQcm9kdWNlID0gb3B0aW9ucy5zdXNoaVByb2R1Y2VyLFxuICAgICAgICBwcm9kdWNlcklkID0gX29wdGlvbnMkc3VzaGlQcm9kdWNlID09PSB2b2lkIDAgPyBLQVRfU1RBTkRBTE9ORV9ORVhVU19QUk9EVUNFUl9JRCA6IF9vcHRpb25zJHN1c2hpUHJvZHVjZSxcbiAgICAgICAgc3VzaGlDbGllbnRPcHRpb25zID0gb3B0aW9ucy5zdXNoaUNsaWVudE9wdGlvbnMsXG4gICAgICAgIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUgPSBvcHRpb25zLnN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGU7IC8vIGN1c3RvbSBzb3VyY2UgZ3JvdXAgYWx3YXlzIG92ZXJyaWRlcyBkZWZhdWx0c1xuXG4gICAgdmFyIHNvdXJjZUdyb3VwSWQgPSBvcHRpb25zLnNvdXJjZUdyb3VwSWQgfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTW2RvbWFpbl0gfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTWyd0ZXN0J107XG4gICAgX3RoaXMuc3VzaGkgPSBzdXNoaUNsaWVudCB8fCBfdGhpcy5idWlsZFN1c2hpQ2xpZW50KGRvbWFpbiwgcmVhbG0sIHNvdXJjZUdyb3VwSWQsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgX3RoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgIF90aGlzLnByb2R1Y2VySWQgPSBwcm9kdWNlcklkO1xuICAgIF90aGlzLnNvdXJjZUdyb3VwSWQgPSBzb3VyY2VHcm91cElkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBbe1xuICAgIGtleTogXCJiZWZvcmVVbmxvYWRcIixcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFnZSB1bmxvYWRzLiBUaGlzXG4gICAgICogYWxsb3dzIGZvciBhbnkgZmluYWwgbWV0cmljcywgc3VjaCBhcyBwYWdlIHZpc2l0IGR1cmF0aW9uLCB0byBiZSBzZW50XG4gICAgICogYmVmb3JlIHRoZSB1c2VyIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2Ugb3IgY2xvc2VzIHRoZSB0YWIuXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgQVBJIGFuZCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVVbmxvYWQoY2IpIHtcbiAgICAgIHRoaXMuc3VzaGkub25TdXNoaVVubG9hZChjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZXJyb3IgaGFuZGxlciBpZiB0aGUgdXNlci1zdXBwbGllZCBlcnJvciBoYW5kbGVyIGZhaWxzIG9yIGlzIHVuc2V0LiAgU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3NcbiAgICAgKiB1c2VyLXByb3ZpZGVkIGVycm9yIGhhbmRsZXIgbWlzYmVoYXZlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgVW5oYW5kbGVkIGVycm9yIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEVycm9ySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGVycm9yLWhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHVzZXIgd2hlbiB0aGlzIG9iamVjdCB3YXMgY29uc3RydWN0ZWQ7IGlmIHRoYXQgaXMgdW5zZXQgb3IgaXRzZWxmIHRocm93c1xuICAgICAqIGFuIGV4Y2VwdGlvbiwgY2FsbHMgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBhcyBhIGZhbGxiYWNrLCB3aGljaCB3aWxsIGp1c3QgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgRXJyb3Igb2JqZWN0IHRvIGhhbmRsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxpbmdcIixcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gd3JhcCBhIGZ1bmN0aW9uIGluIHRoZSBlcnJvciBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvVGhlVGhpbmcgRnVuY3Rpb24gdG8gcnVuIHVuZGVyIHRoZSB3cmFwcGVyXG4gICAgICogQHJldHVybiBSZXR1cm4gdmFsdWUgZnJvbSBjYWxsZWQgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxpbmcoZG9UaGVUaGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvVGhlVGhpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkU3VzaGlDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRTdXNoaUNsaWVudChkb21haW4sIHJlYWxtLCBzb3VyY2VHcm91cElkLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpIHtcbiAgICAgIGlmICghZG9tYWluIHx8ICFyZWFsbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0thdGFsTWV0cmljc0RyaXZlclN1c2hpIHJlcXVpcmVzIGEgZG9tYWluIGFuZCByZWFsbSB0byBidWlsZCBhIHN1c2hpIGNsaWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0KEthdGFsTWV0cmljc0RyaXZlclN1c2hpLmdldFJlYWxtTmFtZShyZWFsbSksIHNvdXJjZUdyb3VwSWQsIHRoaXMuY29tYmluZWRFcnJvckhhbmRsZXIsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hcIixcbiAgICAvLyBUT0RPOiBlcnJvckhhbmRsZXIgaW4gdGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgaXMgbm90IHJlZmVyZW5jZWQuXG4gICAgLy8gVGVjaCBkZWJ0OiBodHRwczovL2lzc3Vlcy5hbWF6b24uY29tL2lzc3Vlcy9LQVQtODc1XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2gobWV0cmljT2JqZWN0LCBlcnJvckhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBTdXBwb3J0IGZvciBuZXcgMi1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2gsIHdoaWNoIGRvZXMgbm90IHBhc3MgdGhlIHVudXNlZCBlcnJvckhhbmRsZXIgb2JqZWN0IChLQVQtODc1KVxuICAgICAgdmFyIG1ldHJpY3NDb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBhcmd1bWVudHNbMV0gOiBhcmd1bWVudHNbMl07XG4gICAgICB0aGlzLndpdGhFcnJvckhhbmRsaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBsb2dpYyBpcyBub3cgbW92ZWQgaW50byBLYXRhbE1ldHJpY3NQdWJsaXNoZXIsIG9uY2UgZXZlcnlib2R5IGhhcyB0aGF0IHVwZGF0ZSB3ZSBjYW4gcmVtb3ZlIHRoaXMuXG4gICAgICAgIC8vIFRlY2ggZGVidDogaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTg3NlxuICAgICAgICBpZiAoX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0Lkxpc3QgPT09IG1ldHJpY09iamVjdC50eXBlKSB7XG4gICAgICAgICAgbWV0cmljT2JqZWN0Lm1ldHJpY0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgICBfdGhpczIucHVibGlzaChtZXRyaWMsIG1ldHJpY3NDb250ZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dXNTY2hlbWEgPSBfdGhpczIubWFwT2JqZWN0VHlwZVRvTmV4dXNTY2hlbWEobWV0cmljT2JqZWN0LnR5cGUpO1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSAoMCwgX29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIG1ldHJpY3NDb250ZXh0LmNvbnRleHQsIHtcbiAgICAgICAgICBtZXRyaWNLZXk6IG1ldHJpY09iamVjdC5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBtZXRyaWNPYmplY3QudmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1ldHJpY09iamVjdC5pc01vbml0b3IpIHtcbiAgICAgICAgICBmaWVsZHMuaXNNb25pdG9yID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBSZXNldCB0aGUgZXZlbnQgY291bnQgYmFjayB0byAwLCBvdGhlcndpc2UgU3VzaGkgd2lsbCBzdG9wIHB1Ymxpc2hpbmcgYWZ0ZXIgMUsgaXRlbXMgKGh0dHBzOi8vaXNzdWVzLmFtYXpvbi5jb20vaXNzdWVzL0tBVC0xNTM0KVxuXG5cbiAgICAgICAgX3RoaXMyLnN1c2hpLnJlc2V0KCk7XG5cbiAgICAgICAgX3RoaXMyLnN1c2hpLmV2ZW50KGZpZWxkcywgX3RoaXMyLnByb2R1Y2VySWQsIG5leHVzU2NoZW1hLCB7XG4gICAgICAgICAgXCJzc2RcIjogMVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBPYmplY3RUeXBlVG9OZXh1c1NjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBPYmplY3RUeXBlVG9OZXh1c1NjaGVtYShvYmplY3RUeXBlKSB7XG4gICAgICBzd2l0Y2ggKG9iamVjdFR5cGUpIHtcbiAgICAgICAgY2FzZSBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQuU3RyaW5nOlxuICAgICAgICAgIHJldHVybiAna2F0YWwuY2xpZW50Lm1ldHJpY3MuU3RyaW5nLjInO1xuXG4gICAgICAgIGNhc2UgX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0LkNvdW50ZXI6XG4gICAgICAgICAgcmV0dXJuICdrYXRhbC5jbGllbnQubWV0cmljcy5Db3VudGVyLjMnO1xuXG4gICAgICAgIGNhc2UgX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0LlRpbWVyOlxuICAgICAgICAgIHJldHVybiAna2F0YWwuY2xpZW50Lm1ldHJpY3MuVGltZXIuMic7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIuY29uY2F0KG9iamVjdFR5cGUsIFwiIHdoZW4gcHVibGlzaGluZyBtZXRyaWMgb2JqZWN0LlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0UmVhbG1OYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlYWxtTmFtZShyZWFsbSkge1xuICAgICAgc3dpdGNoIChyZWFsbSkge1xuICAgICAgICBjYXNlICdOQUFtYXpvbic6XG4gICAgICAgIGNhc2UgJ1VTQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLk5BO1xuXG4gICAgICAgIGNhc2UgJ0VVQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLkVVO1xuXG4gICAgICAgIGNhc2UgJ0ZFQW1hem9uJzpcbiAgICAgICAgY2FzZSAnSlBBbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuRkU7XG5cbiAgICAgICAgY2FzZSAnQ05BbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuQ047XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBMZXQgdGhlIFN1c2hpQ2xpZW50IGRlY2lkZSBpZiB0aGlzIGlzIGJvZ3VzIG9yIG5vdC5cbiAgICAgICAgICByZXR1cm4gcmVhbG07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbn0oX0thdGFsTWV0cmljc0RyaXZlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBcIkJ1aWxkZXJcIiwgKF90ZW1wID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX3RlbXAoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgX3RlbXApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29udGV4dFwiLCB7fSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShfdGVtcCwgW3tcbiAgICBrZXk6IFwid2l0aFN1c2hpQ2xpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTdXNoaUNsaWVudChzdXNoaUNsaWVudCkge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpQ2xpZW50ID0gc3VzaGlDbGllbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aERvbWFpblJlYWxtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhEb21haW5SZWFsbShkb21haW4sIHJlYWxtKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZG9tYWluID0gZG9tYWluO1xuICAgICAgdGhpcy5jb250ZXh0LnJlYWxtID0gcmVhbG07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEN1c3RvbVByb2R1Y2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhDdXN0b21Qcm9kdWNlcihzdXNoaVByb2R1Y2VySWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdXNoaVByb2R1Y2VyID0gc3VzaGlQcm9kdWNlcklkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDdXN0b21Tb3VyY2VHcm91cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ3VzdG9tU291cmNlR3JvdXAoc291cmNlR3JvdXBJZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnNvdXJjZUdyb3VwSWQgPSBzb3VyY2VHcm91cElkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFN1c2hpQ2xpZW50T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnRPcHRpb25zKHN1c2hpQ2xpZW50T3B0aW9ucykge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpQ2xpZW50T3B0aW9ucyA9IHN1c2hpQ2xpZW50T3B0aW9ucztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoU3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZShzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSA9IHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICByZXR1cm4gbmV3IEthdGFsTWV0cmljc0RyaXZlclN1c2hpKHRoaXMuY29udGV4dCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBfdGVtcDtcbn0oKSwgX3RlbXApKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxucmVxdWlyZShcIi4vbm9kZWpzU2hpbXNcIik7XG5cbnZhciBfS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSByZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaVwiKTtcblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbnZhciBfZGVmYXVsdCA9IF9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaS5LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9vYmplY3RTcHJlYWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWRcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVTdHJpbmdcIikpO1xuXG52YXIgX0ZpcnN0TWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXIvRmlyc3RNYXBcIikpO1xuXG52YXIgX21lcmdlTGlzdHMgPSByZXF1aXJlKFwiLi9oZWxwZXIvbWVyZ2VMaXN0c1wiKTtcblxudmFyIF9lbWJlZFJlcXVlc3RJZCA9IHJlcXVpcmUoXCIuL2hlbHBlci9lbWJlZFJlcXVlc3RJZFwiKTtcblxudmFyIF90ZW1wO1xuXG52YXIgUkVRVUlSRURfRklFTERTID0gWydzaXRlJywgJ3NlcnZpY2VOYW1lJywgJ21ldGhvZE5hbWUnXTtcblxudmFyIEthdGFsTWV0cmljc0NvbnRleHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1ldHJpY3MgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBmaWVsZHMuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0RmllbGRzIENvbnRleHQgZmllbGRzIHZhbHVlIChkZWZhdWx0IGVtcHR5KVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNzQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dEZpZWxkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzQ29udGV4dCk7XG4gICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyBpcyBpbW11dGFibGVcbiAgICB0aGlzLmNvbnRleHQgPSAoMCwgX29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIGNvbnRleHRGaWVsZHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dCB3aGljaCBpcyBhIGNvcHkgb2YgdGhpcyBjb250ZXh0LCB3aXRoIHZhbHVlcyBhZGRlZCBvciBvdmVycmlkZGVuIGZyb21cbiAgICogdGhlIGdpdmVuIGNvbnRleHQuXG4gICAqXG4gICAqIElmIHRoZSBnaXZlbiBjb250ZXh0IGlzIG51bGwgb3IgZW1wdHksIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9yaWdpbmFsIG9iamVjdCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB0aGF0Q29udGV4dCBDb250ZXh0IHRvIG1lcmdlIHZhbHVlcyBmcm9tXG4gICAqIEByZXR1cm4gTmV3IGNvbnRleHQgd2l0aCBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoaXMgY29udGV4dCwgYW5kIHZhbHVlcyBvdmVycmlkZGVuIG9yIGFkZGVkIGJ5IHRoZSBnaXZlbiBjb250ZXh0LlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0NvbnRleHQsIFt7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKHRoYXRDb250ZXh0KSB7XG4gICAgICBpZiAoIXRoYXRDb250ZXh0KSByZXR1cm4gdGhpczsgLy8gQ2hlY2sgZm9yIGEgY29tbW9uIGVycm9yXG5cbiAgICAgIGlmICh0aGF0Q29udGV4dCBpbnN0YW5jZW9mIEthdGFsTWV0cmljc0NvbnRleHQuQnVpbGRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIgb2JqZWN0IHBhc3NlZCBpbnN0ZWFkIG9mIEthdGFsTWV0cmljc0NvbnRleHQuICBUcnkgY2FsbGluZyAuYnVpbGQoKSBtZXRob2QuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoYXRDb250ZXh0IGluc3RhbmNlb2YgS2F0YWxNZXRyaWNzQ29udGV4dCA/IHRoYXRDb250ZXh0LmNvbnRleHQgOiB0aGF0Q29udGV4dDtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gKDAsIF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKHt9LCB0aGlzLmNvbnRleHQsIGNvbnRleHQsIHtcbiAgICAgICAgcmVsYXRlZE1ldHJpY3M6ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MsIGNvbnRleHQucmVsYXRlZE1ldHJpY3MpLFxuICAgICAgICByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbjogKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiwgY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbilcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KG5ld0NvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgY29udGV4dCB3aGljaCBpcyBhIGNvcHkgb2YgdGhpcyBjb250ZXh0IHdpdGggcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY2hpbGQgcHVibGlzaGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBDb3B5IG9mIHRoaXMgY29udGV4dCwgd2l0aCByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiByZW1vdmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aXRob3V0UmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KCgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGhpcy5jb250ZXh0LCB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiB1bmRlZmluZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgY29udGV4dCBzdWl0YWJsZSBmb3IgcHVibGljYXRpb24gdG8gdGhlIGRyaXZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHN0cmlwcyBvdXQgYW55IHByaXZhdGUgZmllbGRzLCBhbmQgbGVhdmVzIG9ubHkgZmllbGRzIGZyb20gdGhlIHNjaGVtYSB0aGF0IHRoZSBkcml2ZXIgc2hvdWxkIHB1Ymxpc2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENvbnRleHQgc3VpdGFibGUgZm9yIGRyaXZlciBwdWJsaWNhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJpdmVyQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcml2ZXJDb250ZXh0KCkge1xuICAgICAgLy8gRG9uJ3QgcHVibGlzaCByZWxhdGVkTWV0cmljcyB0byB0aGUgZHJpdmVyXG4gICAgICB2YXIgbmV3Q29udGV4dEZpZWxkcyA9ICgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGRlbGV0ZSBuZXdDb250ZXh0RmllbGRzW1wicmVsYXRlZE1ldHJpY3NcIl07XG4gICAgICBkZWxldGUgbmV3Q29udGV4dEZpZWxkc1tcInJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCJdO1xuICAgICAgZGVsZXRlIG5ld0NvbnRleHRGaWVsZHNbXCJyZXF1ZXN0SWRcIl07XG5cbiAgICAgIGlmICh0aGlzLmNvbnRleHQucmVxdWVzdElkKSB7XG4gICAgICAgIG5ld0NvbnRleHRGaWVsZHMuYWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShuZXdDb250ZXh0RmllbGRzLmFjdGlvbklkLCB0aGlzLmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KG5ld0NvbnRleHRGaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW1wbGUgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybiBTaW1wbGUgSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmllbGRzKCkge1xuICAgICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyByZW1haW5zIGltbXV0YWJsZVxuICAgICAgcmV0dXJuICgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGEgdmFsaWRhdGlvbiBlcnJvciBvbiB0aGlzIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkIGlmIG9uZSBpcyBmb3VuZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVycm9ycyBmb3VuZCB3aXRoIHRoaXMgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBlcnI7IC8vIEZpZWxkcyDigJxzaXRl4oCdLCDigJxzZXJ2aWNlTmFtZeKAnSwg4oCcbWV0aG9kTmFtZeKAnSwgYW5kIOKAnG1ldHJpY0tleeKAnSBhcmUgcmVxdWlyZWQuXG5cbiAgICAgIGVyciA9ICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkoUkVRVUlSRURfRklFTERTLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKF90aGlzLmNvbnRleHRbZmllbGRdID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGaWVsZCBcIi5jb25jYXQoZmllbGQsIFwiIGlzIHJlcXVpcmVkLCBidXQgaXQgaXMgXCIpLmNvbmNhdChfdGhpcy5jb250ZXh0W2ZpZWxkXSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XG4gICAgICByZXR1cm4gKDAsIF9GaXJzdE1hcC5kZWZhdWx0KShPYmplY3Qua2V5cyh0aGlzLmNvbnRleHQpLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGFuIGluZGl2aWR1YWwgY29udGV4dCBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZCBOYW1lIG9mIGZpZWxkIHRvIHZhbGlkYXRlXG4gICAgICogQHJldHVybnMgRXJyb3IgZm91bmQgd2l0aCB0aGlzIGZpZWxkLCBvciB1bmRlZmluZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlRmllbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgICAgdmFyIHZhbCA9IHRoaXMuY29udGV4dFtmaWVsZF07XG4gICAgICB2YXIgbmFtZUZvckVycm9yID0gXCJmaWVsZCBcIi5jb25jYXQoZmllbGQpO1xuXG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIC8vIFN0cmluZ3Mgd2hpY2ggY291bGQgYmUgdXNlZCBhcyBwYXJ0aXRpb24ga2V5cyAoXCJzaXRlXCIgYW5kIFwic2VydmljZU5hbWVcIikgY2Fubm90IGNvbnRhaW4gc2xhc2hlcywgaW5cbiAgICAgICAgLy8gYWRkaXRpb24gdG8gdGhlIG90aGVyIHJlc3RpY3Rpb25zIGJlbG93LlxuICAgICAgICBjYXNlICdzaXRlJzpcbiAgICAgICAgY2FzZSAnc2VydmljZU5hbWUnOlxuICAgICAgICAgIGlmICh2YWwuaW5kZXhPZignLycpID4gLTEpIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBjb250YWluIG9ubHkgdmFsaWQgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCwgXCIuICBJdCBjYW5ub3QgY29udGFpbiBhIHNsYXNoLlwiKSk7XG4gICAgICAgIC8vIEVsc2UgZmFsbCB0aHJvdWdoXG4gICAgICAgIC8vIFN0cmluZ3MgZm9yIGZpZWxkcyDigJxzaXRl4oCdLCDigJxzZXJ2aWNlTmFtZeKAnSwg4oCcbWV0aG9kTmFtZeKAnSwg4oCcbWV0cmljS2V54oCdIG11c3QgbWF0Y2ggYmUgdmFsaWQgUE1FVCBmaWVsZCBuYW1lczpcbiAgICAgICAgLy8gbWF4aW11bSBsZW5ndGggb2YgMjU2LCBvbmx5IGxldHRlcnMsIG51bWJlcnMsIGFuZCB0aGUgZG90LCBjb2xvbiwgYXQtc2lnbiwgdW5kZXJzY29yZSwgZm9yd2FyZC1zbGFzaCxcbiAgICAgICAgLy8gYW5kIHNsYXNoIGNoYXJhY3RlcnMgKGluIHNob3J0IHRoZSByZWdleCBeW0EtWmEtejAtOS46QF8vLV0rJCkuXG5cbiAgICAgICAgY2FzZSAnbWV0aG9kTmFtZSc6XG4gICAgICAgIGNhc2UgJ2FjdGlvbklkJzpcbiAgICAgICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZVN0cmluZy5kZWZhdWx0KSh2YWwsIG5hbWVGb3JFcnJvcik7XG4gICAgICB9IC8vIE5vIGVycm9yIGZvdW5kLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZGVyIGNsYXNzIGZvciBLYXRhbE1ldHJpY3NDb250ZXh0XG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzQ29udGV4dDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNzQ29udGV4dDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljc0NvbnRleHQsIFwiQnVpbGRlclwiLCAoX3RlbXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfdGVtcCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBfdGVtcCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjb250ZXh0XCIsIHt9KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKF90ZW1wLCBbe1xuICAgIGtleTogXCJ3aXRoU2l0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU2l0ZShzaXRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc2l0ZSA9IHNpdGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFNlcnZpY2VOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTZXJ2aWNlTmFtZShzZXJ2aWNlTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0LnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aE1ldGhvZE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aE1ldGhvZE5hbWUobWV0aG9kTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0Lm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhBY3Rpb25JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQWN0aW9uSWQoYWN0aW9uSWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5hY3Rpb25JZCA9IGFjdGlvbklkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZXF1ZXN0SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFJlcXVlc3RJZChyZXF1ZXN0SWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhbnkgcmVsYXRlZCBtZXRyaWNzIHdpdGggdGhlIGdpdmVuIGxpc3QgKHNlZSBhZGRSZWxhdGVkTWV0cmljcyB0byBhZGQgaW5zdGVhZCBvZiByZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIFJlbGF0ZWQgbWV0cmljcyBhcmUgbWV0cmljcyB0aGF0IGFyZSBwdWJsaXNoZWQgd2hlbmV2ZXIgYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQuICBUaGV5IGFyZSB1c2VkIHRvIHJlbGF0ZSB0aGVcbiAgICAgKiBhY3Rpb24gYmFjayB0byB0aGUgY29udGV4dCB3aGVyZSBpdCBpcyBoYXBwZW5pbmcsIGZvciBleGFtcGxlIGEgcmVxdWVzdCBJRCBvciBhIHVzZXIgaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVsYXRlZE1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzIHRvIHB1Ymxpc2ggd2hlbiBhIG5ldyBhY3Rpb24gaXMgc3RhcnRlZCBmb3IgdGhpcyBjb250ZXh0XG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhSZWxhdGVkTWV0cmljcygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWxhdGVkTWV0cmljcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljcyA9IHJlbGF0ZWRNZXRyaWNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhZGRpdGlvbmFsIHJlbGF0ZWQgbWV0cmljcyB0byB0aGlzIGJ1aWxkZXIuICBTZWUgd2l0aFJlbGF0ZWRNZXRyaWNzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0ZWRNZXRyaWNzIEFkZGl0aW9uYWwgcmVsYXRlZCBtZXRyaWNzIHRvIHB1Ymxpc2ggd2hlbiBhIG5ldyBhY3Rpb24gaXMgc3RhcnRlZCBmb3IgdGhpcyBjb250ZXh0XG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmVsYXRlZE1ldHJpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbGF0ZWRNZXRyaWNzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljcyA9ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MsIHJlbGF0ZWRNZXRyaWNzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHNpbmdsZS1hY3Rpb24gcmVsYXRlZCBtZXRyaWNzIHdpdGggdGhlIGdpdmVuIGxpc3QgKHNlZSBhZGRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiB0byBhZGQgaW5zdGVhZCBvZiByZXBsYWNlLFxuICAgICAqIGFuZCB3aXRoUmVsYXRlZE1ldHJpY3MgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgcmVsYXRlZCBtZXRyaWNzKS5cbiAgICAgKlxuICAgICAqIFNpbmdsZS1hY3Rpb24gcmVsYXRlZCBtZXRyaWNzIGFyZSBwdWJsaXNoZWQgd2hlbiBhIG5ldyBjaGlsZCBtZXRyaWMgcHVibGlzaGVyIGlzIGNyZWF0ZWQsIGJ1dCBub3QgaW5jbHVkZWQgYXNcbiAgICAgKiByZWxhdGVkIG1ldHJpY3MgZm9yIHRoZSBuZXcgY2hpbGQgbWV0cmljIHB1Ymxpc2hlciwgc28gYXJlIG5vdCBwdWJsaXNoZWQgYWdhaW4gaWYgdGhlIGNoaWxkIG1ldHJpYyBwdWJsaXNoZXJcbiAgICAgKiBjcmVhdGVzIGdyYW5kY2hpbGQgcHVibGlzaGVkIG1ldHJpY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0cmljcyBSZWxhdGVkIG1ldHJpY3NcbiAgICAgKiBAcmV0dXJucyBUaGlzIGJ1aWxkZXIgb2JqZWN0IHRvIGNvbnRpbnVlIGJ1aWxkaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBtZXRyaWNzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIG1ldHJpY3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uID0gbWV0cmljcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWRkaXRpb25hbCBzaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyB0byB0aGlzIGJ1aWxkZXIuICBTZWUgYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0cmljcyBSZWxhdGVkIG1ldHJpY3NcbiAgICAgKiBAcmV0dXJucyBUaGlzIGJ1aWxkZXIgb2JqZWN0IHRvIGNvbnRpbnVlIGJ1aWxkaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgbWV0cmljcyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBtZXRyaWNzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24sIG1ldHJpY3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIGZpZWxkcyBzZXQgaW4gdGhpcyBidWlsZGVyIGFuZCB1c2UgdGhlbSB0byBjcmVhdGUgYSBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gS2F0YWxNZXRyaWNzQ29udGV4dCBvYmplY3QgYnVpbHQgd2l0aCB0aGUgcGFyYW1ldGVycyBnaXZlbiB0byB0aGlzIGJ1aWxkZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBfdGVtcDtcbn0oKSwgX3RlbXApKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInV1aWQvdjRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0NvbnRleHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc0NvbnRleHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgS2F0YWxNZXRyaWNzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi5cIikpO1xuXG52YXIgX0thdGFsTWV0cmljU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNTdHJpbmdcIikpO1xuXG52YXIgX21lcmdlTGlzdHMgPSByZXF1aXJlKFwiLi9oZWxwZXIvbWVyZ2VMaXN0c1wiKTtcblxudmFyIF9tZXRyaWNzRXh0ZW5zaW9uID0gcmVxdWlyZShcIi4vaGVscGVyL21ldHJpY3NFeHRlbnNpb25cIik7XG5cbnZhciBfZW1iZWRSZXF1ZXN0SWQgPSByZXF1aXJlKFwiLi9oZWxwZXIvZW1iZWRSZXF1ZXN0SWRcIik7XG5cbnZhciBJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSA9ICdJbml0aWFsaXphdGlvbic7XG5cbi8qKlxuICogRGVmYXVsdCBlcnJvciBoYW5kbGVyIGlmIHRoZSB1c2VyLXN1cHBsaWVkIGVycm9yIGhhbmRsZXIgZmFpbHMgb3IgaXMgdW5zZXQuXG4gKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyB1c2VyLXByb3ZpZGVkIGVycm9yIGhhbmRsZXIgbWlzYmVoYXZlcy5cbiAqL1xudmFyIERFRkFVTFRfRVJST1JfSEFORExFUiA9IGZ1bmN0aW9uIERFRkFVTFRfRVJST1JfSEFORExFUihlcnIpIHtcbiAgY29uc29sZS5lcnJvcihcIkVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKTtcbn07XG5cbnZhciBQQVJFTlRfQUNUSU9OX0lEX05BTUUgPSAncGFyZW50QWN0aW9uSWQnO1xuXG52YXIgZ2V0Q29udGV4dEZpZWxkcyA9IGZ1bmN0aW9uIGdldENvbnRleHRGaWVsZHMoY29udGV4dCkge1xuICBpZiAoY29udGV4dC5jb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufTtcbi8qKlxuICogQ2xhc3MgdXNlZCBmb3IgcHVibGlzaGluZyBtZXRyaWNzIHRvIEthdGFsLiAgQ29udGFpbnMgYSBkcml2ZXIgYW5kIGEgY29udGV4dC5cbiAqXG4gKiBUaGlzIGNsYXNzIGtub3dzIGhvdyB0byBwdWJsaXNoIG1ldHJpY3MsIGFuZCBob3cgdG8gY3JlYXRlIG5ldyBwdWJsaXNoZXJzIHdpdGggYSBtb2RpZmllZCBjb250ZXh0LlxuICovXG5cblxudmFyIEthdGFsTWV0cmljc1B1Ymxpc2hlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbWV0cmljcyBwdWJsaXNoZXIgd2l0aCB0aGUgZ2l2ZW4gZHJpdmVyIGFuZCBjb250ZXh0XG4gICAqXG4gICAqIEBwYXJhbSBkcml2ZXIgU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNzRHJpdmVyIHVzZWQgdG8gcHVibGlzaCB0aGUgbWV0cmljc1xuICAgKiBAcGFyYW0gZXJyb3JIYW5kbGVyIEhhbmRsZXIgZm9yIGVycm9ycyB0aGF0IG9jY3VyIHdoaWxlIHVzaW5nIHRoaXMgcHVibGlzaGVyXG4gICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgZm9yIHRoaXMgbWV0cmljcyBwdWJsaXNoZXI7IGNvbnRhaW5zIGRhdGEgdG8gYmUgaW5jbHVkZWQgd2l0aCBldmVyeVxuICAgKiAgICAgbWV0cmljIHB1Ymxpc2hlZCB1c2luZyB0aGlzIHB1Ymxpc2hlciBvYmplY3QuICBEZWZhdWx0IGlzIGFuIGVtcHR5IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NQdWJsaXNoZXIoZHJpdmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBlcnJvckhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfRVJST1JfSEFORExFUjtcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoKTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NQdWJsaXNoZXIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29tYmluZWRFcnJvckhhbmRsZXJcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9IGNhdGNoIChuZXh0RXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBlcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKG5leHRFcnIpO1xuICAgICAgICBERUZBVUxUX0VSUk9SX0hBTkRMRVIoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGZvciBhIGNvbW1vbiBlcnJvclxuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdC5CdWlsZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIgb2JqZWN0IHBhc3NlZCBpbnN0ZWFkIG9mIEthdGFsTWV0cmljc0NvbnRleHQuICBUcnkgY2FsbGluZyAuYnVpbGQoKSBtZXRob2QuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgIHRoaXMuY29udGV4dCA9ICEoY29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQpID8gbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoY29udGV4dCkgOiBjb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoZSBlcnJvci1oYW5kbGVyIHN1cHBsaWVkIGJ5IHRoZSB1c2VyIHdoZW4gdGhpcyBvYmplY3Qgd2FzIGNvbnN0cnVjdGVkOyBpZiB0aGF0IGlzIHVuc2V0IG9yIGl0c2VsZiB0aHJvd3NcbiAgICogYW4gZXhjZXB0aW9uLCBjYWxscyB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGFzIGEgZmFsbGJhY2ssIHdoaWNoIHdpbGwganVzdCBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiBAcGFyYW0gZXJyIEVycm9yIG9iamVjdCB0byBoYW5kbGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NQdWJsaXNoZXIsIFt7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsaW5nXCIsXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHdyYXAgYSBmdW5jdGlvbiBpbiB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb1RoZVRoaW5nIEZ1bmN0aW9uIHRvIHJ1biB1bmRlciB0aGUgd3JhcHBlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhFcnJvckhhbmRsaW5nKGRvVGhlVGhpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb1RoZVRoaW5nKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lZEVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHJldHVybiBhbGwgdGhlIHJlbGF0ZWQgbWV0cmljcyBvZiBiYXNlIHB1Ymxpc2hlciBhbmQgYWRkaXRpb25hbENvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybiBSZXR1cm4gYWxsIHJlbGF0ZWQgbWV0cmljcyBmcm9tIGJhc2UgcHVibGlzaGVyIGFuZCBhZGRpdGlvbmFsQ29udGV4dC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEFkZGl0aW9uYWxSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBZGRpdGlvbmFsUmVsYXRlZE1ldHJpY3MoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gYWRkaXRpb25hbENvbnRleHQgaW5zdGFuY2VvZiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0ID8gYWRkaXRpb25hbENvbnRleHQuY29udGV4dCA6IGFkZGl0aW9uYWxDb250ZXh0O1xuICAgICAgdmFyIGJhc2VSZWxhdGVkTWV0cmljcyA9IHRoaXMuZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCk7XG4gICAgICByZXR1cm4gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKGJhc2VSZWxhdGVkTWV0cmljcywgbmV3Q29udGV4dC5yZWxhdGVkTWV0cmljcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGFsbCB0aGUgcmVsYXRlZCBtZXRyaWNzIG9mIGJhc2UgcHVibGlzaGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBSZXR1cm4gYWxsIHJlbGF0ZWQgbWV0cmljcyBmcm9tIHRoZSBiYXNlIHB1Ymxpc2hlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICByZXR1cm4gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzLCB0aGlzLmNvbnRleHQuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggdGhlIGdpdmVuIG1ldHJpYyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBndWFyYW50ZWVkIG5ldmVyIHRvIHRocm93IGFuIGV4Y2VwdGlvbi4gIElmIHRoZSBtZXRyaWMgb2JqZWN0IG9yIGNvbnRleHQgYXJlIGludmFsaWQsXG4gICAgICogb3IgYW55IG90aGVyIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgcHVibGlzaGluZywgdGhlIHB1Ymxpc2hlcidzIGVycm9yIGhhbmRsZXIgaXMgY2FsbGVkLiAgSWYgdGhlXG4gICAgICogcHVibGlzaGVyJ3MgZXJyb3IgaGFuZGxlciBpcyB1bnNldCBvciBmYWlscywgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQgKHNlZSBkZWZhdWx0RXJyb3JIYW5kbGVyKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrYXRhbE1ldHJpY09iamVjdCBNZXRyaWMgb2JqZWN0IHRvIHB1Ymxpc2hcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaChrYXRhbE1ldHJpY09iamVjdCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMud2l0aEVycm9ySGFuZGxpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWthdGFsTWV0cmljT2JqZWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHB1Ymxpc2ggdW5kZWZpbmVkL251bGwgbWV0cmljIG9iamVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfS2F0YWxNZXRyaWNPYmplY3QuZGVmYXVsdC5UeXBlcy5MaXN0ID09PSBrYXRhbE1ldHJpY09iamVjdC50eXBlKSB7XG4gICAgICAgICAga2F0YWxNZXRyaWNPYmplY3QubWV0cmljTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICAgIF90aGlzMi5wdWJsaXNoKG1ldHJpYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRyaXZlckNvbnRleHQgPSBfdGhpczIuY29udGV4dC5kcml2ZXJDb250ZXh0KCk7XG5cbiAgICAgICAgICB2YXIgY29udGV4dEVycm9yID0gZHJpdmVyQ29udGV4dC52YWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBpZiAoY29udGV4dEVycm9yKSB0aHJvdyBjb250ZXh0RXJyb3I7XG4gICAgICAgICAgdmFyIG9iamVjdEVycm9yID0ga2F0YWxNZXRyaWNPYmplY3QudmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgICAgaWYgKG9iamVjdEVycm9yKSB0aHJvdyBvYmplY3RFcnJvcjtcbiAgICAgICAgICAoMCwgX21ldHJpY3NFeHRlbnNpb24uZGlzcGF0Y2hNZXRyaWNFdmVudCkoa2F0YWxNZXRyaWNPYmplY3QsIGRyaXZlckNvbnRleHQpO1xuXG4gICAgICAgICAgX3RoaXMyLmRyaXZlci5wdWJsaXNoKGthdGFsTWV0cmljT2JqZWN0LCBfdGhpczIuY29tYmluZWRFcnJvckhhbmRsZXIsIGRyaXZlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHB1Ymxpc2hlciB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhpcyBwdWJsaXNoZXIsIGJ1dCB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGZpZWxkcyBtZXJnZWQgaW50b1xuICAgICAqIHRoZSBuZXcgcHVibGlzaGVyJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZFB1Ymxpc2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZFB1Ymxpc2hlcihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NQdWJsaXNoZXIodGhpcy5kcml2ZXIsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLmNvbnRleHQubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgYWN0aW9uLCBhbmQgcmV0dXJuIGEgbmV3IHB1Ymxpc2hlciBmb3IgbWV0cmljcyByZWxhdGVkIHRvIHRoYXQgYWN0aW9uLlxuICAgICAqXG4gICAgICogQmVnaW5uaW5nIGEgbmV3IGFjdGlvbiBpbnZvbHZlcyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgICAqICAgMS4gR2VuZXJhdGUgYSBuZXcgYWN0aW9uSWQgZm9yIHRoZSBhY3Rpb24sIHJhbmRvbWx5IGluIHRoZSBicm93c2VyXG4gICAgICogICAyLiBJZiB0aGVyZSBhcmUgYW55IHJlbGF0ZWQgbWV0cmljcyBpbiB0aGUgY29udGV4dCwgcHVibGlzaCB0aGVtXG4gICAgICogICAzLiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBwdWJsaXNoZXIgd2l0aCB0aGlzIG9iamVjdCdzIGNvbnRleHQsIG1lcmdlZCB3aXRoIGFueSBhZGRpdGlvbmFsIGNvbnRleHQgZ2l2ZW4sXG4gICAgICogICAgICBtZXJnZWQgd2l0aCB0aGUgYWN0aW9uSWQgZ2VuZXJhdGVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICB2YXIgYWN0aW9uSWQgPSB0aGlzLl9nZW5lcmF0ZUFjdGlvbmlkKGFkZGl0aW9uYWxDb250ZXh0KTtcblxuICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmNvbnRleHQud2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkubWVyZ2Uoe1xuICAgICAgICBhY3Rpb25JZDogYWN0aW9uSWRcbiAgICAgIH0pLm1lcmdlKGFkZGl0aW9uYWxDb250ZXh0KTtcbiAgICAgIHZhciBuZXdQdWJsaXNoZXIgPSBuZXcgS2F0YWxNZXRyaWNzUHVibGlzaGVyKHRoaXMuZHJpdmVyLCB0aGlzLmVycm9ySGFuZGxlciwgbmV3Q29udGV4dCk7XG4gICAgICB2YXIgYWxsUmVsYXRlZE1ldHJpY3MgPSBhZGRpdGlvbmFsQ29udGV4dCAmJiAhKGFkZGl0aW9uYWxDb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdC5CdWlsZGVyKSA/IHRoaXMuZ2V0QWRkaXRpb25hbFJlbGF0ZWRNZXRyaWNzKGFkZGl0aW9uYWxDb250ZXh0KSA6IHRoaXMuZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCk7XG5cbiAgICAgIGlmIChhbGxSZWxhdGVkTWV0cmljcykge1xuICAgICAgICBhbGxSZWxhdGVkTWV0cmljcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICBuZXdQdWJsaXNoZXIucHVibGlzaChtZXRyaWMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1B1Ymxpc2hlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24sIGFuZCByZXR1cm4gYSBuZXcgcHVibGlzaGVyIGZvciBtZXRyaWNzIHJlbGF0ZWQgdG8gdGhhdCBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBBIGNoYWluZWQgYWN0aW9uIGlzIGhhbmRsZWQgdGhlIHNhbWUgd2F5IGFzIGluIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyLCBidXQgYWRkaXRpb25hbGx5LFxuICAgICAqIHRoZSByZXR1cm5lZCBwdWJsaXNoZXIgaGFzIGEgcmVsYXRlZE1ldHJpY05vSW5oZXJpdCBuYW1lZCBcInBhcmVudEFjdGlvbklkXCIsIHdpdGggdGhlIG5ld2x5XG4gICAgICogZ2VuZXJhdGVkIGFjdGlvbklkIGFzIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoZSBlZmZlY3Qgb2YgdGhpcyBpcyB0aGF0IGFueSBmdXJ0aGVyIGNoYWluZWQgY2hpbGQgYWN0aW9ucyBjYW4gYmUgY29ubmVjdGVkIGJhY2sgdG8gdGhpc1xuICAgICAqIGFjdGlvbiB0aHJvdWdoIHRoZSBwYXJlbnRBY3Rpb25JZCwgYW5kIHNvIG9uIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHZhciBhY3Rpb25JZCA9IHRoaXMuX2dlbmVyYXRlQWN0aW9uaWQoYWRkaXRpb25hbENvbnRleHQpO1xuXG4gICAgICB2YXIgcGFyZW50QWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShhY3Rpb25JZCwgdGhpcy5jb250ZXh0LmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIHZhciByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9IFtuZXcgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQoUEFSRU5UX0FDVElPTl9JRF9OQU1FLCBwYXJlbnRBY3Rpb25JZCldO1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCh7XG4gICAgICAgIGFjdGlvbklkOiBhY3Rpb25JZCxcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb246IHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlcihuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWRGb3JNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkRm9yTWV0aG9kKG1ldGhvZE5hbWUsIGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChtZXRob2ROYW1lLCBhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXIobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gZm9yIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uLiAgSXQgd2lsbCBhbHdheXMgaGF2ZSBhIG1ldGhvZE5hbWVcbiAgICAgKiBvZiBcIkluaXRpYWxpemF0aW9uXCI7IG90aGVyd2lzZSB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JJbml0aWFsaXphdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvckluaXRpYWxpemF0aW9uKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSwgYWRkaXRpb25hbENvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZyhuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBLYXRhbE1ldHJpY3MuTWV0cmljLlN0cmluZyhuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUsIHRydW5jYXRlZCB0byB0aGUgbWF4aW11bSBzaXplIGFsbG93ZWQgYnkgdGhlXG4gICAgICogc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgU3RyaW5nIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoU3RyaW5nVHJ1bmNhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZ1RydW5jYXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gbmV3IEthdGFsTWV0cmljcy5NZXRyaWMuU3RyaW5nKG5hbWUsIHZhbHVlKTtcbiAgICAgIG9iamVjdC50cnVuY2F0ZSA9IHRydWU7XG4gICAgICB0aGlzLnB1Ymxpc2gob2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIENvdW50ZXIgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hDb3VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hDb3VudGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IEthdGFsTWV0cmljcy5NZXRyaWMuQ291bnRlcihuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSB0aW1lciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFRpbWVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IEthdGFsTWV0cmljcy5NZXRyaWMuVGltZXIobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBpc01vbml0b3IgZmxhZyBzZXQsIGFuZCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBDb3VudGVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoQ291bnRlck1vbml0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaENvdW50ZXJNb25pdG9yKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IEthdGFsTWV0cmljcy5NZXRyaWMuQ291bnRlcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIHRpbWVyIHdpdGggdGhlIGlzTW9uaXRvciBmbGFnIHNldCwgYW5kIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJNb25pdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hUaW1lck1vbml0b3IobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMucHVibGlzaChuZXcgS2F0YWxNZXRyaWNzLk1ldHJpYy5UaW1lcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB0byBleHRyYWN0IGFuIGFjdGlvbklkIGZyb20gYSBjb250ZXh0IGlmIG9uZSBpcyBwcm92aWRlZCwgYW5kIG90aGVyd2lzZSBnZW5lcmF0ZSBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBY3Rpb24gSUQgc3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVBY3Rpb25pZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVBY3Rpb25pZChjb250ZXh0KSB7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICB2YXIgZmllbGRzID0gZ2V0Q29udGV4dEZpZWxkcyhjb250ZXh0KTtcblxuICAgICAgICBpZiAoZmllbGRzLmFjdGlvbklkKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkcy5hY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF92LmRlZmF1bHQpKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NQdWJsaXNoZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljc1B1Ymxpc2hlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gdm9pZCAwO1xuXG52YXIgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24gREVGQVVMVF9FUlJPUl9IQU5ETEVSKGVycikge1xuICB0aHJvdyBlcnI7XG59O1xuXG5leHBvcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUiA9IERFRkFVTFRfRVJST1JfSEFORExFUjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBLYXRhbCBtZXRyaWNzIGRyaXZlci5cbiAqL1xudmFyIEthdGFsTWV0cmljc0RyaXZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0RyaXZlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NEcml2ZXIpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyLCBbe1xuICAgIGtleTogXCJwdWJsaXNoXCIsXG5cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIHRoZSBnaXZlbiBtZXRyaWMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGVycm9yIGhhbmRsZXIgYW5kIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0cmljT2JqZWN0IE1ldHJpYyBvYmplY3QgdG8gcHVibGlzaC4gIENvbnRhaW5zIG1ldHJpY0tleSwgaXNNb25pdG9yLCB0eXBlLCBhbmQgdmFsdWUuXG4gICAgICogQHBhcmFtIGVycm9ySGFuZGxlciBDYWxsYmFjayBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgYW55IGFzeW5jaHJvbm91cyBlcnJvcnMgdGhhdCBvY2N1ciBpbiB0aGUgZHJpdmVyXG4gICAgICogICAgICh0aGUgZHJpdmVyIHNob3VsZCBqdXN0IHRocm93IGFuIGV4Y2VwdGlvbiBmb3IgYSBzeW5jaHJvbm91cyBlcnJvcikuXG4gICAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBmb3IgcHVibGlzaGluZyB0aGlzIG1ldHJpYy4gIENvbnRhaW5zIGFsbCBvdGhlciBmaWVsZHMgdG8gYmUgcHVibGlzaGVkLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoKG1ldHJpY09iamVjdCwgZXJyb3JIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0thdGFsTWV0cmljc0RyaXZlciBpcyBhbiBhYnN0cmFjdCBjbGFzcywgcGxlYXNlIGNob29zZSBhIGRyaXZlciBhbmQgdXNlIHRoYXQgaW5zdGVhZCcpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzRHJpdmVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY3NEcml2ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmaXJzdE1hcDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBub24tdW5kZWZpbmVkIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHJ1bm5pbmcgZWFjaCB2YWx1ZVxuICogaW4gdGhlIGdpdmVuIGFycmF5IHRocm91Z2ggdGhlIG1hcHBlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSBhcnJheSBBbiBhcnJheSBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0gbWFwcGVyIEEgbWFwcGVyIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiBhIHZhbHVlIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBub24tdW5kZWZpbmVkIHZhbHVlIGZyb20gdGhlIG1hcHBlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmlyc3RNYXAoYXJyYXksIG1hcHBlcikge1xuICB2YXIgdG9SZXR1cm4gPSB1bmRlZmluZWQ7XG4gIGFycmF5LnNvbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgIHRvUmV0dXJuID0gbWFwcGVyKHZhbCk7XG4gICAgcmV0dXJuIHRvUmV0dXJuICE9IG51bGw7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBvYmplY3RWYWx1ZXMgPSBPYmplY3QudmFsdWVzID8gT2JqZWN0LnZhbHVlcyA6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufTtcbnZhciBfZGVmYXVsdCA9IG9iamVjdFZhbHVlcztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRlU2ltcGxlSW50O1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbi8qKlxuICogTnVtYmVyLmlzSW50ZWdlciBpcyBub3QgaW4gSUUxMSwgYW5kIGxldHRpbmcgQmFiZWwgcG9seWZpbGwgaXQgYWRkZWQgdG9vIG11Y2ggd2VpZ2h0LlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc0ludGVnZXJcbiAqL1xudmFyIGlzSW50ZWdlciA9IGZ1bmN0aW9uIGlzSW50ZWdlcih2YWwpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG59O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQgdG8gYmUgcHVibGlzaGVkIHRvIEthdGFsTWV0cmljcyBhcyBhbiBpbnRlZ2VyIChDb3VudGVyIG9yIFRpbWVyKSxcbiAqIGFuZCByZXR1cm4gZWl0aGVyIHVuZGVmaW5lZCAobm8gZXJyb3IpLCBvciBhbiBFcnJvciBvYmplY3QgZGVzY3JpYmluZyB0aGUgcHJvYmxlbS5cbiAqXG4gKiBAcGFyYW0gdmFsIFZhbHVlIHRvIGNoZWNrXG4gKiBAcGFyYW0gbmFtZUZvckVycm9yIE5hbWUgdG8gdXNlIHdoZW4gY29uc3RydWN0aW5nIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBuZWNlc3NhcnlcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2ltcGxlSW50KHZhbCwgbmFtZUZvckVycm9yKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBoYXZlIHR5cGUgJ251bWJlcicsIGJ1dCBpdCB3YXMgdHlwZSAnXCIpLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodmFsKSwgXCInXCIpKTtcbiAgfVxuXG4gIGlmICh2YWwgPCAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIHBvc2l0aXZlLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsKSk7XG4gIH0gLy8gVGhpcyB3aWxsIGFsc28gY2F0Y2ggTmFOIGFuZCBJbmZpbml0eVxuXG5cbiAgaWYgKCFpc0ludGVnZXIodmFsKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBhbiBpbnRlZ2VyLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsKSk7XG4gIH0gLy8gQ291bGRuJ3QgZmluZCBhbnl0aGluZyB3cm9uZywgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbn1cblxuOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRlU2ltcGxlU3RyaW5nO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBTSU1QTEVfU1RSSU5HX1BBVCA9IC9eW0EtWmEtejAtOS46QF8vLV0rJC87XG52YXIgU0lNUExFX1NUUklOR19NQVhfTEVOID0gMTI3O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQgdG8gYmUgcHVibGlzaGVkIHRvIEthdGFsTWV0cmljcyBhcyBhIGZpZWxkIHZhbHVlLFxuICogc3VjaCBhcyBzaXRlLCBzZXJ2aWNlTmFtZSwgbWV0aG9kTmFtZSwgb3IgYWN0aW9uSWQgKG5vdGUgdGhpcyBpcyBub3QgdXNlZCB0byBjaGVjayB2YWx1ZXMgZm9yIHN0cmluZyBtZXRyaWNzKS5cbiAqIEl0IHJldHVybnMgZWl0aGVyIHVuZGVmaW5lZCAobm8gZXJyb3IpLCBvciBhbiBFcnJvciBvYmplY3QgZGVzY3JpYmluZyB0aGUgcHJvYmxlbS5cbiAqXG4gKiBUbyBiZSBwdWJsaXNoZWQsIGl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLCBsZXNzIHRoYW4gMjU2IGNoYXJhY3RlcnMsIGNvbnRhaW5pbmcgb25seSBBU0NJSVxuICogbGV0dGVycywgbnVtYmVycywgb3IgdGhlc2UgY2hhcmFjdGVyczogLjpAXy8tICh0aG9zZSBhcmUgdGhlIFBNRVQgZmllbGQgdmFsdWUgcmVxdWlyZW1lbnRzKS5cbiAqXG4gKiBAcGFyYW0gdmFsIFN0cmluZyB2YWx1ZSB0byBjaGVja1xuICogQHBhcmFtIG5hbWVGb3JFcnJvciBOYW1lIHRvIHVzZSBpbiB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgb25lIGlzIGdlbmVyYXRlZFxuICogQHJldHVybnMgRXJyb3IsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvclxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2ltcGxlU3RyaW5nKHZhbCwgbmFtZUZvckVycm9yKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIGEgc3RyaW5nLCBidXQgaXQgd2FzIGEgXCIpLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodmFsKSkpO1xuICB9XG5cbiAgaWYgKHZhbC5sZW5ndGggPiBTSU1QTEVfU1RSSU5HX01BWF9MRU4pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgbGVzcyB0aGFuIFwiKS5jb25jYXQoU0lNUExFX1NUUklOR19NQVhfTEVOLCBcIiBjaGFyYWN0ZXJzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsLmxlbmd0aCwgXCIgY2hhcmFjdGVyc1wiKSk7XG4gIH1cblxuICBpZiAodmFsLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgbm9uLWJsYW5rXCIpKTtcbiAgfVxuXG4gIGlmICghU0lNUExFX1NUUklOR19QQVQudGVzdCh2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGNvbnRhaW4gb25seSB2YWxpZCBjaGFyYWN0ZXJzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsLCBcIi4gIEl0IGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgYW5kIHRoZXNlIHN5bWJvbHM6IC46QF8vLVwiKSk7XG4gIH0gLy8gQ291bGRuJ3QgZmluZCBhbnl0aGluZyB3cm9uZywgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZW1iZWRSZXF1ZXN0SWQgPSBlbWJlZFJlcXVlc3RJZDtcblxuLy8gdW50aWwgd2UgY2FuIGFkZCBhIHJlcXVlc3RJZCBmaWVsZCB0byB0aGUgYW5kZXMgc2NoZW1hIHdlIHdpbGwgZW1iZWQgaXQgaW4gdGhlIGFjdGlvbklkXG5mdW5jdGlvbiBlbWJlZFJlcXVlc3RJZChhY3Rpb25JZCwgcmVxdWVzdElkKSB7XG4gIGlmIChyZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gW3JlcXVlc3RJZCwgYWN0aW9uSWRdLmpvaW4oXCI6OlwiKTtcbiAgfVxuXG4gIHJldHVybiBhY3Rpb25JZDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1lcmdlTGlzdHMgPSBtZXJnZUxpc3RzO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG4vLyBIZWxwZXIgbWV0aG9kIHRvIG1lcmdlIHR3byBsaXN0cyB3aGljaCBjb3VsZCBiZSB1bmRlZmluZWRcbi8vIFJldHVybnMgbWVyZ2VkIGxpc3RzIGlmIGVpdGhlciBpcyBkZWZpbmVkLCBvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWRcbmZ1bmN0aW9uIG1lcmdlTGlzdHMobGlzdDEsIGxpc3QyKSB7XG4gIGlmIChsaXN0MSB8fCBsaXN0Mikge1xuICAgIHJldHVybiBbXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobGlzdDEgfHwgW10pLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShsaXN0MiB8fCBbXSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kaXNwYXRjaE1ldHJpY0V2ZW50ID0gZGlzcGF0Y2hNZXRyaWNFdmVudDtcblxuLyoqXG4gKiBQdWJsaXNoIHRvIGV4dGVybmFsIHBhcnRpZXMgdGhhdCBhcmUgXG4gKiBsaXN0ZW5pbmcgZm9yIGthdGFsLm1ldHJpY3MucHVibGlzaCBDdXN0b20gRXZlbnRzXG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoTWV0cmljRXZlbnQobWV0cmljLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpc3BhdGNoQ3VzdG9tRXZlbnQobWV0cmljLCBjb250ZXh0KTsgLy8gZm9yIGxlZ2FjeSBwdXJwb3NlcywgYWxzbyBwdWJsaXNoIHRvIF9fS0FUQUxfTUVUUklDU19FWFRFTlNJT05fX1xuXG4gIHB1Ymxpc2hUb01ldHJpY3NFeHRlbnNpb24obWV0cmljLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDdXN0b21FdmVudChtZXRyaWMsIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdrYXRhbC5tZXRyaWNzLnB1Ymxpc2gnLCB7XG4gICAgZGV0YWlsOiB7XG4gICAgICBtZXRyaWM6IG1ldHJpYyxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQuZ2V0RmllbGRzKClcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG4vKipcbiAqIEBEZXByZWNhdGVkXG4gKiBQdWJsaXNoIHRvIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL0thdGFsTWV0cmljc0V4dGVuc2lvblxuICogVGhlIGV4dGVuc2lvbiBpbmplY3RzIGEgZ2xvYmFsIF9fS0FUQUxfTUVUUklDU19FWFRFTlNJT05fXyBvYmplY3Qgd2l0aCBhXG4gKiBgcHVibGlzaGAgbWV0aG9kLlxuICovXG5cblxuZnVuY3Rpb24gcHVibGlzaFRvTWV0cmljc0V4dGVuc2lvbihtZXRyaWMsIGNvbnRleHQpIHtcbiAgdmFyIGV4dGVuc2lvbiA9IHdpbmRvdy5fX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX187XG5cbiAgaWYgKGV4dGVuc2lvbikge1xuICAgIGV4dGVuc2lvbi5wdWJsaXNoKG1ldHJpYywgY29udGV4dC5nZXRGaWVsZHMoKSk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQdWJsaXNoZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc1B1Ymxpc2hlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRleHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRyaWNzRHJpdmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY3NEcml2ZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckhhbmRsZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Vycm9ySGFuZGxlci5FcnJvckhhbmRsZXI7XG4gIH1cbn0pO1xuZXhwb3J0cy5NZXRyaWMgPSB2b2lkIDA7XG5cbnZhciBNZXRyaWMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tZXRyaWNPYmplY3RcIikpO1xuXG5leHBvcnRzLk1ldHJpYyA9IE1ldHJpYztcblxudmFyIF9LYXRhbE1ldHJpY3NQdWJsaXNoZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc1B1Ymxpc2hlclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNzQ29udGV4dCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNzQ29udGV4dFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNzRHJpdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kcml2ZXIvS2F0YWxNZXRyaWNzRHJpdmVyXCIpKTtcblxudmFyIF9FcnJvckhhbmRsZXIgPSByZXF1aXJlKFwiLi9kcml2ZXIvRXJyb3JIYW5kbGVyXCIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZUludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9WYWxpZGF0ZVNpbXBsZUludFwiKSk7XG5cbi8qKlxuICogQ291bnRlciB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgYW4gZXZlbnQgaGFwcGVuZWQgb24gYSBwYWdlLCBvciBhcyBhIHNpbXBsZSAxLzAgY291bnRlciB0byB0cmFja1xuICogc3VjY2VzcyBhbmQgZmFpbHVyZS5cbiAqL1xudmFyIEthdGFsTWV0cmljQ291bnRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNvdW50ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIENvdW50ZXIgbmFtZVxuICAgKiBAcGFyYW0gdmFsdWUgQ291bnRlciB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNDb3VudGVyKG5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNDb3VudGVyKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNDb3VudGVyKS5jYWxsKHRoaXMsIG5hbWUpKTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAqXG4gICAqIEByZXR1cm4gQ291bnRlciB2YWx1ZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBudW1iZXIgdG8gdGhpcyBjb3VudGVyLlxuICAgICAqXG4gICAgICogQ2FuIGFsc28gYmUgbmVnYXRpdmUgdG8gc3VidHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkVmFsdWUgQW1vdW50IHRvIGFkZCB0byB0aGlzIGNvdW50ZXJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGFkZFZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlICs9IGFkZFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNDb3VudGVyLnByb3RvdHlwZSksIFwidmFsaWRhdGlvbkVycm9yXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VwZXJFcnJvcikgcmV0dXJuIHN1cGVyRXJyb3I7XG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZUludC5kZWZhdWx0KSh0aGlzLnZhbHVlLCBcImZpZWxkIHZhbHVlIGluIENvdW50ZXIgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJ1wiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIGNvdW50ZXJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIC8vIE1hdGgucm91bmQgd2lsbCBhbHNvIGNvZXJjZSBmcm9tIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeSwgYW5kIHJldHVybiBOYU4gaWYgaW52YWxpZFxuICAgICAgdGhpcy5fdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHlwZSBmb3IgdGhpcyBjb3VudGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIkNvdW50ZXJcIi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuQ291bnRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY0NvdW50ZXI7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljQ291bnRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljU3RyaW5nXCIpKTtcblxuLyoqXG4gKiBTdGFuZGFyZGl6ZWQgbWV0cmljIGZvciBpbnN0cnVtZW50aW5nIEhUVFAgcmVxdWVzdHMuXG4gKlxuICogVW5kZXIgdGhlIGhvb2QgaXQgaXMgYSBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCB3aXRoIHRoZSBuYW1lIHlvdSBwcm92aWRlIHByZWZpeGVkIHdpdGggXCJIVFRQUmVxdWVzdC5cIi5cbiAqIFRoYXQgb2JqZWN0IHdpbGwgY29udGFpbiBhIG1ldHJpYyBzdWZmaXhlZCB3aXRoIFwiLkxhdGVuY3lcIiBmb3IgdGhlIGxhdGVuY3kgb2YgdGhpcyByZXF1ZXN0LCBhbmQgYSBtZXRyaWMgc3VmZml4ZWRcbiAqIHdpdGggXCIuRmFpbHVyZVwiIHRvIHJlY29yZCB0aGUgZmFpbHVyZSBvciBzdWNjZXNzIG9mIHRoaXMgcmVxdWVzdC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSByZXF1ZXN0IHdpbGwgYmUgdHJhY2tlZCBhcyBhIGZhaWx1cmU7IHRvIG1hcmsgaXQgYXMgYSBzdWNjZXNzIGNhbGwgdGhlIFwic2V0U3VjY2VzcygpXCIgbWV0aG9kLlxuICpcbiAqIEl0IGhhcyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgd2hpY2ggd2lsbCBiZSBlbWl0dGVkIGlmIHNldDsgc2VlIHVybCwgc3RhdHVzQ29kZSwgYW5kIHN0YXR1c1RleHQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBnYXZlIHRoZSBuYW1lIFwiU2VhcmNoXCIsIHRoZXNlIG1ldHJpY3Mgd2lsbCBiZSBjcmVhdGVkOlxuICogICBIVFRQUmVxdWVzdC5TZWFyY2guTGF0ZW5jeSAtIExhdGVuY3kgZm9yIHRoaXMgcmVxdWVzdFxuICogICBIVFRQUmVxdWVzdC5TZWFyY2guRmFpbHVyZSAtIEZhaWx1cmUgZm9yIHRoaXMgcmVxdWVzdCAoMSBmb3IgZmFpbHVyZSwgMCBmb3Igc3VjY2VzcylcbiAqL1xudmFyIEthdGFsTWV0cmljSHR0cFJlcXVlc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY1RpbWVkQXR0ZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBfS2F0YWxNZXRyaWNUaW1lZEF0dGUpO1xuXG4gIC8qKiBUaGUgcHJlZml4IGZvciB0aGlzIG1ldHJpYy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgVVJMIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSBjb2RlIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSB0ZXh0IG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEhUVFAgUmVxdWVzdCB0aW1lZCBhdHRlbXB0IG1ldHJpYyBpbmNvcnBvcmF0aW5nIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBUaGUgbmFtZSB5b3UgZ2l2ZSB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZSBwcmVmaXhlZCB3aXRoIFwiSFRUUFJlcXVlc3QuXCIuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBtZXRyaWM7IHJlc3VsdGluZyBtZXRyaWNzIHdpbGwgcHJlZml4IHRoaXMgbmFtZSB3aXRoIFwiSFRUUFJlcXVlc3QuXCJcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljSHR0cFJlcXVlc3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljSHR0cFJlcXVlc3QpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5IVFRQX1JFUVVFU1RfUFJFRklYLCBcIi5cIikuY29uY2F0KG5hbWUpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXJsIGZvciB0aGlzIG1ldHJpYy5cbiAgICpcbiAgICogQSBzdHJpbmcgbWV0cmljIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IHdpbGwgYmUgcHVibGlzaGVkIGZvciB0aGlzIG1ldHJpYy4gIEl0cyBuYW1lIHdpbGxcbiAgICogYmUgdGhpcyBtZXRyaWNzIG5hbWUgc3VmZml4ZWQgd2l0aCAnLlVSTCcsIGFuZCBpdHMgdmFsdWUgd2lsbCBiZSB0aGUgVVJMIHZhbHVlIGdpdmVuIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBVUkwgZm9yIHRoaXMgbWV0cmljXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgW3tcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBVUkwgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgVVJMIGZvciB0aGlzIG1ldHJpYywgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFVSTCBtZXRyaWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBVUkwgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cmxNZXRyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBmb3IgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBBIHN0cmluZyBtZXRyaWMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlzdCBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSBwdWJsaXNoZWQgZm9yIHRoaXMgbWV0cmljLiAgSXRzIG5hbWUgd2lsbFxuICAgICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5TdGF0dXNDb2RlJywgYW5kIGl0cyB2YWx1ZSB3aWxsIGJlIHRoZSBzdGF0dXMgY29kZSB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNDb2RlXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX0NPREVfU1VGRklYLCBfS2F0YWxNZXRyaWNTdHJpbmcuZGVmYXVsdCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c0NvZGVNZXRyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX0NPREVfU1VGRklYKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEEgc3RyaW5nIG1ldHJpYyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHB1Ymxpc2hlZCBmb3IgdGhpcyBtZXRyaWMuICBJdHMgbmFtZSB3aWxsXG4gICAgICogYmUgdGhpcyBtZXRyaWNzIG5hbWUgc3VmZml4ZWQgd2l0aCAnLlN0YXR1c1RleHQnLCBhbmQgaXRzIHZhbHVlIHdpbGwgYmUgdGhlIHN0YXR1cyB0ZXh0IHZhbHVlIGdpdmVuIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdHVzVGV4dCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgb3IgdW5kZWZpbmVkIHRvIHJlbW92ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzVGV4dFwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19URVhUX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNUZXh0TWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19URVhUX1NVRkZJWCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0O1xufShfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljSHR0cFJlcXVlc3Q7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIkhUVFBfUkVRVUVTVF9QUkVGSVhcIiwgJ0hUVFBSZXF1ZXN0Jyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIlVSTF9TVUZGSVhcIiwgJ1VSTCcpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJTVEFUVVNfQ09ERV9TVUZGSVhcIiwgJ1N0YXR1c0NvZGUnKTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFwiU1RBVFVTX1RFWFRfU1VGRklYXCIsICdTdGF0dXNUZXh0Jyk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHRcIikpO1xuXG4vKipcbiAqIFN0YW5kYXJkaXplZCBtZXRyaWMgZm9yIGluc3RydW1lbnRpbmcgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24uXG4gKlxuICogVW5kZXIgdGhlIGhvb2QgaXQgaXMgYSBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCB3aXRoIHRoZSBuYW1lIFwiSW5pdGlhbGl6YXRpb25cIi5cbiAqIFRoYXQgb2JqZWN0IHdpbGwgY29udGFpbiBhIG1ldHJpYyBzdWZmaXhlZCB3aXRoIFwiLkxhdGVuY3lcIiBmb3IgdGhlIGxhdGVuY3kgb2YgdGhpcyByZXF1ZXN0LCBhbmQgYSBtZXRyaWMgc3VmZml4ZWRcbiAqIHdpdGggXCIuRmFpbHVyZVwiIHRvIHJlY29yZCB0aGUgZmFpbHVyZSBvciBzdWNjZXNzIG9mIHRoaXMgcmVxdWVzdC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSByZXF1ZXN0IHdpbGwgYmUgdHJhY2tlZCBhcyBhIGZhaWx1cmU7IHRvIG1hcmsgaXQgYXMgYSBzdWNjZXNzIGNhbGwgdGhlIFwic2V0U3VjY2VzcygpXCIgbWV0aG9kLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZXNlIG1ldHJpY3Mgd2lsbCBiZSBjcmVhdGVkOlxuICogICBJbml0aWFsaXphdGlvbi5MYXRlbmN5IC0gTGF0ZW5jeSBmb3IgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb25cbiAqICAgSW5pdGlhbGl6YXRpb24uRmFpbHVyZSAtIEZhaWx1cmUgZm9yIHRoaXMgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24gKDEgZm9yIGZhaWx1cmUsIDAgZm9yIHN1Y2Nlc3MpXG4gKi9cbnZhciBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lZEF0dGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiwgX0thdGFsTWV0cmljVGltZWRBdHRlKTtcblxuICAvKiogVGhlIG5hbWUgZm9yIHRoaXMgbWV0cmljLiAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdGltZWQgYXR0ZW1wdCBtZXRyaWMgbmFtZWQgXCJJbml0aWFsaXphdGlvblwiLCBmb3IgcmVjb3JkaW5nIGxhdGVuY3kgYW5kIGZhaWx1cmUgaW5mb3JtYXRpb24gYWJvdXRcbiAgICogeW91ciBhcHBsaWNhdGlvbidzIGluaXRpYWxpemF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uKS5jYWxsKHRoaXMsIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24uSU5JVElBTElaRV9NRVRSSUNfTkFNRSkpO1xuICB9XG5cbiAgcmV0dXJuIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb247XG59KF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbjtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24sIFwiSU5JVElBTElaRV9NRVRSSUNfTkFNRVwiLCAnSW5pdGlhbGl6YXRpb24nKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0TGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RMaXN0XCIpKTtcblxudmFyIF9PYmplY3RWYWx1ZXNQb255ZmlsbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9PYmplY3RWYWx1ZXNQb255ZmlsbFwiKSk7XG5cbi8qKlxuICogTWV0cmljIG9iamVjdCBsaXN0IHRoYXQgdHJhY2tzIG1ldHJpY3MgYnkgbmFtZSwgYW5kIGdlbmVyYXRlcyBtZXRyaWNzIHByZWZpeGVkIHdpdGggdGhlIG5hbWUgb2YgdGhpcyBvYmplY3QuXG4gKi9cbnZhciBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0TGlzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBfS2F0YWxNZXRyaWNPYmplY3RMaXMpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbmFtZWQgb2JqZWN0IGxpc3QuXG4gICAqXG4gICAqIFRoZSBuYW1lIGdpdmVuIGhlcmUgd2lsbCBiZSB1c2VkIHRvIHByZWZpeCBhbGwgbWV0cmljcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGlzIG1ldHJpY1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QobmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QpLmNhbGwodGhpcywgbmFtZSkpO1xuICAgIF90aGlzLm5hbWVkTWV0cmljcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBbe1xuICAgIGtleTogXCJzZXROYW1lZE1ldHJpY1wiLFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgbWV0cmljIHdpdGggdGhlIGdpdmVuIG5hbWUgd2l0aCBhIG5ldyBtZXRyaWMgZ2VuZXJhdGVkIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBuZXdseSBjcmVhdGVkIG1ldHJpYyBzdXBwb3J0cyBtb25pdG9yaW5nLCBpdHMgaXNNb25pdG9yIGZsYWcgd2lsbCBiZSBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAqIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIGNvbnRhaW5pbmcgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcGFyYW0gbWV0cmljQ3JlYXRvciBGdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgZnVsbCBuYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgICAqICAgICAgICBhbmQgcmV0dXJucyBhIG5ld2x5IGNvbnN0cnVjdGVkIEthdGFsTWV0cmljT2JqZWN0IHdpdGggdGhpcyBuYW1lIGFuZCBhbiBhcHByb3ByaWF0ZSB2YWx1ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROYW1lZE1ldHJpYyhzdWJOYW1lLCBtZXRyaWNDcmVhdG9yKSB7XG4gICAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmdldE5hbWVGb3JTdWJNZXRyaWMoc3ViTmFtZSk7XG4gICAgICB2YXIgbWV0cmljID0gbWV0cmljQ3JlYXRvcihmdWxsTmFtZSk7XG5cbiAgICAgIGlmIChtZXRyaWMuY2FuTW9uaXRvcikge1xuICAgICAgICBtZXRyaWMuaXNNb25pdG9yID0gdGhpcy5pc01vbml0b3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdID0gbWV0cmljO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwsIGRlbGV0ZSB0aGUgbWV0cmljIHdpdGggdGhlIGdpdmUgbmFtZTsgb3RoZXJ3aXNlIGlmIHRoZSBnaXZlbiBuYW1lZFxuICAgICAqIG1ldHJpYyBhbHJlYWR5IGV4aXN0cyB1cGRhdGUgaXRzIHZhbHVlOyBvdGhlcndpc2UgY3JlYXRlIGEgbmV3IG1ldHJpYyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgc2V0IGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc3BlY2lhbGl6ZWQgaGVscGVyIG1ldGhvZCBpcyBkZXNpZ25lZCB0byBkZWFsIHdpdGggdGhlIGNvbW1vbiBjYXNlIG9mIGEgdmFsdWUgc2V0dGVyIGluIGEgbW9yZSBjb21wbGV4XG4gICAgICogbWV0cmljLiAgT3V0c2lkZSBvZiBzdWJjbGFzc2VzLCBvdGhlciBtZXRob2RzIHdpbGwgcHJvYmFibHkgcHJvdmUgbW9yZSB1c2VmdWwuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgbnVsbCB0aGUgbWV0cmljIHdpbGwgYWxzbyBiZSBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiBtZXRyaWMgdG8gY3JlYXRlIG9yIGRlbGV0ZVxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZUNsYXNzIENsYXNzIG9mIG5ldyBtZXRyaWMgdG8gY3JlYXRlXG4gICAgICogQHBhcmFtIG5ld1ZhbHVlIE5ldyB2YWx1ZSBmb3IgdGhpcyBtZXRyaWMgKG9yIHVuZGVmaW5lZCB0byBkZWxldGUgdGhlIG1ldHJpYylcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPckRlbGV0ZU5hbWVkTWV0cmljVmFsdWUoc3ViTmFtZSwgbmV3VmFsdWVDbGFzcywgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVOYW1lZE1ldHJpYyhzdWJOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmdldE9yQ3JlYXRlTmFtZWRNZXRyaWMoc3ViTmFtZSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG5ld1ZhbHVlQ2xhc3MobmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0cmljLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3ViLW1ldHJpYyB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IG1ldHJpYyBhbmRcbiAgICAgKiBzdG9yZSBhbmQgcmV0dXJuIHRoYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEBwYXJhbSBtZXRyaWNDcmVhdG9yIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBmdWxsIG5hbWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICogICAgICAgIGFuZCByZXR1cm5zIGEgbmV3bHkgY29uc3RydWN0ZWQgS2F0YWxNZXRyaWNPYmplY3Qgd2l0aCB0aGlzIG5hbWUgYW5kIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG4gICAgICogQHJldHVybiBNZXRyaWMgb2JqZWN0IHdoaWNoIHdhcyByZXRyaWV2ZWQgb3IgY3JlYXRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3JDcmVhdGVOYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPckNyZWF0ZU5hbWVkTWV0cmljKHN1Yk5hbWUsIG1ldHJpY0NyZWF0b3IpIHtcbiAgICAgIGlmICghdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV0pIHtcbiAgICAgICAgdGhpcy5zZXROYW1lZE1ldHJpYyhzdWJOYW1lLCBtZXRyaWNDcmVhdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGdpdmVuIG5hbWVkIHN1Yi1tZXRyaWMsIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHJldHVybiB7S2F0YWxNZXRyaWNPYmplY3QgfCB1bmRlZmluZWR9IE1ldHJpYyBvYmplY3Qgd2l0aCB0aGlzIG5hbWUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lZE1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgZ2l2ZW4gbmFtZWQgc3ViLW1ldHJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVOYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVOYW1lZE1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBtZXRyaWMsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbWV0cmljIGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIFZhbHVlIGZvciB0aGUgZ2l2ZW4gbWV0cmljLCBvciB1bmRlZmluZWQgaWYgdGhlIG1ldHJpYyBkb2VzIG5vdCBleGlzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZWRNZXRyaWNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lZE1ldHJpY1ZhbHVlKHN1Yk5hbWUpIHtcbiAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmdldE5hbWVkTWV0cmljKHN1Yk5hbWUpO1xuICAgICAgaWYgKCFtZXRyaWMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gbWV0cmljLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIG5hbWUgZm9yIHRoZSBnaXZlbiBzdWItbWV0cmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIEZ1bGwgbmFtZSBmb3IgdGhpcyBzdWItbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lRm9yU3ViTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVGb3JTdWJNZXRyaWMoc3ViTmFtZSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIuXCIpLmNvbmNhdChzdWJOYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWV0cmljTGlzdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfT2JqZWN0VmFsdWVzUG9ueWZpbGwuZGVmYXVsdCkodGhpcy5uYW1lZE1ldHJpY3MpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3Q7XG59KF9LYXRhbE1ldHJpY09iamVjdExpc3QuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1R5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBzaW5nbGUgbWV0cmljIGluIEthdGFsLlxuICpcbiAqIEEgc2luZ2xlIG1ldHJpYyBjb250YWlucyB0aGUgbmFtZSAobWV0cmljS2V5KSwgdmFsdWUsIHR5cGUsIGFuZCB0aGUgaXNNb25pdG9yIGZsYWc7IGV2ZXJ5dGhpbmcgZWxzZSBpcyBpbiB0aGVcbiAqIEthdGFsTWV0cmljc0NvbnRleHQgaXQgaXMgcHVibGlzaGVkIHRvLlxuICovXG52YXIgS2F0YWxNZXRyaWNPYmplY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTWV0cmljIHR5cGVzLlxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEthdGFsTWV0cmljT2JqZWN0IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgbWV0cmljOyBwdWJsaXNoZWQgYXMgbWV0cmljS2V5IGZpZWxkXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY09iamVjdChuYW1lKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNPYmplY3QpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2lzTW9uaXRvciA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgZm9yIHRoaXMgbWV0cmljLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIG5hbWUgaXMgaW1tdXRhYmxlLCBhbmQgdGhpcyBjYW5ub3QgYmUgc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyBOYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBbe1xuICAgIGtleTogXCJ3aXRoTW9uaXRvclwiLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBtZXRyaWMsIGFuZCByZXR1cm5zIHRoaXMgb2JqZWN0IGZvciBjb250aW51ZWQgdXNlLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGRldGVybWluZXMgaWYgdGhlIG1ldHJpYyBjYW4gYmUgdXNlZCBmb3IgZGFzaGJvYXJkcyBhbmQgYWxhcm1zIChpLmUuIGlmIGl0IHdpbGwgYmUgcHVibGlzaGVkIHRvIFBNRVQpXG4gICAgICogQHBhcmFtIGlzTW9uaXRvciBOZXcgdmFsdWUgZm9yIHRoZSBpc01vbml0b3IgZmxhZzsgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAqIEByZXR1cm5zIFRoaXMgb2JqZWN0XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhNb25pdG9yKCkge1xuICAgICAgdmFyIGlzTW9uaXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHRoaXMuaXNNb25pdG9yID0gaXNNb25pdG9yO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIGlzIGZvcmNlZCB0byBhIGJvb2xlYW4gYmFzZWQgb24gaXRzIHRydXRoaW5lc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNNb25pdG9yIE5ldyB2YWx1ZSBmb3IgdGhlIGlzTW9uaXRvciBmbGFnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBhIHZhbGlkYXRpb24gZXJyb3Igb24gdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkIGlmIG9uZSBpcyBmb3VuZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtFcnJvciB8IHVuZGVmaW5lZH0gRXJyb3IgZm91bmQgd2l0aCB0aGlzIG9iamVjdCwgb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9yIGlzIGZvdW5kXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIGlmICh0aGlzLmlzTW9uaXRvciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0aGlzLmlzTW9uaXRvciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGaWVsZCBpc01vbml0b3Igc2hvdWxkIGJlIGEgYm9vbGVhbiwgYnV0IGl0IHdhcyBhIFwiLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGhpcy5pc01vbml0b3IpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmRlZmF1bHQpKHRoaXMubmFtZSwgJ2ZpZWxkIG5hbWUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1ldHJpY0tleVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTW9uaXRvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGlzTW9uaXRvcikge1xuICAgICAgdGhpcy5faXNNb25pdG9yID0gISFpc01vbml0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybnMgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc01vbml0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbWV0cmljIGNhbiBiZSBtZWFuaW5nZnVsbHkgbW9uaXRvcmVkLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBtZXRyaWMgY2FuIGJlIG1lYW5pbmdmdWxseSBtb25pdG9yZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3QgbXVzdCBpbXBsZW1lbnQgY2FuTW9uaXRvcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFR5cGUgb2YgdGhpcyBtZXRyaWMgKG9uZSBvZjogU3RyaW5nLCBDb3VudGVyLCBUaW1lciwgTGlzdClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3QgbXVzdCBpbXBsZW1lbnQgdHlwZSBnZXR0ZXInKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY09iamVjdDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBcIlR5cGVzXCIsIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX3NldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfRmlyc3RNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvRmlyc3RNYXBcIikpO1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldHJpYyB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBvdGhlciBtZXRyaWNzOyB3aGVuIGl0IGlzIHB1Ymxpc2hlZCwgdGhlIGxpc3Qgb2YgbWV0cmljcyBpcyByZXRyaWV2ZWQsIGFuZCBhbGxcbiAqIGFyZSBwdWJsaXNoZWQuXG4gKi9cbnZhciBLYXRhbE1ldHJpY09iamVjdExpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QsIF9LYXRhbE1ldHJpY09iamVjdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBLYXRhbE1ldHJpY09iamVjdExpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgbWV0cmljLiAgTm90IHJlYWxseSB1c2VkLCBidXQgcHJlc2VudCBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBtZXRyaWNzLlxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNPYmplY3RMaXN0KG5hbWUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY09iamVjdExpc3QpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdCkuY2FsbCh0aGlzLCBuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBmb3IgdGhpcyBvYmplY3RcbiAgICpcbiAgICogQHJldHVybnMgQXJyYXkgb2YgbWV0cmljcyBmb3IgdGhpcyBvYmplY3RcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QsIFt7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuXG4gICAgLyoqXG4gICAgICogSWYgYW55IG9mIHRoZSBjb250YWluZWQgbWV0cmljcyBhcmUgaW52YWxpZCwgcmV0dXJuIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkOyBvdGhlcndpc2UgcmV0dXJuXG4gICAgICogdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaXNuJ3QgY2FsbGVkIGJ5IHRoZSBwdWJsaXNoZXI7IGl0IHZhbGlkYXRlcyBlYWNoIHN1Yi1tZXRyaWMgb24gaXRzIG93bi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVycm9yIGZvdW5kIHdpdGggc3VibWV0cmljLCBpZiBhbnk7IGVsc2UgdW5kZWZpbmVkXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIC8vIERvZXNuJ3QgbWFrZSBzZW5zZSB0byBjaGVjayBzdXBlcmNsYXNzIGVycm9yIGhlcmUsIHNpbmNlIGl0IGlzIHRoZSBjb250YWluZWQgbWV0cmljcyB0aGF0IG1hdHRlci5cbiAgICAgIHJldHVybiAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKHRoaXMubWV0cmljTGlzdCwgZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICByZXR1cm4gbWV0cmljLnZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ldHJpY0xpc3RcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3RMaXN0IG11c3QgaW1wbGVtZW50IG1ldHJpY0xpc3QgZ2V0dGVyJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTW9uaXRvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGlzTW9uaXRvcikge1xuICAgICAgKDAsIF9zZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCBpc01vbml0b3IsIHRoaXMsIHRydWUpO1xuICAgICAgdGhpcy5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICBpZiAobWV0cmljLmNhbk1vbml0b3IpIHtcbiAgICAgICAgICBtZXRyaWMuaXNNb25pdG9yID0gaXNNb25pdG9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFRoaXMganVzdCBkZWxlZ2F0ZXMgdG8gdGhlIHN1cGVyY2xhc3MsIGJ1dCBpZiB3ZSBvdmVycmlkZSB0aGUgc2V0dGVyIHdpdGhvdXQgb3ZlcnJpZGluZyB0aGUgZ2V0dGVyXG4gICAgLy8gZ2V0dGluZyB0aGUgcHJvcGVydHkgd2lsbCBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuTGlzdDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0TGlzdDtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbi8qKlxuICogU3RyaW5nIHR5cGUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gc3RvcmUgYXJiaXRyYXJ5IHN0cmluZ3Mgb2YgZGF0YS5cbiAqL1xudmFyIEthdGFsTWV0cmljU3RyaW5nID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNTdHJpbmcsIF9LYXRhbE1ldHJpY09iamVjdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgU3RyaW5nIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIFN0cmluZyB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNTdHJpbmcobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1N0cmluZyk7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nKS5jYWxsKHRoaXMsIG5hbWUpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcInRydW5jYXRlXCIsIGZhbHNlKTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzdHJpbmcgbWV0cmljLlxuICAgKlxuICAgKiBAcmV0dXJuIFZhbHVlIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLCBbe1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNTdHJpbmcucHJvdG90eXBlKSwgXCJ2YWxpZGF0aW9uRXJyb3JcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChzdXBlckVycm9yKSByZXR1cm4gc3VwZXJFcnJvcjtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgZmllbGQgdmFsdWUgaW4gU3RyaW5nIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIicgdG8gYmUgdHlwZSBzdHJpbmcsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGhpcy52YWx1ZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUpIHtcbiAgICAgICAgaWYgKHRoaXMudHJ1bmNhdGUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHJpbmcoMCwgS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBmaWVsZCB2YWx1ZSBpbiBTdHJpbmcgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJyB0byBiZSBcIikuY29uY2F0KEthdGFsTWV0cmljU3RyaW5nLk1BWF9TSVpFLCBcIiBjaGFyYWN0ZXJzIG9yIGxlc3MsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh0aGlzLnZhbHVlLmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIikpO1xuICAgICAgICB9XG4gICAgICB9IC8vIERpZG4ndCBmaW5kIGFueXRoaW5nIHdyb25nLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN0cmluZyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBUaGUgbmV3IHZhbHVlIHNob3VsZCBiZSBhIHN0cmluZywgYnV0IG51bWJlciBhbmQgYm9vbGVhbiB0eXBlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIHN0cmluZ3MuXG4gICAgICogRm9yIG90aGVyIHR5cGVzLCBpbmNsdWRpbmcgdW5kZWZpbmVkIGFuZCBudWxsLCB0aGUgdmFsdWUgd2lsbCBiZSBhY2NlcHRlZCwgYnV0IHdpbGwgZmFpbCB2YWxpZGF0aW9uIHdoZW4gcHVibGlzaGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0aW9uIGZsYWcgZm9yIHRoaXMgc3RyaW5nIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIElmIHNldCwgdGhlIHZhbHVlIGhlcmUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRydW5jYXRlZCB0byB0aGUgbWF4aW11bSBzaXplIGFsbG93ZWQgYnkgdGhlIGN1cnJlbnQgc2NoZW1hLlxuICAgICAqIE90aGVyd2lzZSwgc2VuZGluZyBhIHZhbHVlIGxhcmdlciB0aGFuIGFsbG93ZWQgd2lsbCByZXN1bHQgaW4gYSBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFRydWUgdG8gYXV0b21hdGljYWxseSB0cnVuY2F0ZSBtZXRyaWNzLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHR5cGUgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIlN0cmluZ1wiLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdC5UeXBlcy5TdHJpbmc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljU3RyaW5nO1xufShfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY1N0cmluZztcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLCBcIk1BWF9TSVpFXCIsIDI1Nik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3RcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2hcIikpO1xuXG52YXIgX0thdGFsTWV0cmljQ291bnRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNDb3VudGVyXCIpKTtcblxuLyoqXG4gKiBNZXRyaWMgdGhhdCBwYWlycyBhIHRpbWVyIGFuZCBhIGZhaWx1cmUgY291bnRlciB0byByZWNvcmQgdGhlIHRpbWUgYW5kIHN0YXR1cyBvZiBhbiBhdHRlbXB0IHRvIGRvIHNvbWV0aGluZy5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZWRBdHRlbXB0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNOYW1lZE9iamUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIF9LYXRhbE1ldHJpY05hbWVkT2JqZSk7XG5cbiAgLyoqIFRoZSBzdWItbWV0cmljIG5hbWUgZm9yIGxhdGVuY3kuICovXG5cbiAgLyoqIFRoZSBzdWItbWV0cmljIG5hbWUgZm9yIGZhaWx1cmUgY291bnQuICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lZCBhdHRlbXB0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogVGhpcyB3aWxsIGNyZWF0ZSB0d28gaW5uZXIgbWV0cmljcywgYSBLYXRhbE1ldHJpY0NvdW50ZXIgdGhhdCBoYXMgdGhlIGdpdmVuIG5hbWUgd2l0aCBcIi5GYWlsdXJlXCIgYXBwZW5kZWQsXG4gICAqIGFuZCBhIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggdGhhdCBoYXMgdGhlIGdpdmVuIG5hbWUgd2l0aCBcIi5MYXRlbmN5XCIgYXBwZW5kZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBhdHRlbXB0XG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdChuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCkuY2FsbCh0aGlzLCBuYW1lKSk7XG5cbiAgICBfdGhpcy5zZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5MQVRFTkNZX1NVRkZJWCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2guZGVmYXVsdChuYW1lKTtcbiAgICB9KTtcblxuICAgIF90aGlzLnNldE5hbWVkTWV0cmljKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LkZBSUxVUkVfU1VGRklYLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBfS2F0YWxNZXRyaWNDb3VudGVyLmRlZmF1bHQobmFtZSwgMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgZmFpbHVyZSBjb3VudGVyIG1ldHJpYyBiYXNlZCBvbiB0aGUgZ2l2ZW4gZmFpbHVyZSBzdGF0dXMuXG4gICAqXG4gICAqIElmIGZhaWx1cmUgaXMgdHJ1ZSB0aGUgY291bnRlciB3aWxsIGhhdmUgYSB2YWx1ZSBvZiAxOyBpZiBpdCBpcyBmYWxzZSB0aGUgY291bnRlciB3aWxsIGhhdmUgYSB2YWx1ZSBvZiAwLlxuICAgKlxuICAgKiBAcGFyYW0gZmFpbHVyZSBXaGV0aGVyIHRoaXMgaXMgYSBmYWlsdXJlIG9yIG5vdDsgZGVmYXVsdCB0cnVlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIFt7XG4gICAga2V5OiBcInNldEZhaWx1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmFpbHVyZSgpIHtcbiAgICAgIHZhciBmYWlsdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdmFyIGZhaWx1cmVDb3VudCA9IGZhaWx1cmUgPyAxIDogMDtcbiAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmZhaWx1cmVNZXRyaWM7XG4gICAgICBtZXRyaWMudmFsdWUgPSBmYWlsdXJlQ291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmFpbHVyZSBzdGF0dXMgdG8gZmFsc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdWNjZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN1Y2Nlc3MoKSB7XG4gICAgICB0aGlzLnNldEZhaWx1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhdGVuY3kgbWV0cmljIHRvIHRoZSBnaXZlbiB2YWx1ZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogTm90ZSB5b3UgZG9uJ3Qgbm9ybWFsbHkgaGF2ZSB0byBzZXQgdGhpcywgdGhlIHVuZGVybHlpbmcgbWV0cmljIGlzIGEgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCB0aGF0IHdpbGwgc3RhcnRcbiAgICAgKiBhbmQgc3RvcCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGVuY3lNcyBMYXRlbmN5IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGF0ZW5jeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMYXRlbmN5KGxhdGVuY3lNcykge1xuICAgICAgdmFyIG1ldHJpYyA9IHRoaXMubGF0ZW5jeU1ldHJpYztcbiAgICAgIG1ldHJpYy52YWx1ZSA9IGxhdGVuY3lNcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aW1lciBzdG9wd2F0Y2ggbWV0cmljIGZvciB0aGlzIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRpbWVyIHN0b3B3YXRjaCBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGF0ZW5jeU1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuTEFURU5DWV9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZhaWx1cmUgY291bnRlciBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gRmFpbHVyZSBjb3VudGVyIG1ldHJpYyBmb3IgdGhpcyBldmVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFpbHVyZU1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuRkFJTFVSRV9TVUZGSVgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQ7XG59KF9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQ7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgXCJMQVRFTkNZX1NVRkZJWFwiLCAnTGF0ZW5jeScpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIFwiRkFJTFVSRV9TVUZGSVhcIiwgJ0ZhaWx1cmUnKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfVmFsaWRhdGVTaW1wbGVJbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnRcIikpO1xuXG4vKipcbiAqIFRpbWVyIHR5cGUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gcmVjb3JkIGEgdGltZS4gIFRoaXMgY2xhc3MgcmVxdWlyZXMgZXhwbGljaXQgdmFsdWU7IHNlZSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoIGZvciBhdXRvbWF0aWNcbiAqIHRpbWluZy5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdGltZXIgbWV0cmljLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGUgbWV0cmljXG4gICAqIEBwYXJhbSB2YWx1ZSBUaW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljVGltZXIobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1RpbWVyKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lcikuY2FsbCh0aGlzLCBuYW1lKSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgdGltZXJcbiAgICpcbiAgICogQHJldHVybiBUaW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBbe1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lci5wcm90b3R5cGUpLCBcInZhbGlkYXRpb25FcnJvclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN1cGVyRXJyb3IpIHJldHVybiBzdXBlckVycm9yO1xuICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVJbnQuZGVmYXVsdCkodGhpcy52YWx1ZSwgXCJmaWVsZCB2YWx1ZSBpbiBUaW1lciBtZXRyaWNzIG9iamVjdCAnXCIuY29uY2F0KHRoaXMubmFtZSwgXCInXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyB0aW1lclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB0aW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBNYXRoLnJvdW5kIHdpbGwgYWxzbyBjb2VyY2UgZnJvbSBhIHN0cmluZyBpZiBuZWNlc3NhcnksIGFuZCByZXR1cm4gTmFOIGlmIGludmFsaWRcblxuXG4gICAgICB0aGlzLl92YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgZm9yIHRoaXMgdGltZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIFwiVGltZXJcIi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuVGltZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lcjtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX3NldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lclwiKSk7XG5cbi8qKlxuICogU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNUaW1lciB0aGF0IGNhbiBiZSBzdGFydGVkIGFuZCBzdG9wcGVkLCBhbmQgd2lsbCByZWNvcmQgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHN0YXJ0aW5nIGFuZFxuICogc3RvcHBpbmcuICBCeSBkZWZhdWx0IGl0IHdpbGwgc3RhcnQgd2hlbiB0aGUgb2JqZWN0IGlzIGNyZWF0ZWQsIGFuZCBzdG9wcGVkIHdoZW4gdGhlIHZhbHVlIGlzIHJldHJpZXZlZCB3aXRoXG4gKiB0aGUgZ2V0dGVyIFwidmFsdWVcIi5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY1RpbWVyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gsIF9LYXRhbE1ldHJpY1RpbWVyKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHN0YXJ0aW5nIHRpbWUuICBJZiBubyBzdGFydGluZyB0aW1lIGlzIGdpdmVuLCB0aGUgY3VycmVudCB0aW1lIGlzIHVzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgdGltZXJcbiAgICogQHBhcmFtIHN0YXJ0VGltZSBNaWxsaXNlY29uZCBlcG9jaCB0aW1lIGZvciB0aGUgc3RhcnQgdGltZTsgZGVmYXVsdHMgdG8gbm93XG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKG5hbWUsIHN0YXJ0VGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKS5jYWxsKHRoaXMsIG5hbWUsIHVuZGVmaW5lZCkpO1xuXG4gICAgX3RoaXMuc3RhcnQoc3RhcnRUaW1lKTtcblxuICAgIF90aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlLXN0YXJ0IHRpbWVyIHdpdGggdGhlIGdpdmVuIHN0YXJ0IHRpbWUsIG9yIHRoZSBjdXJyZW50IHRpbWUgaWYgbm9uZSBpcyBnaXZlbi5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0VGltZSBXaGVuIHRoZSB0aW1lciB3YXMgc3RhcnRlZCwgaW4gZXBvY2ggbWlsbGlzZWNvbmRzOyBkZWZhdWx0cyB0byBub3dcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydChzdGFydFRpbWUpIHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHN0YXJ0VGltZSB8fCB0aGlzLm5vdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB0aW1lciBhbmQgcmVjb3JkIHRoZSBlbGFwc2VkIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcFRpbWUgV2hlbiB0aGUgdGltZXIgd2FzIHN0b3BwZWQsIGluIGVwb2NoIG1pbGxpc2Vjb25kczsgZGVmYXVsdHMgdG8gbm93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3Aoc3RvcFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSA9IHN0b3BUaW1lIHx8IHRoaXMubm93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0aW1lciBoYXMgYmVlbiBzdG9wcGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdGltZXIgaGFzIGJlZW4gc3RvcHBlZCB5ZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5vd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RvcHBlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1lICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZWxhcHNlZCB0aW1lIGJldHdlZW4gd2hlbiB0aGUgdGltZXIgd2FzIHN0YXJ0ZWQgYW5kIHN0b3BwZWQ7IGlmIHRoZSB0aW1lciBoYXMgbm90IHlldCBiZWVuIHN0b3BwZWQsXG4gICAgICogc3RvcCBpdCBmaXJzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVsYXBzZWQgdGltZSBiZXR3ZWVuIHdoZW4gdGltZXIgd2FzIHN0YXJ0ZWQgYW5kIHN0b3BwZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB0aGlzKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfSAvLyBSZWx5IG9uIHN1cGVyLnZhbHVlIHNldHRlciB0byByb3VuZFxuXG5cbiAgICAgICAgKDAsIF9zZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB0aGlzLnN0b3BUaW1lIC0gdGhpcy5zdGFydFRpbWUsIHRoaXMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdoZW4gdGhpcyB0aW1lciB3YXMgc3RhcnRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gU3RhcnQgdGltZSwgaW4gZXBvY2ggbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBtZXRyaWMuICBOb3RlIHRoaXMgd2lsbCBvdmVycmlkZSB0aGUgc3RvcHdhdGNoIGJlaGF2aW9yIGFuZCBqdXN0IHVzZSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICgwLCBfc2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdmFsdWUsIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFRpbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3aGVuIHRoaXMgdGltZXIgd2FzIHN0b3BwZWQgKG9yIHVuZGVmaW5lZCBpZiBpdCBpcyBzdGlsbCBydW5uaW5nKVxuICAgICAqXG4gICAgICogQHJldHVybiBTdG9wIHRpbWUsIGluIGVwb2NoIG1pbGxzZWNvbmRzLCBvciB1bmRlZmluZWQgaWYgdGhlIHN0b3B3YXRjaCBpcyBzdGlsbCBydW5uaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wVGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1lO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaDtcbn0oX0thdGFsTWV0cmljVGltZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKipcbiAqIE1ldHJpYyB0eXBlcy5cbiAqL1xudmFyIEthdGFsTWV0cmljVHlwZTtcblxuKGZ1bmN0aW9uIChLYXRhbE1ldHJpY1R5cGUpIHtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiU3RyaW5nXCJdID0gXCJTdHJpbmdcIjtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiQ291bnRlclwiXSA9IFwiQ291bnRlclwiO1xuICBLYXRhbE1ldHJpY1R5cGVbXCJUaW1lclwiXSA9IFwiVGltZXJcIjtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiTGlzdFwiXSA9IFwiTGlzdFwiO1xufSkoS2F0YWxNZXRyaWNUeXBlIHx8IChLYXRhbE1ldHJpY1R5cGUgPSB7fSkpO1xuXG47XG52YXIgX2RlZmF1bHQgPSBLYXRhbE1ldHJpY1R5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvdW50ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljQ291bnRlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXJTdG9wd2F0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2guZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lZEF0dGVtcHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5pdGlhbGl6YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwUmVxdWVzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgX0thdGFsTWV0cmljU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1N0cmluZ1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNDb3VudGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY0NvdW50ZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2hcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvblwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNIdHRwUmVxdWVzdFwiKSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdHdvIElJRkVzIHRoYXQgdGhlIFN1c2hpIGxpYnJhcnkgY29udGFpbnMuIEEgZmFrZSBDU00gYW5kIFdpbmRvdyBvYmplY3QgYXJlIGNyZWF0ZWQgYW5kIHByb3ZpZGVkXG4gKiB0byB0aGUgZnVuY3Rpb25zIHNvIHRoYXQgdGhleSBhY3R1YWxseSBleGVjdXRlIGluIGEgY29udHJvbGxlZCBlbnZpcm9ubWVudCBhd2F5IGZyb20gYW55IENTTSBjb2RlIHRoYXQgbWlnaHQgYmUgZXhlY3V0aW5nXG4gKiBhdCB0aGUgcGxhdGZvcm0gbGV2ZWwgd2l0aGluIHRoZSBwYWdlLlxuICpcbiAqIFRoZSBiYXNpYyBydW4gb3JkZXIgaXMgdGhlIGZvbGxvd2luZzpcbiAqIDEuIEJ1aWxkIHRoZSBtb2NrIENTTSBvYmplY3QsIHRoZW4gYnVpbGQgYSBtb2NrIFdpbmRvdyBvYmplY3QgdGhhdCByZWZlcmVuY2VzIHRoZSBDU00gb2JqZWN0IGFzIHVlX2NzbVxuICogMi4gUnVuIHRoZSB0cmFuc3BvcnRhdGlvbi1jbGllbnRzLmpzIFNjcmlwdCBmcm9tIFN1c2hpSmF2YXNjcmlwdENsaWVudCBwcm92aWRpbmcgdGhlIG1vY2tzLiBJdCB3aWxsIG1vZGlmeSBnbG9iYWxzIG9uIHRoZSBtb2NrIG9iamVjdHMuXG4gKiAzLiBSdW4gdGhlIHN1c2hpLWNsaWVudC5qcyBzY3JpcHQgZnJvbSBTdXNoaUphdmFTY3JpcHRDbGllbnQgcHJvdmlkaW5nIHRoZSBtb2Nrcy4gSXQgd2lsbCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHN1c2hpIGNsaWVudCBhbmQgaW5qZWN0IGl0IGludG8gdGhlIENTTSBnbG9iYWxzIGluIHRoZSBtb2Nrcy5cbiAqIDQuIHdoZW5ldmVyIGV2ZW50KCkgaXMgY2FsbGVkLCByZWZlciB0byB0aGUgZW5jYXBzdWxhdGVkIGNzbSBvYmplY3QgdG8gYWRkIHRoZSBldmVudCB0byB0aGUgcXVldWUuXG4gKi9cbnZhciBTdXNoaUNsaWVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFN1c2hpQ2xpZW50LCBudWxsLCBbe1xuICAgIGtleTogXCJjcmVhdGVTdXNoaVVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdXNoaVVybChyZWdpb24sIHNvdXJjZUdyb3VwKSB7XG4gICAgICBpZiAoIXNvdXJjZUdyb3VwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1c2hpIERyaXZlciB3YXMgbm90IHByb3ZpZGVkIHdpdGggYSBzb3VyY2UgZ3JvdXAuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG9tYWluO1xuXG4gICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuTkE6XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1uYVwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3VzaGlDbGllbnQuUkVHSU9OUy5FVTpcbiAgICAgICAgICBkb21haW4gPSBcInVuYWdpLWV1XCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLkZFOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktZmVcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuQ046XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1jblwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHJlZ2lvbiAnXCIuY29uY2F0KHJlZ2lvbiwgXCInIHByb3ZpZGVkIHRvIFN1c2hpQ2xpZW50LlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcImh0dHBzOi8vXCIuY29uY2F0KGRvbWFpbiwgXCIuYW1hem9uLmNvbS8xL2V2ZW50cy9cIikuY29uY2F0KHNvdXJjZUdyb3VwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQ3NtVXNlckNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ3NtVXNlckNvbnRleHQoc3VzaGlVcmwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgaGlQcmlGbHVzaEludGVydmFsOiAxMDAwLFxuICAgICAgICBsb3dQcmlGbHVzaEludGVydmFsOiAxMDAwMCxcbiAgICAgICAgcmVxdWVzdElkOiBcIjFcIixcbiAgICAgICAgZXJyb3JDaGFubmVsOiBcImpzZXJyXCIsXG4gICAgICAgIHNlc3Npb25TdG9yYWdlV3JhcHBlcjogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvckhhbmRsZXJGdW5jdGlvbjogY29uc29sZS5sb2csXG4gICAgICAgIHN1c2hpVXJsOiBzdXNoaVVybFxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFN1c2hpIENsaWVudCBmb3IgYSByZWdpb24gYW5kIHNvdXJjZSBncm91cFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiBSZWdpb24gaW4gU3VzaGlDbGllbnQuUkVHSU9OU1xuICAgICAqIEBwYXJhbSBzb3VyY2VHcm91cCBTdXNoaSBFZWwgc291cmNlIGdyb3VwXG4gICAgICogQHBhcmFtIGVycm9ySGFuZGxlciBFcnJvciBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBDU00gY29udGV4dCBvdmVycmlkZXNcbiAgICAgKiBAcGFyYW0gY2xpZW50T3ZlcnJpZGUgQW4gb3B0aW9uYWwgdHJhbnNwb3J0YXRpb24gY2xpZW50IGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGNsaWVudHMgKG5hdmlnYXRvci5zZW5kQmVhY29uIGFuZCBYRG9tYWluUmVxdWVzdCBvciBYTUxIdHRwUmVxdWVzdClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlJFR0lPTlNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIE5BOiBcIk5BXCIsXG4gICAgICAgIEVVOiBcIkVVXCIsXG4gICAgICAgIEZFOiBcIkZFXCIsXG4gICAgICAgIENOOiBcIkNOXCJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gU3VzaGlDbGllbnQoKSB7XG4gICAgdmFyIHJlZ2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogU3VzaGlDbGllbnQuUkVHSU9OUy5OQTtcbiAgICB2YXIgc291cmNlR3JvdXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXJyb3JIYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIHZhciBjbGllbnRPdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFN1c2hpQ2xpZW50KTtcbiAgICB2YXIgc3VzaGlVcmwgPSBTdXNoaUNsaWVudC5jcmVhdGVTdXNoaVVybChyZWdpb24sIHNvdXJjZUdyb3VwKTtcbiAgICB2YXIgY3NtVXNlckNvbnRleHQgPSBTdXNoaUNsaWVudC5jcmVhdGVDc21Vc2VyQ29udGV4dChzdXNoaVVybCwgb3B0aW9ucyk7XG4gICAgdGhpcy51ZV9jc20gPSB0aGlzLnNldHVwTW9ja0NTTU9iamVjdChjc21Vc2VyQ29udGV4dCk7XG4gICAgdGhpcy5lbmNhcHN1bGF0ZWRXaW5kb3cgPSB0aGlzLnNldHVwTW9ja1dpbmRvdyh0aGlzLnVlX2NzbSk7XG4gICAgdGhpcy50cmFuc3BvcnRhdGlvbkNsaWVudENvZGUodGhpcy51ZV9jc20sIHdpbmRvdyk7XG5cbiAgICBpZiAoY2xpZW50T3ZlcnJpZGUpIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLl9zQmNuID0ge1xuICAgICAgICBpc1N1cHBvcnRlZDogdHJ1ZSxcbiAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChlbmRwb2ludCwgcGF5bG9hZCkge1xuICAgICAgICAgIGNsaWVudE92ZXJyaWRlKGVuZHBvaW50LCBwYXlsb2FkKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudENvZGUodGhpcy51ZV9jc20sIHRoaXMuZW5jYXBzdWxhdGVkV2luZG93KTtcbiAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFN1c2hpQ2xpZW50LCBbe1xuICAgIGtleTogXCJldmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmVudChkYXRhLCBwcm9kdWNlcklkLCBzY2hlbWFJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3VzaGlDbGllbnQgd3JhcHBlciBwdWJsaXNoaW5nIHRoZSBmb2xsb3dpbmc6XCIsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHByb2R1Y2VySWQ6IHByb2R1Y2VySWQsXG4gICAgICAgICAgc2NoZW1hSWQ6IHNjaGVtYUlkLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVlX2NzbS51ZS5ldmVudChkYXRhLCBwcm9kdWNlcklkLCBzY2hlbWFJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHlvdSBwbGFuIHRvIGVtaXQgMTAwMCBvciBtb3JlIGV2ZW50cyBwZXIgaW5zdGFudGlhdGVkIGNsaWVudCxcbiAgICAgKiBjYWxsIHJlc2V0IGFmdGVyIGNhbGxpbmcgZXZlbnQgdG8gYWxsb3cgdGhlIENTTSBjbGllbnQgdG8gY29udGludWUgc2VuZGluZyBldmVudHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLmV2ZW50LnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBqdXN0IGJlZm9yZSBlYWNoIHRpbWUgbWV0cmljcyBhcmVcbiAgICAgKiBmbHVzaGVkIHRvIHRoZSBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgc3VzaGkgd2lsbCBjYWxsIGJlZm9yZSBmbHVzaGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25TdXNoaUZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VzaGlGbHVzaChjYWxsYmFjaykge1xuICAgICAgdGhpcy51ZV9jc20udWUub25TdXNoaUZsdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWdlIHVubG9hZHMuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBzZW5kIGFueSBmaW5hbCBtZXRyaWNzIHRvIHN1c2hpLCBzdWNoIGFzIHBhZ2UgdmlzaXRcbiAgICAgKiBkdXJhdGlvbiBvciBiYXRjaGVkIGNvdW50ZXJzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgc3VzaGkgd2lsbCBjYWxsIGJlZm9yZSB1bmxvYWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblN1c2hpVW5sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VzaGlVbmxvYWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLm9uU3VzaGlVbmxvYWQoY2FsbGJhY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cE1vY2tDU01PYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBNb2NrQ1NNT2JqZWN0KGNzbVVzZXJDb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZXhlY1N0dWIgPSBmdW5jdGlvbiBleGVjU3R1YihjYWxsYmFjaywgYXR0cmlidXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgfTtcblxuICAgICAgdmFyIGV2ZW50U3R1YiA9IGZ1bmN0aW9uIGV2ZW50U3R1Yihsb2csIHByb2R1Y2VyLCBldmVudFR5cGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU3VzaGlDbGllbnQgQ1NNIHN0dWIgY2FsbGVkIGluIHVuc3VwcG9ydGVkIG1hbm5lcjogZXZlbnQoKVwiKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiBlcnJvckhhbmRsZXIobG9nRXZlbnQsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKF90aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgICAgIF90aGlzLmVycm9ySGFuZGxlcihsb2dFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBbiBlcnJvciBoYXMgb2NjdXJyZWQgaW4gU3VzaGlDbGllbnQgY2hhbm5lbCBcIiArIGNoYW5uZWwsIGxvZ0V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGF0dGFjaEhhbmRsZXIgPSBmdW5jdGlvbiBhdHRhY2hIYW5kbGVyKGV2dCwgaGFuZGxlciwgY29udGFpbmVyKSB7XG4gICAgICAgIC8vVE9ETyBtaWdodCBiZSBhYmxlIHRvIGp1c3QgdXNlIHdpbmRvdy51ZS5hdHRhY2g/XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCB3aW5kb3c7IC8vb2sgdG8gdXNlIHJlYWwgd2luZG93IGdsb2JhbCBoZXJlLlxuXG4gICAgICAgIGlmICh3aW5kb3cuRXZlbnRUYXJnZXQgJiYgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSAmJiB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIuY2FsbChjb250YWluZXIsIGV2dCwgaGFuZGxlciwgISF3aW5kb3cudWVfY2xmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgISF3aW5kb3cudWVfY2xmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICBjb250YWluZXIuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdWVfaHBzaTogY3NtVXNlckNvbnRleHQuaGlQcmlGbHVzaEludGVydmFsLFxuICAgICAgICB1ZV9scHNpOiBjc21Vc2VyQ29udGV4dC5sb3dQcmlGbHVzaEludGVydmFsLFxuICAgICAgICB1ZToge1xuICAgICAgICAgIHNzdzogY3NtVXNlckNvbnRleHQuc2Vzc2lvblN0b3JhZ2VXcmFwcGVyLFxuICAgICAgICAgIGxvZzogZXJyb3JIYW5kbGVyLFxuICAgICAgICAgIGV4ZWM6IGV4ZWNTdHViLFxuICAgICAgICAgIGV2ZW50OiBldmVudFN0dWIsXG4gICAgICAgICAgYXR0YWNoOiBhdHRhY2hIYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIHVlTG9nRXJyb3I6IGNzbVVzZXJDb250ZXh0LmVycm9ySGFuZGxlckZ1bmN0aW9uLFxuICAgICAgICB1ZV9zdXJsOiBjc21Vc2VyQ29udGV4dC5zdXNoaVVybCxcbiAgICAgICAgdWVfaWQ6IGNzbVVzZXJDb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgICAgdWVfZXJyX2NoYW46IGNzbVVzZXJDb250ZXh0LmVycm9yQ2hhbm5lbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBNb2NrV2luZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwTW9ja1dpbmRvdyh1ZV9jc20pIHtcbiAgICAgIC8vYXBwYXJlbnRseSBjYW5ub3QgcmVmIHRoZSBzZXRUaW1lb3V0IGZ1bmN0aW9uIGRpcmVjdGx5IGluIHNvbWUgYnJvd3NlcnMgc28gd2UgaGF2ZSB0byB3cmFwIGl0LlxuICAgICAgdmFyIHRpbWVvdXRXcmFwcGVyID0gZnVuY3Rpb24gdGltZW91dFdyYXBwZXIoZm4sIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lb3V0KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVlX2NzbTogdWVfY3NtLFxuICAgICAgICB1ZUxvZ0Vycm9yOiB1ZV9jc20udWVMb2dFcnJvcixcbiAgICAgICAgdWU6IHVlX2NzbS51ZSxcbiAgICAgICAgc2V0VGltZW91dDogdGltZW91dFdyYXBwZXJcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvZGUgd2l0aGluIGZ1bmN0aW9uIHB1bGxlZCBkaXJlY3RseSBmcm9tXG4gICAgICogaHR0cHM6Ly9jb2RlLmFtYXpvbi5jb20vcGFja2FnZXMvU3VzaGlKYXZhU2NyaXB0Q2xpZW50L2Jsb2JzL21haW5saW5lLy0tL2phdmFzY3JpcHQvc3VzaGktY2xpZW50LmpzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGllbnRDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWVudENvZGUodWVfY3NtLCB3aW5kb3cpIHtcbiAgICAgIHVlX2NzbS51ZS5leGVjKGZ1bmN0aW9uIChiLCBrKSB7XG4gICAgICAgIGZ1bmN0aW9uIEEoKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzW2FdO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgaDtcblxuICAgICAgICAgICAgICBpZiAoYy5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gdC5idWlsZFBheWxvYWQobCwgZSk7XG4gICAgICAgICAgICAgICAgaCA9IGMuc2VuZChKLCBiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHRocm93IGR1bW15RXhjZXB0aW9uO1xuXG4gICAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgICAgfSBjYXRjaCAoZCkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBCKHtcbiAgICAgICAgICAgIG06IFwiQWxsIHN1cHBvcnRlZCBjbGllbnRzIGZhaWxlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRpb246IFwiQ1NNU3VzaGlDbGllbnRfVFJBTlNQT1JUQVRJT05fRkFJTFwiLFxuICAgICAgICAgICAgZjogXCJzdXNoaS1jbGllbnQuanNcIixcbiAgICAgICAgICAgIGxvZ0xldmVsOiBcIkVSUk9SXCJcbiAgICAgICAgICB9LCBrLnVlX2Vycl9jaGFuIHx8IFwianNlcnJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgICAgIGlmIChlLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIG5bYV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQShkLl9zQmNuIHx8IHt9LCBkLl9hanggfHwge30pO1xuICAgICAgICAgICAgZSA9IFtdO1xuICAgICAgICAgICAgZiA9IHt9O1xuICAgICAgICAgICAgbCA9IHt9O1xuICAgICAgICAgICAgdSA9IHYgPSBxID0gdyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSygpIHtcbiAgICAgICAgICB2YXIgYSA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIGMgPSBmdW5jdGlvbiBjKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAxMCA+IGEgPyBcIjBcIiArIGEgOiBhO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPyBhLnRvSVNPU3RyaW5nKCkgOiBhLmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArIGMoYS5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArIGMoYS5nZXRVVENEYXRlKCkpICsgXCJUXCIgKyBjKGEuZ2V0VVRDSG91cnMoKSkgKyBcIjpcIiArIGMoYS5nZXRVVENNaW51dGVzKCkpICsgXCI6XCIgKyBjKGEuZ2V0VVRDU2Vjb25kcygpKSArIFwiLlwiICsgU3RyaW5nKChhLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMUUzKS50b0ZpeGVkKDMpKS5zbGljZSgyLCA1KSArIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24geChhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgICAgICB9IGNhdGNoIChjKSB7fVxuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBDKGEsIGMsIGgsIGcpIHtcbiAgICAgICAgICB2YXIgcCA9ICExO1xuICAgICAgICAgIGcgPSBnIHx8IHt9O1xuICAgICAgICAgIHIrKztcbiAgICAgICAgICByID09IEQgJiYgQih7XG4gICAgICAgICAgICBtOiBcIk1heCBudW1iZXIgb2YgU3VzaGkgTG9ncyBleGNlZWRlZFwiLFxuICAgICAgICAgICAgZjogXCJzdXNoaS1jbGllbnQuanNcIixcbiAgICAgICAgICAgIGxvZ0xldmVsOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjogXCJDU01TdXNoaUNsaWVudF9NQVhfQ0FMTFNcIlxuICAgICAgICAgIH0sIGsudWVfZXJyX2NoYW4gfHwgXCJqc2VyclwiKTtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICBpZiAoZiA9ICEociA+PSBEKSkgKGYgPSBhICYmIC0xIDwgYS5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoXCJPYmplY3RcIikgJiYgYyAmJiAtMSA8IGMuY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKFwiU3RyaW5nXCIpICYmIGggJiYgLTEgPCBoLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZihcIlN0cmluZ1wiKSkgfHwgTCsrO1xuICAgICAgICAgIGYgJiYgKGQuY291bnQgJiYgZC5jb3VudChcIkV2ZW50OlwiICsgaCwgMSksIGEucHJvZHVjZXJJZCA9IGEucHJvZHVjZXJJZCB8fCBjLCBhLnNjaGVtYUlkID0gYS5zY2hlbWFJZCB8fCBoLCBhLnRpbWVzdGFtcCA9IEsoKSwgYyA9IERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICtuZXcgRGF0ZSgpLCBoID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cmluZygyLCAxMiksIGEubWVzc2FnZUlkID0gYi51ZV9pZCArIFwiLVwiICsgYyArIFwiLVwiICsgaCwgZyAmJiAhZy5zc2QgJiYgKGEuc2Vzc2lvbklkID0gYS5zZXNzaW9uSWQgfHwgYi51ZV9zaWQsIGEucmVxdWVzdElkID0gYS5yZXF1ZXN0SWQgfHwgYi51ZV9pZCwgYS5vYmZ1c2NhdGVkTWFya2V0cGxhY2VJZCA9IGEub2JmdXNjYXRlZE1hcmtldHBsYWNlSWQgfHwgYi51ZV9taWQpLCAoYyA9IHgoYSkpID8gKGMgPSBjLmxlbmd0aCwgKGUubGVuZ3RoID09IE0gfHwgcSArIGMgPiBOKSAmJiBtKCksIHEgKz0gYywgYSA9IHtcbiAgICAgICAgICAgIGRhdGE6IHQuY29tcHJlc3NFdmVudChhKVxuICAgICAgICAgIH0sIGUucHVzaChhKSwgKGcgfHwge30pLm4gPyAwID09PSBFID8gbSgpIDogdSB8fCAodSA9IGsuc2V0VGltZW91dChtLCBFKSkgOiB2IHx8ICh2ID0gay5zZXRUaW1lb3V0KG0sIE8pKSwgcCA9ICEwKSA6IHAgPSAhMSk7XG4gICAgICAgICAgIXAgJiYgYi51ZV9pbnQgJiYgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlMgTmV4dXMgQVBJIGNhbGxcIik7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBGKCkge1xuICAgICAgICAgIGlmICghRykge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB5Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIHlbYV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IG4ubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgblthXSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLmxlbmd0aCAmJiAoYi51ZV9zYnVpbXAgJiYgYi51ZSAmJiBiLnVlLnNzdyAmJiAoYSA9IHgoe1xuICAgICAgICAgICAgICBkY3Q6IGwsXG4gICAgICAgICAgICAgIGV2dDogZVxuICAgICAgICAgICAgfSksIGIudWUuc3N3KFwiZWVsZGF0YVwiLCBhKSwgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJ1bmtcIikpLCBBKGQuX3NCY24gfHwge30pKTtcbiAgICAgICAgICAgIEcgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBIKGEpIHtcbiAgICAgICAgICB5LnB1c2goYSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBJKGEpIHtcbiAgICAgICAgICBuLnB1c2goYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgRCA9IDFFMyxcbiAgICAgICAgICAgIE0gPSA0OTksXG4gICAgICAgICAgICBOID0gNTI0Mjg4LFxuICAgICAgICAgICAgcyA9IGZ1bmN0aW9uIHMoKSB7fSxcbiAgICAgICAgICAgIGQgPSBiLnVlIHx8IHt9LFxuICAgICAgICAgICAgQiA9IGQubG9nIHx8IHMsXG4gICAgICAgICAgICBQID0gYi51ZXggfHwgcztcblxuICAgICAgICAoYi51ZXQgfHwgcykoXCJiYlwiLCBcInVlX3N1c2hpX3YxXCIsIHtcbiAgICAgICAgICB3YjogMVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgSiA9IGIudWVfc3VybCB8fCBcImh0dHBzOi8vdW5hZ2ktbmEuYW1hem9uLmNvbS8xL2V2ZW50cy9jb20uYW1hem9uLmNzbS5uZXh1c2NsaWVudC5nYW1tYVwiLFxuICAgICAgICAgICAgUSA9IFtcIm1lc3NhZ2VJZFwiLCBcInRpbWVzdGFtcFwiXSxcbiAgICAgICAgICAgIHogPSBcIiNcIixcbiAgICAgICAgICAgIGUgPSBbXSxcbiAgICAgICAgICAgIGYgPSB7fSxcbiAgICAgICAgICAgIGwgPSB7fSxcbiAgICAgICAgICAgIHEgPSAwLFxuICAgICAgICAgICAgdyA9IDAsXG4gICAgICAgICAgICBMID0gMCxcbiAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgeSA9IFtdLFxuICAgICAgICAgICAgbiA9IFtdLFxuICAgICAgICAgICAgRyA9ICExLFxuICAgICAgICAgICAgdSxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICBFID0gdm9pZCAwID09PSBiLnVlX2hwc2kgPyAxRTMgOiBiLnVlX2hwc2ksXG4gICAgICAgICAgICBPID0gdm9pZCAwID09PSBiLnVlX2xwc2kgPyAxRTQgOiBiLnVlX2xwc2ksXG4gICAgICAgICAgICB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGEoYSkge1xuICAgICAgICAgICAgZlthXSA9IHogKyB3Kys7XG4gICAgICAgICAgICBsW2ZbYV1dID0gYTtcbiAgICAgICAgICAgIHJldHVybiBmW2FdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGMoYikge1xuICAgICAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZyA9IFtdLCBkID0gYi5sZW5ndGgsIGUgPSAwOyBlIDwgZDsgZSsrKSB7XG4gICAgICAgICAgICAgICAgICBnW2VdID0gYyhiW2VdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChiIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yIChkIGluIGIpIHtcbiAgICAgICAgICAgICAgICAgIGIuaGFzT3duUHJvcGVydHkoZCkgJiYgKGdbZltkXSA/IGZbZF0gOiBhKGQpXSA9IC0xID09PSBRLmluZGV4T2YoZCkgPyBjKGJbZF0pIDogYltkXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGIgJiYgKGIubGVuZ3RoID4gKHogKyB3KS5sZW5ndGggfHwgYi5jaGFyQXQoMCkgPT09IHopID8gZltiXSA/IGZbYl0gOiBhKGIpIDogYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcHJlc3NFdmVudDogYyxcbiAgICAgICAgICAgIGJ1aWxkUGF5bG9hZDogZnVuY3Rpb24gYnVpbGRQYXlsb2FkKCkge1xuICAgICAgICAgICAgICByZXR1cm4geCh7XG4gICAgICAgICAgICAgICAgY3M6IHtcbiAgICAgICAgICAgICAgICAgIGRjdDogbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXZlbnRzOiBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcblxuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkLmV2ZW50ICYmIGQuZXZlbnQuaXNTdHViKSB7XG4gICAgICAgICAgICBpZiAoYi51ZV9zYnVpbXAgJiYgYi51ZSAmJiBiLnVlLnNzdykge1xuICAgICAgICAgICAgICB2YXIgYSA9IGIudWUuc3N3KFwiZWVsc3RzXCIpLnZhbDtcblxuICAgICAgICAgICAgICBpZiAoYSAmJiBcInVua1wiID09PSBhICYmIChhID0gYi51ZS5zc3coXCJlZWxkYXRhXCIpLnZhbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYztcblxuICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBKU09OLnBhcnNlKGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZikge31cblxuICAgICAgICAgICAgICAgICAgYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYyAmJiBjLmV2dCBpbnN0YW5jZW9mIEFycmF5ICYmIGMuZGN0IGluc3RhbmNlb2YgT2JqZWN0ICYmIChlID0gYy5ldnQsIGwgPSBjLmRjdCwgZSAmJiBsICYmIChtKCksIGIudWUuc3N3KFwiZWVsZGF0YVwiLCBcInt9XCIpLCBiLnVlLnNzdyhcImVlbHN0c1wiLCBcInNjc1wiKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGQuZXZlbnQucmVwbGF5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIGFbM10gPSBhWzNdIHx8IHt9O1xuICAgICAgICAgICAgICBhWzNdLm4gPSAxO1xuICAgICAgICAgICAgICBDLmFwcGx5KHRoaXMsIGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLm9uU3VzaGlVbmxvYWQucmVwbGF5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIEgoYVswXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQub25TdXNoaUZsdXNoLnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBJKGFbMF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGQuYXR0YWNoKFwiYmVmb3JldW5sb2FkXCIsIEYpO1xuICAgICAgICBkLmF0dGFjaChcInBhZ2VoaWRlXCIsIEYpO1xuICAgICAgICBkLl9jbXBzID0gdDtcbiAgICAgICAgZC5ldmVudCA9IEM7XG5cbiAgICAgICAgZC5ldmVudC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByID0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBkLm9uU3VzaGlVbmxvYWQgPSBIO1xuICAgICAgICBkLm9uU3VzaGlGbHVzaCA9IEk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBrLlAgJiYgay5QLnJlZ2lzdGVyICYmIGsuUC5yZWdpc3RlcihcInN1c2hpLWNsaWVudFwiLCBzKTtcbiAgICAgICAgfSBjYXRjaCAoUikge1xuICAgICAgICAgIGIudWVMb2dFcnJvcihSLCB7XG4gICAgICAgICAgICBsb2dMZXZlbDogXCJXQVJOXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFAoXCJsZFwiLCBcInVlX3N1c2hpX3YxXCIsIHtcbiAgICAgICAgICB3YjogMVxuICAgICAgICB9KTtcbiAgICAgIH0sIFwiTnhzLUpTLUNsaWVudFwiKSh1ZV9jc20sIHdpbmRvdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb2RlIGluIHRoaXMgZnVuY3Rpb24gaXMgcHVsbGVkIGRpcmVjdGx5IGZyb206XG4gICAgICogaHR0cHM6Ly9jb2RlLmFtYXpvbi5jb20vcGFja2FnZXMvU3VzaGlKYXZhU2NyaXB0Q2xpZW50L2Jsb2JzL21haW5saW5lLy0tL2phdmFzY3JpcHQvdHJhbnNwb3J0YXRpb24tY2xpZW50cy5qc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNwb3J0YXRpb25DbGllbnRDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zcG9ydGF0aW9uQ2xpZW50Q29kZSh1ZV9jc20sIHdpbmRvdykge1xuICAgICAgdWVfY3NtLnVlLmV4ZWMoZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgdmFyIGUgPSBmdW5jdGlvbiBlKCkge30sXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGIsIGQpIHtcbiAgICAgICAgICAgICAgaWYgKGQgJiYgYikge1xuICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgIGlmIChjLlhEb21haW5SZXF1ZXN0KSBhID0gbmV3IFhEb21haW5SZXF1ZXN0KCksIGEub25lcnJvciA9IGUsIGEub250aW1lb3V0ID0gZSwgYS5vbnByb2dyZXNzID0gZSwgYS5vbmxvYWQgPSBlLCBhLnRpbWVvdXQgPSAwO2Vsc2UgaWYgKGMuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiBhKSkgdGhyb3cgXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgYSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoIWEpIHRocm93IFwiXCI7XG4gICAgICAgICAgICAgICAgYS5vcGVuKFwiUE9TVFwiLCBiLCAhMCk7XG4gICAgICAgICAgICAgICAgYS5zZXRSZXF1ZXN0SGVhZGVyICYmIGEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgYS5zZW5kKGQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQ6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpLFxuICAgICAgICAgICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChjLCBkKSB7XG4gICAgICAgICAgICAgIGlmIChjICYmIGQpIGlmIChuYXZpZ2F0b3Iuc2VuZEJlYWNvbihjLCBkKSkgYi51ZV9zYnVpbXAgJiYgYi51ZSAmJiBiLnVlLnNzdyAmJiBiLnVlLnNzdyhcImVlbHN0c1wiLCBcInNjc1wiKTtlbHNlIHRocm93IFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQ6ICEhbmF2aWdhdG9yLnNlbmRCZWFjb24gJiYgIShjLmNvcmRvdmEgJiYgYy5jb3Jkb3ZhLnBsYXRmb3JtSWQgJiYgXCJpb3NcIiA9PSBjLmNvcmRvdmEucGxhdGZvcm1JZClcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgYi51ZS5fYWp4ID0gZjtcbiAgICAgICAgYi51ZS5fc0JjbiA9IGc7XG4gICAgICB9LCBcIlRyYW5zcG9ydGF0aW9uLWNsaWVudHNcIikodWVfY3NtLCB3aW5kb3cpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3VzaGlDbGllbnQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN1c2hpQ2xpZW50OyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7XG4gICAgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wO1xuICB9KShub2RlSW50ZXJvcCk7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHtcbiAgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi9kZWZpbmVQcm9wZXJ0eS5qc1wiKTtcblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBPYmplY3QoYXJndW1lbnRzW2ldKSA6IHt9O1xuICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cy5wdXNoLmFwcGx5KG93bktleXMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFNwcmVhZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vZGVmaW5lUHJvcGVydHkuanNcIik7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgc2V0ID0gUmVmbGVjdC5zZXQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgdmFyIGRlc2M7XG5cbiAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xufVxuXG5mdW5jdGlvbiBfc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciwgaXNTdHJpY3QpIHtcbiAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2V0IHByb3BlcnR5Jyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZC5qc1wiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ2Vycm9yLXN0YWNrLXBhcnNlcicsIFsnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LkVycm9yU3RhY2tQYXJzZXIgPSBmYWN0b3J5KHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyKFN0YWNrRnJhbWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQID0gLyhefEApXFxTKzpcXGQrLztcbiAgICB2YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG4gICAgdmFyIFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCBleHRyYWN0IHRoZSBtb3N0IGluZm9ybWF0aW9uIGZyb20gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2YgU3RhY2tGcmFtZXNcbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZShlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5zdGFja3RyYWNlICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXJyb3JbJ29wZXJhI3NvdXJjZWxvYyddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTZXBhcmF0ZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBmcm9tIGEgc3RyaW5nIG9mIHRoZSBmb3JtOiAoVVJJOkxpbmU6Q29sdW1uKVxuICAgICAgICBleHRyYWN0TG9jYXRpb246IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJGV4dHJhY3RMb2NhdGlvbih1cmxMaWtlKSB7XG4gICAgICAgICAgICAvLyBGYWlsLWZhc3QgYnV0IHJldHVybiBsb2NhdGlvbnMgbGlrZSBcIihuYXRpdmUpXCJcbiAgICAgICAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VybExpa2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVnRXhwID0gLyguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC87XG4gICAgICAgICAgICB2YXIgcGFydHMgPSByZWdFeHAuZXhlYyh1cmxMaWtlLnJlcGxhY2UoL1soKV0vZywgJycpKTtcbiAgICAgICAgICAgIHJldHVybiBbcGFydHNbMV0sIHBhcnRzWzJdIHx8IHVuZGVmaW5lZCwgcGFydHNbM10gfHwgdW5kZWZpbmVkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZVY4T3JJRTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VWOE9ySUUoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignKGV2YWwgJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLCAnZXZhbCcpLnJlcGxhY2UoLyhcXChldmFsIGF0IFteKCldKil8KFxcKSwuKiQpL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZExpbmUgPSBsaW5lLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xcKGV2YWwgY29kZS9nLCAnKCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSBhbmQgcHJlc2V2ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBcIigvZm9vL215IGJhci5qczoxMjo4NylcIiBpblxuICAgICAgICAgICAgICAgIC8vIGNhc2UgaXQgaGFzIHNwYWNlcyBpbiBpdCwgYXMgdGhlIHN0cmluZyBpcyBzcGxpdCBvbiBcXHMrIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2FuaXRpemVkTGluZS5tYXRjaCgvIChcXCgoLispOihcXGQrKTooXFxkKylcXCkkKS8pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIGZyb20gdGhlIGxpbmUsIGlmIGl0IHdhcyBtYXRjaGVkXG4gICAgICAgICAgICAgICAgc2FuaXRpemVkTGluZSA9IGxvY2F0aW9uID8gc2FuaXRpemVkTGluZS5yZXBsYWNlKGxvY2F0aW9uWzBdLCAnJykgOiBzYW5pdGl6ZWRMaW5lO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHNhbml0aXplZExpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGxvY2F0aW9uIHdhcyBtYXRjaGVkLCBwYXNzIGl0IHRvIGV4dHJhY3RMb2NhdGlvbigpIG90aGVyd2lzZSBwb3AgdGhlIGxhc3QgdG9rZW5cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxvY2F0aW9uID8gbG9jYXRpb25bMV0gOiB0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbnMuam9pbignICcpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBbJ2V2YWwnLCAnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWxpbmUubWF0Y2goU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsOlxcZCs6XFxkKy9nLCAnOiQxJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignQCcpID09PSAtMSAmJiBsaW5lLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZVJlZ2V4ID0gLygoLipcIi4rXCJbXkBdKik/W15AXSopKD86QCkvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goZnVuY3Rpb25OYW1lUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsaW5lLnJlcGxhY2UoZnVuY3Rpb25OYW1lUmVnZXgsICcnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEoZSkge1xuICAgICAgICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgKGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbWF0Y2hbM10gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuICAgICAgICBwYXJzZU9wZXJhMTE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbkNhbGwgPSAodG9rZW5zLnNoaWZ0KCkgfHwgJycpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkNhbGxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCAnJDInKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgYXJnc1JhdztcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm1hdGNoKC9cXCgoW14pXSopXFwpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1JhdyA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC9eW14oXStcXCgoW14pXSopXFwpJC8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IChhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nKSA/XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IGFyZ3NSYXcuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiIsIi8qKlxuICogQHRoaXMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIGZpbmFsbHlDb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmFsbHlDb25zdHJ1Y3RvcjtcbiIsImltcG9ydCBwcm9taXNlRmluYWxseSBmcm9tICcuL2ZpbmFsbHknO1xuXG4vLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG52YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBpc0FycmF5KHgpIHtcbiAgcmV0dXJuIEJvb2xlYW4oeCAmJiB0eXBlb2YgeC5sZW5ndGggIT09ICd1bmRlZmluZWQnKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9ICovXG4gIHRoaXMuX3N0YXRlID0gMDtcbiAgLyoqIEB0eXBlIHshYm9vbGVhbn0gKi9cbiAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAvKiogQHR5cGUge1Byb21pc2V8dW5kZWZpbmVkfSAqL1xuICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgLyoqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn0gKi9cbiAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgfVxuICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICB0cnkge1xuICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICBpZiAoXG4gICAgICBuZXdWYWx1ZSAmJlxuICAgICAgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChzZWxmLCBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fc3RhdGUgPSAyO1xuICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICB9XG4gIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmbihcbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfVxuICAgICk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3Qoc2VsZiwgZXgpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gcHJvbWlzZUZpbmFsbHk7XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdQcm9taXNlLmFsbCBhY2NlcHRzIGFuIGFycmF5JykpO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdQcm9taXNlLnJhY2UgYWNjZXB0cyBhbiBhcnJheScpKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoYXJyW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuUHJvbWlzZS5faW1tZWRpYXRlRm4gPVxuICAvLyBAdHMtaWdub3JlXG4gICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgZnVuY3Rpb24oZm4pIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfSkgfHxcbiAgZnVuY3Rpb24oZm4pIHtcbiAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gIH07XG5cblByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ1Bvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjonLCBlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbWlzZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbi8qKlxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgbnVtYmVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICogZmFpbHVyZS5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICB9XG5cbiAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDYyOiArXG4gIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgcmV0dXJuIDYyO1xuICB9XG5cbiAgLy8gNjM6IC9cbiAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgcmV0dXJuIDYzO1xuICB9XG5cbiAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gIHJldHVybiAtMTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG5mdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gIH07XG5cblNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cblNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICpcbiAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSBhT3JkZXJcbiAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgdmFyIG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH07XG4gICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKG5lZWRsZS5zb3VyY2UpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobmVlZGxlLnNvdXJjZSk7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICByZXR1cm4gc21jO1xuICB9O1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICB9LCB0aGlzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nKCkge1xuICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgdmFyIHRlbXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4gICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBvcmlnaW5hbE1hcHBpbmdzO1xuICB9O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICogaW5jbHVzaXZlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gKlxuICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICogICAgICAgZmllbGQuXG4gKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICogdW5zdXBwb3J0ZWQuXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gKlxuICogIHtcbiAqICAgIHZlcnNpb24gOiAzLFxuICogICAgZmlsZTogXCJhcHAuanNcIixcbiAqICAgIHNlY3Rpb25zOiBbe1xuICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAqICAgICAgbWFwOiB7XG4gKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAqICAgICAgfVxuICogICAgfV0sXG4gKiAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgIGxpbmU6IC0xLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgIGlmIChzLnVybCkge1xuICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICB9LFxuICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgfVxuICB9KTtcbn1cblxuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZXMuaW5kZXhPZih1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICB9O1xuXG5leHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCAhIWFQYXRoLm1hdGNoKHVybFJlZ2V4cCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFjay1nZW5lcmF0b3InLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3N0YWNrZnJhbWUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja0dlbmVyYXRvciA9IGZhY3Rvcnkocm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKFN0YWNrRnJhbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrdHJhY2U6IGZ1bmN0aW9uIFN0YWNrR2VuZXJhdG9yJCRiYWNrdHJhY2Uob3B0cykge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgICAgICB2YXIgbWF4U3RhY2tTaXplID0gMTA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdHMubWF4U3RhY2tTaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG1heFN0YWNrU2l6ZSA9IG9wdHMubWF4U3RhY2tTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VyciA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICAgICAgICB3aGlsZSAoY3VyciAmJiBzdGFjay5sZW5ndGggPCBtYXhTdGFja1NpemUgJiYgY3VyclsnYXJndW1lbnRzJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBWOCBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoY3VyclsnYXJndW1lbnRzJ10ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGN1cnJbJ2FyZ3VtZW50cyddW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL2Z1bmN0aW9uKD86XFxzKyhbXFx3JF0rKSkrXFxzKlxcKC8udGVzdChjdXJyLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrRnJhbWUoe2Z1bmN0aW9uTmFtZTogUmVnRXhwLiQxIHx8IHVuZGVmaW5lZCwgYXJnczogYXJnc30pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0ZyYW1lKHthcmdzOiBhcmdzfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLmNhbGxlcjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFja2ZyYW1lJywgW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tGcmFtZSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0dGVyKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICAgIHZhciBudW1lcmljUHJvcHMgPSBbJ2NvbHVtbk51bWJlcicsICdsaW5lTnVtYmVyJ107XG4gICAgdmFyIHN0cmluZ1Byb3BzID0gWydmaWxlTmFtZScsICdmdW5jdGlvbk5hbWUnLCAnc291cmNlJ107XG4gICAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcbiAgICB2YXIgb2JqZWN0UHJvcHMgPSBbJ2V2YWxPcmlnaW4nXTtcblxuICAgIHZhciBwcm9wcyA9IGJvb2xlYW5Qcm9wcy5jb25jYXQobnVtZXJpY1Byb3BzLCBzdHJpbmdQcm9wcywgYXJyYXlQcm9wcywgb2JqZWN0UHJvcHMpO1xuXG4gICAgZnVuY3Rpb24gU3RhY2tGcmFtZShvYmopIHtcbiAgICAgICAgaWYgKCFvYmopIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9ialtwcm9wc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3NldCcgKyBfY2FwaXRhbGl6ZShwcm9wc1tpXSldKG9ialtwcm9wc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGdldEFyZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXJnczogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3MgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcmdzID0gdjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFdmFsT3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2YWxPcmlnaW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldEV2YWxPcmlnaW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IHY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSBuZXcgU3RhY2tGcmFtZSh2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZhbCBPcmlnaW4gbXVzdCBiZSBhbiBPYmplY3Qgb3IgU3RhY2tGcmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gdGhpcy5nZXRDb2x1bW5OdW1iZXIoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SXNFdmFsKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbZXZhbF0gKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgKyAnICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdGFja0ZyYW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBTdGFja0ZyYW1lJCRmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgYXJnc1N0YXJ0SW5kZXggPSBzdHIuaW5kZXhPZignKCcpO1xuICAgICAgICB2YXIgYXJnc0VuZEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcpJyk7XG5cbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgYXJnc1N0YXJ0SW5kZXgpO1xuICAgICAgICB2YXIgYXJncyA9IHN0ci5zdWJzdHJpbmcoYXJnc1N0YXJ0SW5kZXggKyAxLCBhcmdzRW5kSW5kZXgpLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBsb2NhdGlvblN0cmluZyA9IHN0ci5zdWJzdHJpbmcoYXJnc0VuZEluZGV4ICsgMSk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uU3RyaW5nLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gL0AoLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvLmV4ZWMobG9jYXRpb25TdHJpbmcsICcnKTtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBwYXJ0c1szXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtbk51bWJlciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbGVhblByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSBfZ2V0dGVyKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gQm9vbGVhbih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1lcmljUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IF9nZXR0ZXIobnVtZXJpY1Byb3BzW2pdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocCArICcgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gTnVtYmVyKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkobnVtZXJpY1Byb3BzW2pdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHN0cmluZ1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IF9nZXR0ZXIoc3RyaW5nUHJvcHNba10pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gU3RyaW5nKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoc3RyaW5nUHJvcHNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBTdGFja0ZyYW1lO1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2t0cmFjZS1ncHMnLCBbJ3NvdXJjZS1tYXAnLCAnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLCByZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tUcmFjZUdQUyA9IGZhY3Rvcnkocm9vdC5Tb3VyY2VNYXAgfHwgcm9vdC5zb3VyY2VNYXAsIHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTb3VyY2VNYXAsIFN0YWNrRnJhbWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgWC1Eb21haW4gcmVxdWVzdCB0byB1cmwgYW5kIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB3aXRoIHJlc3BvbnNlIHRleHQgaWYgZnVsZmlsbGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3hkcih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxLm9wZW4oJ2dldCcsIHVybCk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBvbnJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocmVxLnN0YXR1cyA+PSAyMDAgJiYgcmVxLnN0YXR1cyA8IDMwMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh1cmwuc3Vic3RyKDAsIDcpID09PSAnZmlsZTovLycgJiYgcmVxLnJlc3BvbnNlVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdIVFRQIHN0YXR1czogJyArIHJlcS5zdGF0dXMgKyAnIHJldHJpZXZpbmcgJyArIHVybCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5zZW5kKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBpbnRvIGl0cyBvcmlnaW5hbCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBVc2VkIGZvciBpbmxpbmUgc291cmNlbWFwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiNjRzdHIgQmFzZS02NCBlbmNvZGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG9yaWdpbmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2F0b2IoYjY0c3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYXRvYikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKGI2NHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIHBvbHlmaWxsIGZvciB3aW5kb3cuYXRvYiBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcGFyc2VKc29uKHN0cmluZykge1xuICAgICAgICBpZiAodHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnICYmIEpTT04ucGFyc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIHBvbHlmaWxsIGZvciBKU09OLnBhcnNlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maW5kRnVuY3Rpb25OYW1lKHNvdXJjZSwgbGluZU51bWJlci8qLCBjb2x1bW5OdW1iZXIqLykge1xuICAgICAgICB2YXIgc3ludGF4ZXMgPSBbXG4gICAgICAgICAgICAvLyB7bmFtZX0gPSBmdW5jdGlvbiAoe2FyZ3N9KSBUT0RPIGFyZ3MgY2FwdHVyZVxuICAgICAgICAgICAgL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqZnVuY3Rpb25cXGIvLFxuICAgICAgICAgICAgLy8gZnVuY3Rpb24ge25hbWV9KHthcmdzfSkgbVsxXT1uYW1lIG1bMl09YXJnc1xuICAgICAgICAgICAgL2Z1bmN0aW9uXFxzKyhbXignXCJgXSo/KVxccypcXCgoW14pXSopXFwpLyxcbiAgICAgICAgICAgIC8vIHtuYW1lfSA9IGV2YWwoKVxuICAgICAgICAgICAgL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqKD86ZXZhbHxuZXcgRnVuY3Rpb24pXFxiLyxcbiAgICAgICAgICAgIC8vIGZuX25hbWUoKSB7XG4gICAgICAgICAgICAvXFxiKD8hKD86aWZ8Zm9yfHN3aXRjaHx3aGlsZXx3aXRofGNhdGNoKVxcYikoPzooPzpzdGF0aWMpXFxzKyk/KFxcUyspXFxzKlxcKC4qP1xcKVxccypcXHsvLFxuICAgICAgICAgICAgLy8ge25hbWV9ID0gKCkgPT4ge1xuICAgICAgICAgICAgL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqXFwoLio/XFwpXFxzKj0+L1xuICAgICAgICBdO1xuICAgICAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIC8vIFdhbGsgYmFja3dhcmRzIGluIHRoZSBzb3VyY2UgbGluZXMgdW50aWwgd2UgZmluZCB0aGUgbGluZSB3aGljaCBtYXRjaGVzIG9uZSBvZiB0aGUgcGF0dGVybnMgYWJvdmVcbiAgICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgICAgdmFyIG1heExpbmVzID0gTWF0aC5taW4obGluZU51bWJlciwgMjApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heExpbmVzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGxpbmVObyBpcyAxLWJhc2VkLCBzb3VyY2VbXSBpcyAwLWJhc2VkXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVOdW1iZXIgLSBpIC0gMV07XG4gICAgICAgICAgICB2YXIgY29tbWVudFBvcyA9IGxpbmUuaW5kZXhPZignLy8nKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgY29tbWVudFBvcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGxpbmUgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBzeW50YXhlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHN5bnRheGVzW2luZGV4XS5leGVjKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnN1cmVTdXBwb3J0ZWRFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvbnN1bWUgc291cmNlIG1hcHMgaW4gb2xkZXIgYnJvd3NlcnMnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tmcmFtZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dpdmVuIFN0YWNrRnJhbWUgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmZpbGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gZmlsZSBuYW1lIGlzIG5vdCBhIFN0cmluZycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgJSAxICE9PSAwIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBsaW5lIG51bWJlciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmNvbHVtbk51bWJlciAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyICUgMSAhPT0gMCB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXIgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBjb2x1bW4gbnVtYmVyIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maW5kU291cmNlTWFwcGluZ1VSTChzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmdVcmxSZWdFeHAgPSAvXFwvXFwvWyNAXSA/c291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKylcXHMqJC9tZztcbiAgICAgICAgdmFyIGxhc3RTb3VyY2VNYXBwaW5nVXJsO1xuICAgICAgICB2YXIgbWF0Y2hTb3VyY2VNYXBwaW5nVXJsO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgd2hpbGUgKG1hdGNoU291cmNlTWFwcGluZ1VybCA9IHNvdXJjZU1hcHBpbmdVcmxSZWdFeHAuZXhlYyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBsYXN0U291cmNlTWFwcGluZ1VybCA9IG1hdGNoU291cmNlTWFwcGluZ1VybFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNvdXJjZU1hcHBpbmdVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0U291cmNlTWFwcGluZ1VybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlTWFwcGluZ1VSTCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRyYWN0TG9jYXRpb25JbmZvRnJvbVNvdXJjZU1hcFNvdXJjZShzdGFja2ZyYW1lLCBzb3VyY2VNYXBDb25zdW1lciwgc291cmNlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IHNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YWNrZnJhbWUubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGxvYy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWNoZSBtYXBwZWQgc291cmNlc1xuICAgICAgICAgICAgICAgIHZhciBtYXBwZWRTb3VyY2UgPSBzb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGxvYy5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQ2FjaGVbbG9jLnNvdXJjZV0gPSBtYXBwZWRTb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZW4gc3RhY2tmcmFtZSBhbmQgc291cmNlIGxvY2F0aW9uLCB1cGRhdGUgc3RhY2tmcmFtZVxuICAgICAgICAgICAgICAgICAgICBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxvYy5uYW1lIHx8IHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogc3RhY2tmcmFtZS5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvYy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2MubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jLmNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgb3JpZ2luYWwgc291cmNlIGZvciBnaXZlbiBzdGFja2ZyYW1lIGFuZCBzb3VyY2UgbWFwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqICAgICAgb3B0cy5zb3VyY2VDYWNoZSA9IHt1cmw6IFwiU291cmNlIFN0cmluZ1wifSA9PiBwcmVsb2FkIHNvdXJjZSBjYWNoZVxuICAgICAqICAgICAgb3B0cy5zb3VyY2VNYXBDb25zdW1lckNhY2hlID0gey9wYXRoL2ZpbGUuanMubWFwOiBTb3VyY2VNYXBDb25zdW1lcn1cbiAgICAgKiAgICAgIG9wdHMub2ZmbGluZSA9IFRydWUgdG8gcHJldmVudCBuZXR3b3JrIHJlcXVlc3RzLlxuICAgICAqICAgICAgICAgICAgICBCZXN0IGVmZm9ydCB3aXRob3V0IHNvdXJjZXMgb3Igc291cmNlIG1hcHMuXG4gICAgICogICAgICBvcHRzLmFqYXggPSBQcm9taXNlIHJldHVybmluZyBmdW5jdGlvbiB0byBtYWtlIFgtRG9tYWluIHJlcXVlc3RzXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMob3B0cykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RhY2tUcmFjZUdQUykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tUcmFjZUdQUyhvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICB0aGlzLnNvdXJjZUNhY2hlID0gb3B0cy5zb3VyY2VDYWNoZSB8fCB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXBDb25zdW1lckNhY2hlID0gb3B0cy5zb3VyY2VNYXBDb25zdW1lckNhY2hlIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuYWpheCA9IG9wdHMuYWpheCB8fCBfeGRyO1xuXG4gICAgICAgIHRoaXMuX2F0b2IgPSBvcHRzLmF0b2IgfHwgX2F0b2I7XG5cbiAgICAgICAgdGhpcy5fZ2V0ID0gZnVuY3Rpb24gX2dldChsb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0RhdGFVcmwgPSBsb2NhdGlvbi5zdWJzdHIoMCwgNSkgPT09ICdkYXRhOic7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5zb3VyY2VDYWNoZVtsb2NhdGlvbl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5vZmZsaW5lICYmICFpc0RhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IG1ha2UgbmV0d29yayByZXF1ZXN0cyBpbiBvZmZsaW5lIG1vZGUnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGF0YVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBVUkxzIGNhbiBoYXZlIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjM5N1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRlZEVuY29kaW5nUmVnZXhwID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXFx3PTpcIi1dKzspKmJhc2U2NCwvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbG9jYXRpb24ubWF0Y2goc3VwcG9ydGVkRW5jb2RpbmdSZWdleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1hcFN0YXJ0ID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkU291cmNlID0gbG9jYXRpb24uc3Vic3RyKHNvdXJjZU1hcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fYXRvYihlbmNvZGVkU291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBlbmNvZGluZyBvZiB0aGUgaW5saW5lIHNvdXJjZW1hcCBpcyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhoclByb21pc2UgPSB0aGlzLmFqYXgobG9jYXRpb24sIHttZXRob2Q6ICdnZXQnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgUHJvbWlzZSB0byBwcmV2ZW50IGR1cGxpY2F0ZSBpbi1mbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dID0geGhyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoclByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRpbmcgU291cmNlTWFwQ29uc3VtZXJzIGlzIGV4cGVuc2l2ZSwgc28gdGhpcyB3cmFwcyB0aGUgY3JlYXRpb24gb2YgYVxuICAgICAgICAgKiBTb3VyY2VNYXBDb25zdW1lciBpbiBhIHBlci1pbnN0YW5jZSBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZU1hcHBpbmdVUkwgPSBVUkwgdG8gZmV0Y2ggc291cmNlIG1hcCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWZhdWx0U291cmNlUm9vdCA9IERlZmF1bHQgc291cmNlIHJvb3QgZm9yIHNvdXJjZSBtYXAgaWYgdW5kZWZpbmVkXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dldFNvdXJjZU1hcENvbnN1bWVyID0gZnVuY3Rpb24gX2dldFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcHBpbmdVUkwsIGRlZmF1bHRTb3VyY2VSb290KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcENvbnN1bWVyQ2FjaGVbc291cmNlTWFwcGluZ1VSTF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnNvdXJjZU1hcENvbnN1bWVyQ2FjaGVbc291cmNlTWFwcGluZ1VSTF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBDb25zdW1lclByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQoc291cmNlTWFwcGluZ1VSTCkudGhlbihmdW5jdGlvbihzb3VyY2VNYXBTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZU1hcFNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwU291cmNlID0gX3BhcnNlSnNvbihzb3VyY2VNYXBTb3VyY2UucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZU1hcFNvdXJjZS5zb3VyY2VSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBTb3VyY2Uuc291cmNlUm9vdCA9IGRlZmF1bHRTb3VyY2VSb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFNvdXJjZU1hcC5Tb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXBTb3VyY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwQ29uc3VtZXJDYWNoZVtzb3VyY2VNYXBwaW5nVVJMXSA9IHNvdXJjZU1hcENvbnN1bWVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2VNYXBDb25zdW1lclByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgZW5oYW5jZSBmdW5jdGlvbiBuYW1lIGFuZCB1c2Ugc291cmNlIG1hcHMgZm9yIGFcbiAgICAgICAgICogYmV0dGVyIFN0YWNrRnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RhY2tGcmFtZX0gc3RhY2tmcmFtZSBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCB3aXRoIHNvdXJjZS1tYXBwZWQgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5waW5wb2ludCA9IGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMkJHBpbnBvaW50KHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcHBlZExvY2F0aW9uKHN0YWNrZnJhbWUpLnRoZW4oZnVuY3Rpb24obWFwcGVkU3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlTWFwcGVkU3RhY2tGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWFwcGVkU3RhY2tGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRGdW5jdGlvbk5hbWUobWFwcGVkU3RhY2tGcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUsIHJlc29sdmVNYXBwZWRTdGFja0ZyYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ2NhdGNoJ10ocmVzb2x2ZU1hcHBlZFN0YWNrRnJhbWUpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgZ3Vlc3MgZnVuY3Rpb24gbmFtZSBmcm9tIGxvY2F0aW9uIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0YWNrRnJhbWV9IHN0YWNrZnJhbWVcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCBlbmhhbmNlZCBTdGFja0ZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maW5kRnVuY3Rpb25OYW1lID0gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyQkZmluZEZ1bmN0aW9uTmFtZShzdGFja2ZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX2Vuc3VyZVN0YWNrRnJhbWVJc0xlZ2l0KHN0YWNrZnJhbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldChzdGFja2ZyYW1lLmZpbGVOYW1lKS50aGVuKGZ1bmN0aW9uIGdldFNvdXJjZUNhbGxiYWNrKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHN0YWNrZnJhbWUubGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3Vlc3NlZEZ1bmN0aW9uTmFtZSA9IF9maW5kRnVuY3Rpb25OYW1lKHNvdXJjZSwgbGluZU51bWJlciwgY29sdW1uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXBsYWNlIGZ1bmN0aW9uTmFtZSBpZiB3ZSBmb3VuZCBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGd1ZXNzZWRGdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZ3Vlc3NlZEZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBzdGFja2ZyYW1lLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IHN0YWNrZnJhbWUuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtbk51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGFja2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHJlamVjdClbJ2NhdGNoJ10ocmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgc2VlayBzb3VyY2UtbWFwcGVkIGxvY2F0aW9uIGFuZCByZXR1cm4gbmV3IGVuaGFuY2VkIFN0YWNrRnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RhY2tGcmFtZX0gc3RhY2tmcmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aXRoIGVuaGFuY2VkIFN0YWNrRnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE1hcHBlZExvY2F0aW9uID0gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyQkZ2V0TWFwcGVkTG9jYXRpb24oc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdXBwb3J0ZWRFbnZpcm9ubWVudCgpO1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKTtcblxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDYWNoZSA9IHRoaXMuc291cmNlQ2FjaGU7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gc3RhY2tmcmFtZS5maWxlTmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXQoZmlsZU5hbWUpLnRoZW4oZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gX2ZpbmRTb3VyY2VNYXBwaW5nVVJMKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0RhdGFVcmwgPSBzb3VyY2VNYXBwaW5nVVJMLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGE6JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRTb3VyY2VSb290ID0gZmlsZU5hbWUuc3Vic3RyaW5nKDAsIGZpbGVOYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlTWFwcGluZ1VSTFswXSAhPT0gJy8nICYmICFpc0RhdGFVcmwgJiYgISgvXmh0dHBzPzpcXC9cXC98XlxcL1xcLy9pKS50ZXN0KHNvdXJjZU1hcHBpbmdVUkwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBwaW5nVVJMID0gZGVmYXVsdFNvdXJjZVJvb3QgKyBzb3VyY2VNYXBwaW5nVVJMO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcHBpbmdVUkwsIGRlZmF1bHRTb3VyY2VSb290KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dHJhY3RMb2NhdGlvbkluZm9Gcm9tU291cmNlTWFwU291cmNlKHN0YWNrZnJhbWUsIHNvdXJjZU1hcENvbnN1bWVyLCBzb3VyY2VDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlbJ2NhdGNoJ10oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0YWNrZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgcmVqZWN0KVsnY2F0Y2gnXShyZWplY3QpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICB9O1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2t0cmFjZScsIFsnZXJyb3Itc3RhY2stcGFyc2VyJywgJ3N0YWNrLWdlbmVyYXRvcicsICdzdGFja3RyYWNlLWdwcyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnZXJyb3Itc3RhY2stcGFyc2VyJyksIHJlcXVpcmUoJ3N0YWNrLWdlbmVyYXRvcicpLCByZXF1aXJlKCdzdGFja3RyYWNlLWdwcycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrVHJhY2UgPSBmYWN0b3J5KHJvb3QuRXJyb3JTdGFja1BhcnNlciwgcm9vdC5TdGFja0dlbmVyYXRvciwgcm9vdC5TdGFja1RyYWNlR1BTKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIFN0YWNrVHJhY2UoRXJyb3JTdGFja1BhcnNlciwgU3RhY2tHZW5lcmF0b3IsIFN0YWNrVHJhY2VHUFMpIHtcbiAgICB2YXIgX29wdGlvbnMgPSB7XG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24oc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBzdGFja2ZyYW1lcyBmb3IgdGhpcyBsaWJyYXJ5IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHJldHVybiAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrVHJhY2UkJCcpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIChzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnJykuaW5kZXhPZignRXJyb3JTdGFja1BhcnNlciQkJykgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdTdGFja1RyYWNlR1BTJCQnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrR2VuZXJhdG9yJCQnKSA9PT0gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZUNhY2hlOiB7fVxuICAgIH07XG5cbiAgICB2YXIgX2dlbmVyYXRlRXJyb3IgPSBmdW5jdGlvbiBTdGFja1RyYWNlJCRHZW5lcmF0ZUVycm9yKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRXJyb3IgbXVzdCBiZSB0aHJvd24gdG8gZ2V0IHN0YWNrIGluIElFXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlIDIgZ2l2ZW4gT2JqZWN0cy4gSWYgYSBjb25mbGljdCBvY2N1cnMgdGhlIHNlY29uZCBvYmplY3Qgd2lucy5cbiAgICAgKiBEb2VzIG5vdCBkbyBkZWVwIG1lcmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaXJzdCBiYXNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgb3ZlcnJpZGVzXG4gICAgICogQHJldHVybnMge09iamVjdH0gbWVyZ2VkIGZpcnN0IGFuZCBzZWNvbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9tZXJnZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcblxuICAgICAgICBbZmlyc3QsIHNlY29uZF0uZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGVycikge1xuICAgICAgICByZXR1cm4gZXJyLnN0YWNrIHx8IGVyclsnb3BlcmEjc291cmNlbG9jJ107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbHRlcmVkKHN0YWNrZnJhbWVzLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2ZyYW1lcy5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2tmcmFtZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGJhY2t0cmFjZSBmcm9tIGludm9jYXRpb24gcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gb2YgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZXQob3B0cykge1xuICAgICAgICAgICAgdmFyIGVyciA9IF9nZW5lcmF0ZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZXJyKSA/IHRoaXMuZnJvbUVycm9yKGVyciwgb3B0cykgOiB0aGlzLmdlbmVyYXRlQXJ0aWZpY2lhbGx5KG9wdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBiYWNrdHJhY2UgZnJvbSBpbnZvY2F0aW9uIHBvaW50LlxuICAgICAgICAgKiBJTVBPUlRBTlQ6IERvZXMgbm90IGhhbmRsZSBzb3VyY2UgbWFwcyBvciBndWVzcyBmdW5jdGlvbiBuYW1lcyFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBvZiBTdGFja0ZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTeW5jOiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZXRTeW5jKG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfbWVyZ2UoX29wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGVyciA9IF9nZW5lcmF0ZUVycm9yKCk7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBfaXNTaGFwZWRMaWtlUGFyc2FibGVFcnJvcihlcnIpID8gRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnIpIDogU3RhY2tHZW5lcmF0b3IuYmFja3RyYWNlKG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIF9maWx0ZXJlZChzdGFjaywgb3B0cy5maWx0ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBlcnJvciBvYmplY3QsIHBhcnNlIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IGZvciBBcnJheVtTdGFja0ZyYW1lfVxuICAgICAgICAgKi9cbiAgICAgICAgZnJvbUVycm9yOiBmdW5jdGlvbiBTdGFja1RyYWNlJCRmcm9tRXJyb3IoZXJyb3IsIG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfbWVyZ2UoX29wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGdwcyA9IG5ldyBTdGFja1RyYWNlR1BTKG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tmcmFtZXMgPSBfZmlsdGVyZWQoRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnJvciksIG9wdHMuZmlsdGVyKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFByb21pc2UuYWxsKHN0YWNrZnJhbWVzLm1hcChmdW5jdGlvbihzZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZU9yaWdpbmFsKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBncHMucGlucG9pbnQoc2YpLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZU9yaWdpbmFsKVsnY2F0Y2gnXShyZXNvbHZlT3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIFN0YWNrR2VuZXJhdG9yIHRvIGdlbmVyYXRlIGEgYmFja3RyYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gb2YgQXJyYXlbU3RhY2tGcmFtZV1cbiAgICAgICAgICovXG4gICAgICAgIGdlbmVyYXRlQXJ0aWZpY2lhbGx5OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZW5lcmF0ZUFydGlmaWNpYWxseShvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gX21lcmdlKF9vcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBzdGFja0ZyYW1lcyA9IFN0YWNrR2VuZXJhdG9yLmJhY2t0cmFjZShvcHRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdGFja0ZyYW1lcyA9IHN0YWNrRnJhbWVzLmZpbHRlcihvcHRzLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0YWNrRnJhbWVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBmdW5jdGlvbiwgd3JhcCBpdCBzdWNoIHRoYXQgaW52b2NhdGlvbnMgdHJpZ2dlciBhIGNhbGxiYWNrIHRoYXRcbiAgICAgICAgICogaXMgY2FsbGVkIHdpdGggYSBzdGFjayB0cmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gYmUgaW5zdHJ1bWVudGVkXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBhIHN0YWNrIHRyYWNlIG9uIGludm9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyYmFjayBvcHRpb25hbCBmdW5jdGlvbiB0byBjYWxsIHdpdGggZXJyb3IgaWYgdW5hYmxlIHRvIGdldCBzdGFjayB0cmFjZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgb3B0aW9uYWwgY29udGV4dCBvYmplY3QgKGUuZy4gd2luZG93KVxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdHJ1bWVudDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkaW5zdHJ1bWVudChmbiwgY2FsbGJhY2ssIGVycmJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnN0cnVtZW50IG5vbi1mdW5jdGlvbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGluc3RydW1lbnRlZCwgcmV0dXJuIGdpdmVuIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5zdHJ1bWVudGVkID0gZnVuY3Rpb24gU3RhY2tUcmFjZSQkaW5zdHJ1bWVudGVkKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KCkudGhlbihjYWxsYmFjaywgZXJyYmFjaylbJ2NhdGNoJ10oZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUVycm9yKGUpLnRoZW4oY2FsbGJhY2ssIGVycmJhY2spWydjYXRjaCddKGVycmJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgaW5zdHJ1bWVudGVkLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPSBmbjtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGluc3RydW1lbnRlZCxcbiAgICAgICAgICogcmV2ZXJ0IHRoZSBmdW5jdGlvbiB0byBpdCdzIG9yaWdpbmFsIChub24taW5zdHJ1bWVudGVkKSBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gZGUtaW5zdHJ1bWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZGVpbnN0cnVtZW50OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRkZWluc3RydW1lbnQoZm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZS1pbnN0cnVtZW50IG5vbi1mdW5jdGlvbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uX19zdGFja3RyYWNlT3JpZ2luYWxGbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gbm90IGluc3RydW1lbnRlZCwgcmV0dXJuIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBlcnJvciBtZXNzYWdlIGFuZCBBcnJheSBvZiBTdGFja0ZyYW1lcywgc2VyaWFsaXplIGFuZCBQT1NUIHRvIGdpdmVuIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc3RhY2tmcmFtZXNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JNc2dcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICByZXBvcnQ6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJHJlcG9ydChzdGFja2ZyYW1lcywgdXJsLCBlcnJvck1zZywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAyMDAgJiYgcmVxLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1BPU1QgdG8gJyArIHVybCArICcgZmFpbGVkIHdpdGggc3RhdHVzOiAnICsgcmVxLnN0YXR1cykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub3BlbigncG9zdCcsIHVybCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVxdWVzdCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zICYmIHR5cGVvZiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlcXVlc3RPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVwb3J0UGF5bG9hZCA9IHtzdGFjazogc3RhY2tmcmFtZXN9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1zZyAhPT0gdW5kZWZpbmVkICYmIGVycm9yTXNnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFBheWxvYWQubWVzc2FnZSA9IGVycm9yTXNnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcS5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcG9ydFBheWxvYWQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXVxuICBdKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NEcml2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvZHJpdmVyL0thdGFsTWV0cmljc0RyaXZlclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbnZhciBfa2F0YWxTdXNoaUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLXN1c2hpLWNsaWVudFwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEtBVF9TVEFOREFMT05FX05FWFVTX1BST0RVQ0VSX0lEID0gJ2thdGFsJztcbnZhciBLQVRfU1RBTkRBTE9ORV9ERUZBVUxUX1NPVVJDRV9HUk9VUFMgPSB7XG4gIHRlc3Q6ICdjb20uYW1hem9uLmVlbC5rYXRhbC5tZXRyaWNzLmNvcmUubmV4dXMuZ2FtbWEnLFxuICBwcm9kOiAnY29tLmFtYXpvbi5lZWwua2F0YWwubWV0cmljcy5jb3JlLm5leHVzJ1xufTtcblxudmFyIEthdGFsTWV0cmljc0RyaXZlclN1c2hpQnVpbGRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0RyaXZlclN1c2hpQnVpbGRlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29udGV4dFwiLCB7fSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIsIFt7XG4gICAga2V5OiBcIndpdGhTdXNoaUNsaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnQoc3VzaGlDbGllbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd3aXRoU3VzaGkgY2xpZW50Li4uJyk7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlDbGllbnQgPSBzdXNoaUNsaWVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoRG9tYWluUmVhbG1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aERvbWFpblJlYWxtKGRvbWFpbiwgcmVhbG0pIHtcbiAgICAgIHRoaXMuY29udGV4dC5kb21haW4gPSBkb21haW47XG4gICAgICB0aGlzLmNvbnRleHQucmVhbG0gPSByZWFsbTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoQ3VzdG9tUHJvZHVjZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEN1c3RvbVByb2R1Y2VyKHN1c2hpUHJvZHVjZXJJZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpUHJvZHVjZXIgPSBzdXNoaVByb2R1Y2VySWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEN1c3RvbVNvdXJjZUdyb3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhDdXN0b21Tb3VyY2VHcm91cChzb3VyY2VHcm91cElkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc291cmNlR3JvdXBJZCA9IHNvdXJjZUdyb3VwSWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoU3VzaGlDbGllbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTdXNoaUNsaWVudE9wdGlvbnMoc3VzaGlDbGllbnRPcHRpb25zKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlDbGllbnRPcHRpb25zID0gc3VzaGlDbGllbnRPcHRpb25zO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhTdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlKHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlID0gc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkodGhpcy5jb250ZXh0KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0RyaXZlclN1c2hpQnVpbGRlcjtcbn0oKTtcblxudmFyIEthdGFsTWV0cmljc0RyaXZlclN1c2hpID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNzRHJpdmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBfS2F0YWxNZXRyaWNzRHJpdmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljc0RyaXZlclN1c2hpKTtcblxuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaShvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJzdXNoaVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwicHJvZHVjZXJJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwic291cmNlR3JvdXBJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiZXJyb3JIYW5kbGVyXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJjb21iaW5lZEVycm9ySGFuZGxlclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoX3RoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGVycik7IC8vIFJldHVybiB0byBhdm9pZCBmYWxsaW5nIHRocm91Z2ggdG8gZGVmYXVsdCBlcnJvciBoYW5kbGVyXG5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAobmV4dEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBlcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV4dEVycik7IC8vIEZhbGwgdGhyb3VnaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9KTtcbiAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW4sXG4gICAgICAgIHJlYWxtID0gb3B0aW9ucy5yZWFsbSxcbiAgICAgICAgZXJyb3JIYW5kbGVyID0gb3B0aW9ucy5lcnJvckhhbmRsZXIsXG4gICAgICAgIHN1c2hpQ2xpZW50ID0gb3B0aW9ucy5zdXNoaUNsaWVudCxcbiAgICAgICAgX29wdGlvbnMkc3VzaGlQcm9kdWNlID0gb3B0aW9ucy5zdXNoaVByb2R1Y2VyLFxuICAgICAgICBwcm9kdWNlcklkID0gX29wdGlvbnMkc3VzaGlQcm9kdWNlID09PSB2b2lkIDAgPyBLQVRfU1RBTkRBTE9ORV9ORVhVU19QUk9EVUNFUl9JRCA6IF9vcHRpb25zJHN1c2hpUHJvZHVjZSxcbiAgICAgICAgc3VzaGlDbGllbnRPcHRpb25zID0gb3B0aW9ucy5zdXNoaUNsaWVudE9wdGlvbnMsXG4gICAgICAgIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUgPSBvcHRpb25zLnN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGU7IC8vIGN1c3RvbSBzb3VyY2UgZ3JvdXAgYWx3YXlzIG92ZXJyaWRlcyBkZWZhdWx0c1xuXG4gICAgdmFyIHNvdXJjZUdyb3VwSWQgPSBvcHRpb25zLnNvdXJjZUdyb3VwSWQgfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTW2RvbWFpbl0gfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTWyd0ZXN0J107XG4gICAgX3RoaXMuc3VzaGkgPSBzdXNoaUNsaWVudCB8fCBfdGhpcy5idWlsZFN1c2hpQ2xpZW50KGRvbWFpbiwgcmVhbG0sIHNvdXJjZUdyb3VwSWQsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgX3RoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgIF90aGlzLnByb2R1Y2VySWQgPSBwcm9kdWNlcklkO1xuICAgIF90aGlzLnNvdXJjZUdyb3VwSWQgPSBzb3VyY2VHcm91cElkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBbe1xuICAgIGtleTogXCJiZWZvcmVVbmxvYWRcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCByaWdodCBiZWZvcmUgdGhlIHBhZ2UgdW5sb2Fkcy4gVGhpc1xuICAgICAqIGFsbG93cyBmb3IgYW55IGZpbmFsIG1ldHJpY3MsIHN1Y2ggYXMgcGFnZSB2aXNpdCBkdXJhdGlvbiwgdG8gYmUgc2VudFxuICAgICAqIGJlZm9yZSB0aGUgdXNlciBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlIG9yIGNsb3NlcyB0aGUgdGFiLlxuICAgICAqIE5PVEU6IFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIEFQSSBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmVVbmxvYWQoY2IpIHtcbiAgICAgIHRoaXMuc3VzaGkub25TdXNoaVVubG9hZChjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZXJyb3IgaGFuZGxlciBpZiB0aGUgdXNlci1zdXBwbGllZCBlcnJvciBoYW5kbGVyIGZhaWxzIG9yIGlzIHVuc2V0LiAgU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3NcbiAgICAgKiB1c2VyLXByb3ZpZGVkIGVycm9yIGhhbmRsZXIgbWlzYmVoYXZlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgVW5oYW5kbGVkIGVycm9yIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEVycm9ySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGVycm9yLWhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHVzZXIgd2hlbiB0aGlzIG9iamVjdCB3YXMgY29uc3RydWN0ZWQ7IGlmIHRoYXQgaXMgdW5zZXQgb3IgaXRzZWxmIHRocm93c1xuICAgICAqIGFuIGV4Y2VwdGlvbiwgY2FsbHMgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBhcyBhIGZhbGxiYWNrLCB3aGljaCB3aWxsIGp1c3QgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgRXJyb3Igb2JqZWN0IHRvIGhhbmRsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxpbmdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHdyYXAgYSBmdW5jdGlvbiBpbiB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb1RoZVRoaW5nIEZ1bmN0aW9uIHRvIHJ1biB1bmRlciB0aGUgd3JhcHBlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxpbmcoZG9UaGVUaGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvVGhlVGhpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkU3VzaGlDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRTdXNoaUNsaWVudChkb21haW4sIHJlYWxtLCBzb3VyY2VHcm91cElkLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpIHtcbiAgICAgIGlmICghZG9tYWluIHx8ICFyZWFsbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0thdGFsTWV0cmljc0RyaXZlclN1c2hpIHJlcXVpcmVzIGEgZG9tYWluIGFuZCByZWFsbSB0byBidWlsZCBhIHN1c2hpIGNsaWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0KEthdGFsTWV0cmljc0RyaXZlclN1c2hpLmdldFJlYWxtTmFtZShyZWFsbSksIHNvdXJjZUdyb3VwSWQsIHRoaXMuY29tYmluZWRFcnJvckhhbmRsZXIsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hcIixcbiAgICB2YWx1ZTogLy8gVE9ETzogZXJyb3JIYW5kbGVyIGluIHRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIG5vdCByZWZlcmVuY2VkLlxuICAgIC8vIFRlY2ggZGVidDogaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTg3NVxuICAgIGZ1bmN0aW9uIHB1Ymxpc2gobWV0cmljT2JqZWN0LCBlcnJvckhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBTdXBwb3J0IGZvciBuZXcgMi1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2gsIHdoaWNoIGRvZXMgbm90IHBhc3MgdGhlIHVudXNlZCBlcnJvckhhbmRsZXIgb2JqZWN0IChLQVQtODc1KVxuICAgICAgdmFyIG1ldHJpY3NDb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBhcmd1bWVudHNbMV0gOiBhcmd1bWVudHNbMl07XG4gICAgICB0aGlzLndpdGhFcnJvckhhbmRsaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBsb2dpYyBpcyBub3cgbW92ZWQgaW50byBLYXRhbE1ldHJpY3NQdWJsaXNoZXIsIG9uY2UgZXZlcnlib2R5IGhhcyB0aGF0IHVwZGF0ZSB3ZSBjYW4gcmVtb3ZlIHRoaXMuXG4gICAgICAgIC8vIFRlY2ggZGVidDogaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTg3NlxuICAgICAgICBpZiAoX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0Lkxpc3QgPT09IG1ldHJpY09iamVjdC50eXBlKSB7XG4gICAgICAgICAgbWV0cmljT2JqZWN0Lm1ldHJpY0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgICBfdGhpczIucHVibGlzaChtZXRyaWMsIG1ldHJpY3NDb250ZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dXNTY2hlbWEgPSBfdGhpczIubWFwT2JqZWN0VHlwZVRvTmV4dXNTY2hlbWEobWV0cmljT2JqZWN0LnR5cGUpO1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1ldHJpY3NDb250ZXh0LmNvbnRleHQpLCB7fSwge1xuICAgICAgICAgIG1ldHJpY0tleTogbWV0cmljT2JqZWN0Lm5hbWUsXG4gICAgICAgICAgdmFsdWU6IG1ldHJpY09iamVjdC52YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWV0cmljT2JqZWN0LmlzTW9uaXRvcikge1xuICAgICAgICAgIGZpZWxkcy5pc01vbml0b3IgPSB0cnVlO1xuICAgICAgICB9IC8vIERlbGV0aW5nIGNsb3VkV2F0Y2hEaW1lbnNpb25zIGZpZWxkIGlmIGV4aXN0cyBhcyBpdCBhcHBsaWVzIG9ubHkgZm9yIEthdGFsTW9uaXRvcmluZ0FXU0RyaXZlci5cblxuXG4gICAgICAgIGlmIChmaWVsZHMuY2xvdWRXYXRjaERpbWVuc2lvbnMpIHtcbiAgICAgICAgICBkZWxldGUgZmllbGRzLmNsb3VkV2F0Y2hEaW1lbnNpb25zO1xuICAgICAgICB9IC8vIFJlc2V0IHRoZSBldmVudCBjb3VudCBiYWNrIHRvIDAsIG90aGVyd2lzZSBTdXNoaSB3aWxsIHN0b3AgcHVibGlzaGluZyBhZnRlciAxSyBpdGVtcyAoaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTE1MzQpXG5cblxuICAgICAgICBfdGhpczIuc3VzaGkucmVzZXQoKTtcblxuICAgICAgICBfdGhpczIuc3VzaGkuZXZlbnQoZmllbGRzLCBfdGhpczIucHJvZHVjZXJJZCwgbmV4dXNTY2hlbWEsIHtcbiAgICAgICAgICBcInNzZFwiOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcE9iamVjdFR5cGVUb05leHVzU2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcE9iamVjdFR5cGVUb05leHVzU2NoZW1hKG9iamVjdFR5cGUpIHtcbiAgICAgIHN3aXRjaCAob2JqZWN0VHlwZSkge1xuICAgICAgICBjYXNlIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdC5TdHJpbmc6XG4gICAgICAgICAgcmV0dXJuICdrYXRhbC5jbGllbnQubWV0cmljcy5TdHJpbmcuMic7XG5cbiAgICAgICAgY2FzZSBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQuQ291bnRlcjpcbiAgICAgICAgICByZXR1cm4gJ2thdGFsLmNsaWVudC5tZXRyaWNzLkNvdW50ZXIuMyc7XG5cbiAgICAgICAgY2FzZSBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQuVGltZXI6XG4gICAgICAgICAgcmV0dXJuICdrYXRhbC5jbGllbnQubWV0cmljcy5UaW1lci4yJztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIi5jb25jYXQob2JqZWN0VHlwZSwgXCIgd2hlbiBwdWJsaXNoaW5nIG1ldHJpYyBvYmplY3QuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXRSZWFsbU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVhbG1OYW1lKHJlYWxtKSB7XG4gICAgICBzd2l0Y2ggKHJlYWxtKSB7XG4gICAgICAgIGNhc2UgJ05BQW1hem9uJzpcbiAgICAgICAgY2FzZSAnVVNBbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuTkE7XG5cbiAgICAgICAgY2FzZSAnRVVBbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuRVU7XG5cbiAgICAgICAgY2FzZSAnRkVBbWF6b24nOlxuICAgICAgICBjYXNlICdKUEFtYXpvbic6XG4gICAgICAgICAgcmV0dXJuIF9rYXRhbFN1c2hpQ2xpZW50LmRlZmF1bHQuUkVHSU9OUy5GRTtcblxuICAgICAgICBjYXNlICdDTkFtYXpvbic6XG4gICAgICAgICAgcmV0dXJuIF9rYXRhbFN1c2hpQ2xpZW50LmRlZmF1bHQuUkVHSU9OUy5DTjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIExldCB0aGUgU3VzaGlDbGllbnQgZGVjaWRlIGlmIHRoaXMgaXMgYm9ndXMgb3Igbm90LlxuICAgICAgICAgIHJldHVybiByZWFsbTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0RyaXZlclN1c2hpO1xufShfS2F0YWxNZXRyaWNzRHJpdmVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9IEthdGFsTWV0cmljc0RyaXZlclN1c2hpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGksIFwiQnVpbGRlclwiLCBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5yZXF1aXJlKFwiLi9ub2RlanNTaGltc1wiKTtcblxudmFyIF9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9IHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc0RyaXZlclN1c2hpXCIpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xudmFyIF9kZWZhdWx0ID0gX0thdGFsTWV0cmljc0RyaXZlclN1c2hpLkthdGFsTWV0cmljc0RyaXZlclN1c2hpO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVTdHJpbmdcIikpO1xuXG52YXIgX3ZhbGlkYXRlQ2xvdWRXYXRjaERpbWVuc2lvbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2hlbHBlci92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zXCIpKTtcblxudmFyIF9GaXJzdE1hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGVscGVyL0ZpcnN0TWFwXCIpKTtcblxudmFyIF9tZXJnZUxpc3RzID0gcmVxdWlyZShcIi4vaGVscGVyL21lcmdlTGlzdHNcIik7XG5cbnZhciBfZW1iZWRSZXF1ZXN0SWQgPSByZXF1aXJlKFwiLi9oZWxwZXIvZW1iZWRSZXF1ZXN0SWRcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUkVRVUlSRURfRklFTERTID0gWydzaXRlJywgJ3NlcnZpY2VOYW1lJywgJ21ldGhvZE5hbWUnXTtcblxudmFyIEthdGFsTWV0cmljc0NvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1ldHJpY3MgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBmaWVsZHMuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0RmllbGRzIENvbnRleHQgZmllbGRzIHZhbHVlIChkZWZhdWx0IGVtcHR5KVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNzQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dEZpZWxkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzQ29udGV4dCk7XG4gICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyBpcyBpbW11dGFibGVcbiAgICB0aGlzLmNvbnRleHQgPSBfb2JqZWN0U3ByZWFkKHt9LCBjb250ZXh0RmllbGRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IEthdGFsTWV0cmljc0NvbnRleHQgd2hpY2ggaXMgYSBjb3B5IG9mIHRoaXMgY29udGV4dCwgd2l0aCB2YWx1ZXMgYWRkZWQgb3Igb3ZlcnJpZGRlbiBmcm9tXG4gICAqIHRoZSBnaXZlbiBjb250ZXh0LlxuICAgKlxuICAgKiBJZiB0aGUgZ2l2ZW4gY29udGV4dCBpcyBudWxsIG9yIGVtcHR5LCB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvcmlnaW5hbCBvYmplY3QgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdGhhdENvbnRleHQgQ29udGV4dCB0byBtZXJnZSB2YWx1ZXMgZnJvbVxuICAgKiBAcmV0dXJuIE5ldyBjb250ZXh0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZnJvbSB0aGlzIGNvbnRleHQsIGFuZCB2YWx1ZXMgb3ZlcnJpZGRlbiBvciBhZGRlZCBieSB0aGUgZ2l2ZW4gY29udGV4dC5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NDb250ZXh0LCBbe1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZSh0aGF0Q29udGV4dCkge1xuICAgICAgaWYgKCF0aGF0Q29udGV4dCkgcmV0dXJuIHRoaXM7IC8vIENoZWNrIGZvciBhIGNvbW1vbiBlcnJvclxuXG4gICAgICBpZiAodGhhdENvbnRleHQgaW5zdGFuY2VvZiBLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2F0YWxNZXRyaWNzQ29udGV4dC5CdWlsZGVyIG9iamVjdCBwYXNzZWQgaW5zdGVhZCBvZiBLYXRhbE1ldHJpY3NDb250ZXh0LiAgVHJ5IGNhbGxpbmcgLmJ1aWxkKCkgbWV0aG9kLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGF0Q29udGV4dCBpbnN0YW5jZW9mIEthdGFsTWV0cmljc0NvbnRleHQgPyB0aGF0Q29udGV4dC5jb250ZXh0IDogdGhhdENvbnRleHQ7XG5cbiAgICAgIHZhciBuZXdDb250ZXh0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCksIGNvbnRleHQpLCB7fSwge1xuICAgICAgICByZWxhdGVkTWV0cmljczogKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljcywgY29udGV4dC5yZWxhdGVkTWV0cmljcyksXG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uLCBjb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKSxcbiAgICAgICAgLy8gQ29tYmluZXMgdGhlIGRpbWVuc2lvbnMgZnJvbSBiYXNlIHB1Ymxpc2hlciB3aXRoIGFueSBjaGlsZCBwdWJsaXNoZXIuXG4gICAgICAgIGNsb3VkV2F0Y2hEaW1lbnNpb25zOiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LmNsb3VkV2F0Y2hEaW1lbnNpb25zLCBjb250ZXh0LmNsb3VkV2F0Y2hEaW1lbnNpb25zKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dChuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGNvbnRleHQgd2hpY2ggaXMgYSBjb3B5IG9mIHRoaXMgY29udGV4dCB3aXRoIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNoaWxkIHB1Ymxpc2hlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQ29weSBvZiB0aGlzIGNvbnRleHQsIHdpdGggcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gcmVtb3ZlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhvdXRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCksIHt9LCB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiB1bmRlZmluZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgY29udGV4dCBzdWl0YWJsZSBmb3IgcHVibGljYXRpb24gdG8gdGhlIGRyaXZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHN0cmlwcyBvdXQgYW55IHByaXZhdGUgZmllbGRzLCBhbmQgbGVhdmVzIG9ubHkgZmllbGRzIGZyb20gdGhlIHNjaGVtYSB0aGF0IHRoZSBkcml2ZXIgc2hvdWxkIHB1Ymxpc2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENvbnRleHQgc3VpdGFibGUgZm9yIGRyaXZlciBwdWJsaWNhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJpdmVyQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcml2ZXJDb250ZXh0KCkge1xuICAgICAgLy8gRG9uJ3QgcHVibGlzaCByZWxhdGVkTWV0cmljcyB0byB0aGUgZHJpdmVyXG4gICAgICB2YXIgbmV3Q29udGV4dEZpZWxkcyA9IF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCk7XG5cbiAgICAgIGRlbGV0ZSBuZXdDb250ZXh0RmllbGRzW1wicmVsYXRlZE1ldHJpY3NcIl07XG4gICAgICBkZWxldGUgbmV3Q29udGV4dEZpZWxkc1tcInJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCJdO1xuICAgICAgZGVsZXRlIG5ld0NvbnRleHRGaWVsZHNbXCJyZXF1ZXN0SWRcIl07XG5cbiAgICAgIGlmICh0aGlzLmNvbnRleHQucmVxdWVzdElkKSB7XG4gICAgICAgIG5ld0NvbnRleHRGaWVsZHMuYWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShuZXdDb250ZXh0RmllbGRzLmFjdGlvbklkLCB0aGlzLmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KG5ld0NvbnRleHRGaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW1wbGUgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybiBTaW1wbGUgSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmllbGRzKCkge1xuICAgICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyByZW1haW5zIGltbXV0YWJsZVxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBhIHZhbGlkYXRpb24gZXJyb3Igb24gdGhpcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZCBpZiBvbmUgaXMgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFcnJvcnMgZm91bmQgd2l0aCB0aGlzIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZXJyOyAvLyBGaWVsZHMg4oCcc2l0ZeKAnSwg4oCcc2VydmljZU5hbWXigJ0sIOKAnG1ldGhvZE5hbWXigJ0sIGFuZCDigJxtZXRyaWNLZXnigJ0gYXJlIHJlcXVpcmVkLlxuXG4gICAgICBlcnIgPSAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKFJFUVVJUkVEX0ZJRUxEUywgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChfdGhpcy5jb250ZXh0W2ZpZWxkXSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRmllbGQgXCIuY29uY2F0KGZpZWxkLCBcIiBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIFwiKS5jb25jYXQoX3RoaXMuY29udGV4dFtmaWVsZF0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgcmV0dXJuICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkoT2JqZWN0LmtleXModGhpcy5jb250ZXh0KSwgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy52YWxpZGF0ZUZpZWxkKGZpZWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhbiBpbmRpdmlkdWFsIGNvbnRleHQgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGQgTmFtZSBvZiBmaWVsZCB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm5zIEVycm9yIGZvdW5kIHdpdGggdGhpcyBmaWVsZCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZUZpZWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICAgIHZhciB2YWwgPSB0aGlzLmNvbnRleHRbZmllbGRdO1xuICAgICAgdmFyIG5hbWVGb3JFcnJvciA9IFwiZmllbGQgXCIuY29uY2F0KGZpZWxkKTtcblxuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAvLyBTdHJpbmdzIHdoaWNoIGNvdWxkIGJlIHVzZWQgYXMgcGFydGl0aW9uIGtleXMgKFwic2l0ZVwiIGFuZCBcInNlcnZpY2VOYW1lXCIpIGNhbm5vdCBjb250YWluIHNsYXNoZXMsIGluXG4gICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBvdGhlciByZXN0aWN0aW9ucyBiZWxvdy5cbiAgICAgICAgY2FzZSAnc2l0ZSc6XG4gICAgICAgIGNhc2UgJ3NlcnZpY2VOYW1lJzpcbiAgICAgICAgICBpZiAodmFsLmluZGV4T2YoJy8nKSA+IC0xKSByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gY29udGFpbiBvbmx5IHZhbGlkIGNoYXJhY3RlcnMsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWwsIFwiLiAgSXQgY2Fubm90IGNvbnRhaW4gYSBzbGFzaC5cIikpO1xuICAgICAgICAvLyBFbHNlIGZhbGwgdGhyb3VnaFxuICAgICAgICAvLyBTdHJpbmdzIGZvciBmaWVsZHMg4oCcc2l0ZeKAnSwg4oCcc2VydmljZU5hbWXigJ0sIOKAnG1ldGhvZE5hbWXigJ0sIOKAnG1ldHJpY0tleeKAnSBtdXN0IG1hdGNoIGJlIHZhbGlkIFBNRVQgZmllbGQgbmFtZXM6XG4gICAgICAgIC8vIG1heGltdW0gbGVuZ3RoIG9mIDI1Niwgb25seSBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgdGhlIGRvdCwgY29sb24sIGF0LXNpZ24sIHVuZGVyc2NvcmUsIGZvcndhcmQtc2xhc2gsXG4gICAgICAgIC8vIGFuZCBzbGFzaCBjaGFyYWN0ZXJzIChpbiBzaG9ydCB0aGUgcmVnZXggXltBLVphLXowLTkuOkBfLy1dKyQpLlxuXG4gICAgICAgIGNhc2UgJ21ldGhvZE5hbWUnOlxuICAgICAgICBjYXNlICdhY3Rpb25JZCc6XG4gICAgICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVTdHJpbmcuZGVmYXVsdCkodmFsLCBuYW1lRm9yRXJyb3IpO1xuXG4gICAgICAgIGNhc2UgJ2Nsb3VkV2F0Y2hEaW1lbnNpb25zJzpcbiAgICAgICAgICByZXR1cm4gKDAsIF92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zLmRlZmF1bHQpKHZhbCB8fCBbXSk7XG4gICAgICB9IC8vIE5vIGVycm9yIGZvdW5kLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZGVyIGNsYXNzIGZvciBLYXRhbE1ldHJpY3NDb250ZXh0XG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzQ29udGV4dDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNzQ29udGV4dDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljc0NvbnRleHQsIFwiQnVpbGRlclwiLCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfY2xhc3MyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIF9jbGFzczIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29udGV4dFwiLCB7fSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShfY2xhc3MyLCBbe1xuICAgIGtleTogXCJ3aXRoU2l0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU2l0ZShzaXRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc2l0ZSA9IHNpdGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFNlcnZpY2VOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTZXJ2aWNlTmFtZShzZXJ2aWNlTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0LnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aE1ldGhvZE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aE1ldGhvZE5hbWUobWV0aG9kTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0Lm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhBY3Rpb25JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQWN0aW9uSWQoYWN0aW9uSWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5hY3Rpb25JZCA9IGFjdGlvbklkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZXF1ZXN0SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFJlcXVlc3RJZChyZXF1ZXN0SWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aENsb3VkV2F0Y2hEaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhDbG91ZFdhdGNoRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gICAgICB0aGlzLmNvbnRleHQuY2xvdWRXYXRjaERpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYW55IHJlbGF0ZWQgbWV0cmljcyB3aXRoIHRoZSBnaXZlbiBsaXN0IChzZWUgYWRkUmVsYXRlZE1ldHJpY3MgdG8gYWRkIGluc3RlYWQgb2YgcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBSZWxhdGVkIG1ldHJpY3MgYXJlIG1ldHJpY3MgdGhhdCBhcmUgcHVibGlzaGVkIHdoZW5ldmVyIGEgbmV3IGFjdGlvbiBpcyBzdGFydGVkLiAgVGhleSBhcmUgdXNlZCB0byByZWxhdGUgdGhlXG4gICAgICogYWN0aW9uIGJhY2sgdG8gdGhlIGNvbnRleHQgd2hlcmUgaXQgaXMgaGFwcGVuaW5nLCBmb3IgZXhhbXBsZSBhIHJlcXVlc3QgSUQgb3IgYSB1c2VyIGlkZW50aXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0ZWRNZXRyaWNzIFJlbGF0ZWQgbWV0cmljcyB0byBwdWJsaXNoIHdoZW4gYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQgZm9yIHRoaXMgY29udGV4dFxuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVsYXRlZE1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MgPSByZWxhdGVkTWV0cmljcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWRkaXRpb25hbCByZWxhdGVkIG1ldHJpY3MgdG8gdGhpcyBidWlsZGVyLiAgU2VlIHdpdGhSZWxhdGVkTWV0cmljcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGVkTWV0cmljcyBBZGRpdGlvbmFsIHJlbGF0ZWQgbWV0cmljcyB0byBwdWJsaXNoIHdoZW4gYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQgZm9yIHRoaXMgY29udGV4dFxuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJlbGF0ZWRNZXRyaWNzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZWxhdGVkTWV0cmljcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICByZWxhdGVkTWV0cmljc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MgPSAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzLCByZWxhdGVkTWV0cmljcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyB3aXRoIHRoZSBnaXZlbiBsaXN0IChzZWUgYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gdG8gYWRkIGluc3RlYWQgb2YgcmVwbGFjZSxcbiAgICAgKiBhbmQgd2l0aFJlbGF0ZWRNZXRyaWNzIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHJlbGF0ZWQgbWV0cmljcykuXG4gICAgICpcbiAgICAgKiBTaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyBhcmUgcHVibGlzaGVkIHdoZW4gYSBuZXcgY2hpbGQgbWV0cmljIHB1Ymxpc2hlciBpcyBjcmVhdGVkLCBidXQgbm90IGluY2x1ZGVkIGFzXG4gICAgICogcmVsYXRlZCBtZXRyaWNzIGZvciB0aGUgbmV3IGNoaWxkIG1ldHJpYyBwdWJsaXNoZXIsIHNvIGFyZSBub3QgcHVibGlzaGVkIGFnYWluIGlmIHRoZSBjaGlsZCBtZXRyaWMgcHVibGlzaGVyXG4gICAgICogY3JlYXRlcyBncmFuZGNoaWxkIHB1Ymxpc2hlZCBtZXRyaWNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzXG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgbWV0cmljcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBtZXRyaWNzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9IG1ldHJpY3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFkZGl0aW9uYWwgc2luZ2xlLWFjdGlvbiByZWxhdGVkIG1ldHJpY3MgdG8gdGhpcyBidWlsZGVyLiAgU2VlIGFkZFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzXG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgbWV0cmljc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gPSAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uLCBtZXRyaWNzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBmaWVsZHMgc2V0IGluIHRoaXMgYnVpbGRlciBhbmQgdXNlIHRoZW0gdG8gY3JlYXRlIGEgbmV3IEthdGFsTWV0cmljc0NvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEthdGFsTWV0cmljc0NvbnRleHQgb2JqZWN0IGJ1aWx0IHdpdGggdGhlIHBhcmFtZXRlcnMgZ2l2ZW4gdG8gdGhpcyBidWlsZGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gX2NsYXNzMjtcbn0oKSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ1dWlkL3Y0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NDb250ZXh0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NDb250ZXh0XCIpKTtcblxudmFyIF9tZXRyaWNPYmplY3QgPSByZXF1aXJlKFwiLi9tZXRyaWNPYmplY3RcIik7XG5cbnZhciBfbWVyZ2VMaXN0cyA9IHJlcXVpcmUoXCIuL2hlbHBlci9tZXJnZUxpc3RzXCIpO1xuXG52YXIgX21ldHJpY3NFeHRlbnNpb24gPSByZXF1aXJlKFwiLi9oZWxwZXIvbWV0cmljc0V4dGVuc2lvblwiKTtcblxudmFyIF9lbWJlZFJlcXVlc3RJZCA9IHJlcXVpcmUoXCIuL2hlbHBlci9lbWJlZFJlcXVlc3RJZFwiKTtcblxudmFyIElOSVRJQUxJWkFUSU9OX01FVEhPRF9OQU1FID0gJ0luaXRpYWxpemF0aW9uJztcblxuLyoqXG4gKiBEZWZhdWx0IGVycm9yIGhhbmRsZXIgaWYgdGhlIHVzZXItc3VwcGxpZWQgZXJyb3IgaGFuZGxlciBmYWlscyBvciBpcyB1bnNldC5cbiAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzIHVzZXItcHJvdmlkZWQgZXJyb3IgaGFuZGxlciBtaXNiZWhhdmVzLlxuICovXG52YXIgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24gREVGQVVMVF9FUlJPUl9IQU5ETEVSKGVycikge1xuICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHVibGlzaGluZyBtZXRyaWNzOlwiKTtcbiAgY29uc29sZS5lcnJvcihlcnIpO1xufTtcblxudmFyIFBBUkVOVF9BQ1RJT05fSURfTkFNRSA9ICdwYXJlbnRBY3Rpb25JZCc7XG5cbnZhciBnZXRDb250ZXh0RmllbGRzID0gZnVuY3Rpb24gZ2V0Q29udGV4dEZpZWxkcyhjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0LmNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dC5jb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59O1xuLyoqXG4gKiBDbGFzcyB1c2VkIGZvciBwdWJsaXNoaW5nIG1ldHJpY3MgdG8gS2F0YWwuICBDb250YWlucyBhIGRyaXZlciBhbmQgYSBjb250ZXh0LlxuICpcbiAqIFRoaXMgY2xhc3Mga25vd3MgaG93IHRvIHB1Ymxpc2ggbWV0cmljcywgYW5kIGhvdyB0byBjcmVhdGUgbmV3IHB1Ymxpc2hlcnMgd2l0aCBhIG1vZGlmaWVkIGNvbnRleHQuXG4gKi9cblxuXG52YXIgS2F0YWxNZXRyaWNzUHVibGlzaGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBtZXRyaWNzIHB1Ymxpc2hlciB3aXRoIHRoZSBnaXZlbiBkcml2ZXIgYW5kIGNvbnRleHRcbiAgICpcbiAgICogQHBhcmFtIGRyaXZlciBTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY3NEcml2ZXIgdXNlZCB0byBwdWJsaXNoIHRoZSBtZXRyaWNzXG4gICAqIEBwYXJhbSBlcnJvckhhbmRsZXIgSGFuZGxlciBmb3IgZXJyb3JzIHRoYXQgb2NjdXIgd2hpbGUgdXNpbmcgdGhpcyBwdWJsaXNoZXJcbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBmb3IgdGhpcyBtZXRyaWNzIHB1Ymxpc2hlcjsgY29udGFpbnMgZGF0YSB0byBiZSBpbmNsdWRlZCB3aXRoIGV2ZXJ5XG4gICAqICAgICBtZXRyaWMgcHVibGlzaGVkIHVzaW5nIHRoaXMgcHVibGlzaGVyIG9iamVjdC4gIERlZmF1bHQgaXMgYW4gZW1wdHkgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc1B1Ymxpc2hlcihkcml2ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9FUlJPUl9IQU5ETEVSO1xuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCgpO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljc1B1Ymxpc2hlcik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjb21iaW5lZEVycm9ySGFuZGxlclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBfdGhpcy5lcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgIH0gY2F0Y2ggKG5leHRFcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIGVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobmV4dEVycik7XG4gICAgICAgIERFRkFVTFRfRVJST1JfSEFORExFUihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGEgY29tbW9uIGVycm9yXG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0LkJ1aWxkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkthdGFsTWV0cmljc0NvbnRleHQuQnVpbGRlciBvYmplY3QgcGFzc2VkIGluc3RlYWQgb2YgS2F0YWxNZXRyaWNzQ29udGV4dC4gIFRyeSBjYWxsaW5nIC5idWlsZCgpIG1ldGhvZC5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5kcml2ZXIgPSBkcml2ZXI7XG4gICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgdGhpcy5jb250ZXh0ID0gIShjb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCkgPyBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdChjb250ZXh0KSA6IGNvbnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhlIGVycm9yLWhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHVzZXIgd2hlbiB0aGlzIG9iamVjdCB3YXMgY29uc3RydWN0ZWQ7IGlmIHRoYXQgaXMgdW5zZXQgb3IgaXRzZWxmIHRocm93c1xuICAgKiBhbiBleGNlcHRpb24sIGNhbGxzIHRoZSBkZWZhdWx0IGVycm9yIGhhbmRsZXIgYXMgYSBmYWxsYmFjaywgd2hpY2ggd2lsbCBqdXN0IGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSBlcnIgRXJyb3Igb2JqZWN0IHRvIGhhbmRsZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc1B1Ymxpc2hlciwgW3tcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxpbmdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHdyYXAgYSBmdW5jdGlvbiBpbiB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb1RoZVRoaW5nIEZ1bmN0aW9uIHRvIHJ1biB1bmRlciB0aGUgd3JhcHBlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxpbmcoZG9UaGVUaGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvVGhlVGhpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGFsbCB0aGUgcmVsYXRlZCBtZXRyaWNzIG9mIGJhc2UgcHVibGlzaGVyIGFuZCBhZGRpdGlvbmFsQ29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJuIFJldHVybiBhbGwgcmVsYXRlZCBtZXRyaWNzIGZyb20gYmFzZSBwdWJsaXNoZXIgYW5kIGFkZGl0aW9uYWxDb250ZXh0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWRkaXRpb25hbFJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFkZGl0aW9uYWxSZWxhdGVkTWV0cmljcyhhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBhZGRpdGlvbmFsQ29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQgPyBhZGRpdGlvbmFsQ29udGV4dC5jb250ZXh0IDogYWRkaXRpb25hbENvbnRleHQ7XG4gICAgICB2YXIgYmFzZVJlbGF0ZWRNZXRyaWNzID0gdGhpcy5nZXRCYXNlUmVsYXRlZE1ldHJpY3MoKTtcbiAgICAgIHJldHVybiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykoYmFzZVJlbGF0ZWRNZXRyaWNzLCBuZXdDb250ZXh0LnJlbGF0ZWRNZXRyaWNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byByZXR1cm4gYWxsIHRoZSByZWxhdGVkIG1ldHJpY3Mgb2YgYmFzZSBwdWJsaXNoZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFJldHVybiBhbGwgcmVsYXRlZCBtZXRyaWNzIGZyb20gdGhlIGJhc2UgcHVibGlzaGVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VSZWxhdGVkTWV0cmljcygpIHtcbiAgICAgIHJldHVybiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LmNvbnRleHQucmVsYXRlZE1ldHJpY3MsIHRoaXMuY29udGV4dC5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCB0aGUgZ2l2ZW4gbWV0cmljIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGd1YXJhbnRlZWQgbmV2ZXIgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLiAgSWYgdGhlIG1ldHJpYyBvYmplY3Qgb3IgY29udGV4dCBhcmUgaW52YWxpZCxcbiAgICAgKiBvciBhbnkgb3RoZXIgZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBwdWJsaXNoaW5nLCB0aGUgcHVibGlzaGVyJ3MgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQuICBJZiB0aGVcbiAgICAgKiBwdWJsaXNoZXIncyBlcnJvciBoYW5kbGVyIGlzIHVuc2V0IG9yIGZhaWxzLCB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGlzIGNhbGxlZCAoc2VlIGRlZmF1bHRFcnJvckhhbmRsZXIpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGthdGFsTWV0cmljT2JqZWN0IE1ldHJpYyBvYmplY3QgdG8gcHVibGlzaFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoKGthdGFsTWV0cmljT2JqZWN0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy53aXRoRXJyb3JIYW5kbGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHVibGlzaCB1bmRlZmluZWQvbnVsbCBtZXRyaWMgb2JqZWN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9tZXRyaWNPYmplY3QuT2JqZWN0LlR5cGVzLkxpc3QgPT09IGthdGFsTWV0cmljT2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICBrYXRhbE1ldHJpY09iamVjdC5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICAgICAgX3RoaXMyLnB1Ymxpc2gobWV0cmljKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZHJpdmVyQ29udGV4dCA9IF90aGlzMi5jb250ZXh0LmRyaXZlckNvbnRleHQoKTtcblxuICAgICAgICAgIHZhciBjb250ZXh0RXJyb3IgPSBkcml2ZXJDb250ZXh0LnZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgICAgIGlmIChjb250ZXh0RXJyb3IpIHRocm93IGNvbnRleHRFcnJvcjtcbiAgICAgICAgICB2YXIgb2JqZWN0RXJyb3IgPSBrYXRhbE1ldHJpY09iamVjdC52YWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBpZiAob2JqZWN0RXJyb3IpIHRocm93IG9iamVjdEVycm9yO1xuICAgICAgICAgICgwLCBfbWV0cmljc0V4dGVuc2lvbi5kaXNwYXRjaE1ldHJpY0V2ZW50KShrYXRhbE1ldHJpY09iamVjdCwgZHJpdmVyQ29udGV4dCk7XG5cbiAgICAgICAgICBfdGhpczIuZHJpdmVyLnB1Ymxpc2goa2F0YWxNZXRyaWNPYmplY3QsIGRyaXZlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHB1Ymxpc2hlciB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhpcyBwdWJsaXNoZXIsIGJ1dCB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGZpZWxkcyBtZXJnZWQgaW50b1xuICAgICAqIHRoZSBuZXcgcHVibGlzaGVyJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZFB1Ymxpc2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZFB1Ymxpc2hlcihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NQdWJsaXNoZXIodGhpcy5kcml2ZXIsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLmNvbnRleHQubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgYWN0aW9uLCBhbmQgcmV0dXJuIGEgbmV3IHB1Ymxpc2hlciBmb3IgbWV0cmljcyByZWxhdGVkIHRvIHRoYXQgYWN0aW9uLlxuICAgICAqXG4gICAgICogQmVnaW5uaW5nIGEgbmV3IGFjdGlvbiBpbnZvbHZlcyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgICAqICAgMS4gR2VuZXJhdGUgYSBuZXcgYWN0aW9uSWQgZm9yIHRoZSBhY3Rpb24sIHJhbmRvbWx5IGluIHRoZSBicm93c2VyXG4gICAgICogICAyLiBJZiB0aGVyZSBhcmUgYW55IHJlbGF0ZWQgbWV0cmljcyBpbiB0aGUgY29udGV4dCwgcHVibGlzaCB0aGVtXG4gICAgICogICAzLiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBwdWJsaXNoZXIgd2l0aCB0aGlzIG9iamVjdCdzIGNvbnRleHQsIG1lcmdlZCB3aXRoIGFueSBhZGRpdGlvbmFsIGNvbnRleHQgZ2l2ZW4sXG4gICAgICogICAgICBtZXJnZWQgd2l0aCB0aGUgYWN0aW9uSWQgZ2VuZXJhdGVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICB2YXIgYWN0aW9uSWQgPSB0aGlzLl9nZW5lcmF0ZUFjdGlvbmlkKGFkZGl0aW9uYWxDb250ZXh0KTtcblxuICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmNvbnRleHQud2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkubWVyZ2Uoe1xuICAgICAgICBhY3Rpb25JZDogYWN0aW9uSWRcbiAgICAgIH0pLm1lcmdlKGFkZGl0aW9uYWxDb250ZXh0KTtcbiAgICAgIHZhciBuZXdQdWJsaXNoZXIgPSBuZXcgS2F0YWxNZXRyaWNzUHVibGlzaGVyKHRoaXMuZHJpdmVyLCB0aGlzLmVycm9ySGFuZGxlciwgbmV3Q29udGV4dCk7XG4gICAgICB2YXIgYWxsUmVsYXRlZE1ldHJpY3MgPSBhZGRpdGlvbmFsQ29udGV4dCAmJiAhKGFkZGl0aW9uYWxDb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdC5CdWlsZGVyKSA/IHRoaXMuZ2V0QWRkaXRpb25hbFJlbGF0ZWRNZXRyaWNzKGFkZGl0aW9uYWxDb250ZXh0KSA6IHRoaXMuZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCk7XG5cbiAgICAgIGlmIChhbGxSZWxhdGVkTWV0cmljcykge1xuICAgICAgICBhbGxSZWxhdGVkTWV0cmljcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICBuZXdQdWJsaXNoZXIucHVibGlzaChtZXRyaWMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1B1Ymxpc2hlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24sIGFuZCByZXR1cm4gYSBuZXcgcHVibGlzaGVyIGZvciBtZXRyaWNzIHJlbGF0ZWQgdG8gdGhhdCBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBBIGNoYWluZWQgYWN0aW9uIGlzIGhhbmRsZWQgdGhlIHNhbWUgd2F5IGFzIGluIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyLCBidXQgYWRkaXRpb25hbGx5LFxuICAgICAqIHRoZSByZXR1cm5lZCBwdWJsaXNoZXIgaGFzIGEgcmVsYXRlZE1ldHJpY05vSW5oZXJpdCBuYW1lZCBcInBhcmVudEFjdGlvbklkXCIsIHdpdGggdGhlIG5ld2x5XG4gICAgICogZ2VuZXJhdGVkIGFjdGlvbklkIGFzIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoZSBlZmZlY3Qgb2YgdGhpcyBpcyB0aGF0IGFueSBmdXJ0aGVyIGNoYWluZWQgY2hpbGQgYWN0aW9ucyBjYW4gYmUgY29ubmVjdGVkIGJhY2sgdG8gdGhpc1xuICAgICAqIGFjdGlvbiB0aHJvdWdoIHRoZSBwYXJlbnRBY3Rpb25JZCwgYW5kIHNvIG9uIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHZhciBhY3Rpb25JZCA9IHRoaXMuX2dlbmVyYXRlQWN0aW9uaWQoYWRkaXRpb25hbENvbnRleHQpO1xuXG4gICAgICB2YXIgcGFyZW50QWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShhY3Rpb25JZCwgdGhpcy5jb250ZXh0LmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIHZhciByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9IFtuZXcgX21ldHJpY09iamVjdC5TdHJpbmcoUEFSRU5UX0FDVElPTl9JRF9OQU1FLCBwYXJlbnRBY3Rpb25JZCldO1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCh7XG4gICAgICAgIGFjdGlvbklkOiBhY3Rpb25JZCxcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb246IHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlcihuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWRGb3JNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkRm9yTWV0aG9kKG1ldGhvZE5hbWUsIGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChtZXRob2ROYW1lLCBhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXIobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gZm9yIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uLiAgSXQgd2lsbCBhbHdheXMgaGF2ZSBhIG1ldGhvZE5hbWVcbiAgICAgKiBvZiBcIkluaXRpYWxpemF0aW9uXCI7IG90aGVyd2lzZSB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JJbml0aWFsaXphdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvckluaXRpYWxpemF0aW9uKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSwgYWRkaXRpb25hbENvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZyhuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBfbWV0cmljT2JqZWN0LlN0cmluZyhuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUsIHRydW5jYXRlZCB0byB0aGUgbWF4aW11bSBzaXplIGFsbG93ZWQgYnkgdGhlXG4gICAgICogc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgU3RyaW5nIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoU3RyaW5nVHJ1bmNhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZ1RydW5jYXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gbmV3IF9tZXRyaWNPYmplY3QuU3RyaW5nKG5hbWUsIHZhbHVlKTtcbiAgICAgIG9iamVjdC50cnVuY2F0ZSA9IHRydWU7XG4gICAgICB0aGlzLnB1Ymxpc2gob2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIENvdW50ZXIgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hDb3VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hDb3VudGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IF9tZXRyaWNPYmplY3QuQ291bnRlcihuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSB0aW1lciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFRpbWVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IF9tZXRyaWNPYmplY3QuVGltZXIobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBpc01vbml0b3IgZmxhZyBzZXQsIGFuZCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBDb3VudGVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoQ291bnRlck1vbml0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaENvdW50ZXJNb25pdG9yKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IF9tZXRyaWNPYmplY3QuQ291bnRlcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIHRpbWVyIHdpdGggdGhlIGlzTW9uaXRvciBmbGFnIHNldCwgYW5kIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJNb25pdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hUaW1lck1vbml0b3IobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMucHVibGlzaChuZXcgX21ldHJpY09iamVjdC5UaW1lcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB0byBleHRyYWN0IGFuIGFjdGlvbklkIGZyb20gYSBjb250ZXh0IGlmIG9uZSBpcyBwcm92aWRlZCwgYW5kIG90aGVyd2lzZSBnZW5lcmF0ZSBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBY3Rpb24gSUQgc3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVBY3Rpb25pZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVBY3Rpb25pZChjb250ZXh0KSB7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICB2YXIgZmllbGRzID0gZ2V0Q29udGV4dEZpZWxkcyhjb250ZXh0KTtcblxuICAgICAgICBpZiAoZmllbGRzLmFjdGlvbklkKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkcy5hY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF92LmRlZmF1bHQpKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NQdWJsaXNoZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljc1B1Ymxpc2hlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gdm9pZCAwO1xuXG52YXIgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24gREVGQVVMVF9FUlJPUl9IQU5ETEVSKGVycikge1xuICB0aHJvdyBlcnI7XG59O1xuXG5leHBvcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUiA9IERFRkFVTFRfRVJST1JfSEFORExFUjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBLYXRhbCBtZXRyaWNzIGRyaXZlci5cbiAqL1xudmFyIEthdGFsTWV0cmljc0RyaXZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0RyaXZlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NEcml2ZXIpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyLCBbe1xuICAgIGtleTogXCJwdWJsaXNoXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUHVibGlzaCB0aGUgZ2l2ZW4gbWV0cmljIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBlcnJvciBoYW5kbGVyIGFuZCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY09iamVjdCBNZXRyaWMgb2JqZWN0IHRvIHB1Ymxpc2guICBDb250YWlucyBtZXRyaWNLZXksIGlzTW9uaXRvciwgdHlwZSwgYW5kIHZhbHVlLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgZm9yIHB1Ymxpc2hpbmcgdGhpcyBtZXRyaWMuICBDb250YWlucyBhbGwgb3RoZXIgZmllbGRzIHRvIGJlIHB1Ymxpc2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWJsaXNoKG1ldHJpY09iamVjdCwgY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLYXRhbE1ldHJpY3NEcml2ZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MsIHBsZWFzZSBjaG9vc2UgYSBkcml2ZXIgYW5kIHVzZSB0aGF0IGluc3RlYWQnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0RyaXZlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNzRHJpdmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmlyc3RNYXA7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgbm9uLXVuZGVmaW5lZCB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSBydW5uaW5nIGVhY2ggdmFsdWVcbiAqIGluIHRoZSBnaXZlbiBhcnJheSB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gYXJyYXkgQW4gYXJyYXkgb2YgdmFsdWVzLlxuICogQHBhcmFtIG1hcHBlciBBIG1hcHBlciBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgbm9uLXVuZGVmaW5lZCB2YWx1ZSBmcm9tIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZpcnN0TWFwKGFycmF5LCBtYXBwZXIpIHtcbiAgdmFyIHRvUmV0dXJuID0gdW5kZWZpbmVkO1xuICBhcnJheS5zb21lKGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0b1JldHVybiA9IG1hcHBlcih2YWwpO1xuICAgIHJldHVybiB0b1JldHVybiAhPSBudWxsO1xuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufVxuXG47IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgb2JqZWN0VmFsdWVzID0gT2JqZWN0LnZhbHVlcyA/IE9iamVjdC52YWx1ZXMgOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn07XG52YXIgX2RlZmF1bHQgPSBvYmplY3RWYWx1ZXM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZVNpbXBsZUludDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG4vKipcbiAqIE51bWJlci5pc0ludGVnZXIgaXMgbm90IGluIElFMTEsIGFuZCBsZXR0aW5nIEJhYmVsIHBvbHlmaWxsIGl0IGFkZGVkIHRvbyBtdWNoIHdlaWdodC5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNJbnRlZ2VyXG4gKi9cbnZhciBpc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIodmFsKSB7XG4gIHJldHVybiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1ldHJpY3MgYXMgYW4gaW50ZWdlciAoQ291bnRlciBvciBUaW1lciksXG4gKiBhbmQgcmV0dXJuIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogQHBhcmFtIHZhbCBWYWx1ZSB0byBjaGVja1xuICogQHBhcmFtIG5hbWVGb3JFcnJvciBOYW1lIHRvIHVzZSB3aGVuIGNvbnN0cnVjdGluZyB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgbmVjZXNzYXJ5XG4gKiBAcmV0dXJucyBFcnJvciwgb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9yXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpbXBsZUludCh2YWwsIG5hbWVGb3JFcnJvcikge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gaGF2ZSB0eXBlICdudW1iZXInLCBidXQgaXQgd2FzIHR5cGUgJ1wiKS5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbCksIFwiJ1wiKSk7XG4gIH1cblxuICBpZiAodmFsIDwgMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBwb3NpdGl2ZSwgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCkpO1xuICB9IC8vIFRoaXMgd2lsbCBhbHNvIGNhdGNoIE5hTiBhbmQgSW5maW5pdHlcblxuXG4gIGlmICghaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgYW4gaW50ZWdlciwgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCkpO1xuICB9IC8vIENvdWxkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZVNpbXBsZVN0cmluZztcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgU0lNUExFX1NUUklOR19QQVQgPSAvXltBLVphLXowLTkuOkBfLy1dKyQvO1xudmFyIFNJTVBMRV9TVFJJTkdfTUFYX0xFTiA9IDEyNztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1ldHJpY3MgYXMgYSBmaWVsZCB2YWx1ZSxcbiAqIHN1Y2ggYXMgc2l0ZSwgc2VydmljZU5hbWUsIG1ldGhvZE5hbWUsIG9yIGFjdGlvbklkIChub3RlIHRoaXMgaXMgbm90IHVzZWQgdG8gY2hlY2sgdmFsdWVzIGZvciBzdHJpbmcgbWV0cmljcykuXG4gKiBJdCByZXR1cm5zIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogVG8gYmUgcHVibGlzaGVkLCBpdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZywgbGVzcyB0aGFuIDI1NiBjaGFyYWN0ZXJzLCBjb250YWluaW5nIG9ubHkgQVNDSUlcbiAqIGxldHRlcnMsIG51bWJlcnMsIG9yIHRoZXNlIGNoYXJhY3RlcnM6IC46QF8vLSAodGhvc2UgYXJlIHRoZSBQTUVUIGZpZWxkIHZhbHVlIHJlcXVpcmVtZW50cykuXG4gKlxuICogQHBhcmFtIHZhbCBTdHJpbmcgdmFsdWUgdG8gY2hlY2tcbiAqIEBwYXJhbSBuYW1lRm9yRXJyb3IgTmFtZSB0byB1c2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UsIGlmIG9uZSBpcyBnZW5lcmF0ZWRcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpbXBsZVN0cmluZyh2YWwsIG5hbWVGb3JFcnJvcikge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBhIHN0cmluZywgYnV0IGl0IHdhcyBhIFwiKS5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbCkpKTtcbiAgfVxuXG4gIGlmICh2YWwubGVuZ3RoID4gU0lNUExFX1NUUklOR19NQVhfTEVOKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIGxlc3MgdGhhbiBcIikuY29uY2F0KFNJTVBMRV9TVFJJTkdfTUFYX0xFTiwgXCIgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbC5sZW5ndGgsIFwiIGNoYXJhY3RlcnNcIikpO1xuICB9XG5cbiAgaWYgKHZhbC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIG5vbi1ibGFua1wiKSk7XG4gIH1cblxuICBpZiAoIVNJTVBMRV9TVFJJTkdfUEFULnRlc3QodmFsKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBjb250YWluIG9ubHkgdmFsaWQgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCwgXCIuICBJdCBjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIGFuZCB0aGVzZSBzeW1ib2xzOiAuOkBfLy1cIikpO1xuICB9IC8vIENvdWxkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVtYmVkUmVxdWVzdElkID0gZW1iZWRSZXF1ZXN0SWQ7XG5cbi8vIHVudGlsIHdlIGNhbiBhZGQgYSByZXF1ZXN0SWQgZmllbGQgdG8gdGhlIGFuZGVzIHNjaGVtYSB3ZSB3aWxsIGVtYmVkIGl0IGluIHRoZSBhY3Rpb25JZFxuZnVuY3Rpb24gZW1iZWRSZXF1ZXN0SWQoYWN0aW9uSWQsIHJlcXVlc3RJZCkge1xuICBpZiAocmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIFtyZXF1ZXN0SWQsIGFjdGlvbklkXS5qb2luKFwiOjpcIik7XG4gIH1cblxuICByZXR1cm4gYWN0aW9uSWQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tZXJnZUxpc3RzID0gbWVyZ2VMaXN0cztcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxuLy8gSGVscGVyIG1ldGhvZCB0byBtZXJnZSB0d28gbGlzdHMgd2hpY2ggY291bGQgYmUgdW5kZWZpbmVkXG4vLyBSZXR1cm5zIG1lcmdlZCBsaXN0cyBpZiBlaXRoZXIgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBpZiAobGlzdDEgfHwgbGlzdDIpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGxpc3QxIHx8IFtdKSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobGlzdDIgfHwgW10pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlzcGF0Y2hNZXRyaWNFdmVudCA9IGRpc3BhdGNoTWV0cmljRXZlbnQ7XG5cbi8qKlxuICogUHVibGlzaCB0byBleHRlcm5hbCBwYXJ0aWVzIHRoYXQgYXJlIFxuICogbGlzdGVuaW5nIGZvciBrYXRhbC5tZXRyaWNzLnB1Ymxpc2ggQ3VzdG9tIEV2ZW50c1xuICovXG5mdW5jdGlvbiBkaXNwYXRjaE1ldHJpY0V2ZW50KG1ldHJpYywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXNwYXRjaEN1c3RvbUV2ZW50KG1ldHJpYywgY29udGV4dCk7IC8vIGZvciBsZWdhY3kgcHVycG9zZXMsIGFsc28gcHVibGlzaCB0byBfX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX19cblxuICBwdWJsaXNoVG9NZXRyaWNzRXh0ZW5zaW9uKG1ldHJpYywgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ3VzdG9tRXZlbnQobWV0cmljLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgna2F0YWwubWV0cmljcy5wdWJsaXNoJywge1xuICAgIGRldGFpbDoge1xuICAgICAgbWV0cmljOiBtZXRyaWMsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LmdldEZpZWxkcygpXG4gICAgfVxuICB9KTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuLyoqXG4gKiBARGVwcmVjYXRlZFxuICogUHVibGlzaCB0byBodHRwczovL2NvZGUuYW1hem9uLmNvbS9wYWNrYWdlcy9LYXRhbE1ldHJpY3NFeHRlbnNpb25cbiAqIFRoZSBleHRlbnNpb24gaW5qZWN0cyBhIGdsb2JhbCBfX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX18gb2JqZWN0IHdpdGggYVxuICogYHB1Ymxpc2hgIG1ldGhvZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHB1Ymxpc2hUb01ldHJpY3NFeHRlbnNpb24obWV0cmljLCBjb250ZXh0KSB7XG4gIHZhciBleHRlbnNpb24gPSB3aW5kb3cuX19LQVRBTF9NRVRSSUNTX0VYVEVOU0lPTl9fO1xuXG4gIGlmIChleHRlbnNpb24pIHtcbiAgICBleHRlbnNpb24ucHVibGlzaChtZXRyaWMsIGNvbnRleHQuZ2V0RmllbGRzKCkpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9ucztcblxudmFyIF9GaXJzdE1hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRmlyc3RNYXBcIikpO1xuXG52YXIgUFJJTlRBQkxFX0FTQ0lJX1BBVFRFUk4gPSAvXltcXHgyMC1cXHg3RV0rJC87XG52YXIgQVRfTEVBU1RfT05FX05PTl9XSElURVNQQUNFX1BBVFRFUk4gPSAvXi4qXFxTKy4qJC87XG52YXIgRElNRU5TSU9OX05BTUVfU1RSSU5HX01BWF9MRU4gPSAyNTU7XG52YXIgRElNRU5TSU9OX1ZBTFVFX1NUUklOR19NQVhfTEVOID0gMTAyNDtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1vbml0b3JpbmcgYmFjay1lbmQuXG4gKiBJdCByZXR1cm5zIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogVG8gYmUgcHVibGlzaGVkLCBuYW1lIGFuZCB2YWx1ZSBvZiBzdHJpbmcgbWV0cmljcyBtdXN0IGZvbGxvdyByZXN0cmljdGlvbnMgYXMgZGVzY3JpYmVkIGJ5XG4gKiBDbG91ZFdhdGNoIERpbWVuc2lvbiBBUEkgRG9jdW1lbnRhdGlvbjpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25DbG91ZFdhdGNoL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0RpbWVuc2lvbi5odG1sXG4gKlxuICogQHBhcmFtIGRpbWVuc2lvbnMgQXJyYXkgb2Ygc3RyaW5nIG1ldHJpY3MgdG8gY2hlY2tcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgcmV0dXJuICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkoZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbWVuc2lvbikge1xuICAgIHZhciBuYW1lID0gZGltZW5zaW9uLm5hbWUsXG4gICAgICAgIHZhbHVlID0gZGltZW5zaW9uLnZhbHVlO1xuICAgIHJldHVybiB2YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb24obmFtZSwgdmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbiBpcyB2YWxpZCBhcyBkZXNjcmliZWQgYnkgQ2xvdWRXYXRjaCBkb2N1bWVudGF0aW9uLlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkNsb3VkV2F0Y2gvbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfRGltZW5zaW9uLmh0bWxcbiAqXG4gKiBAcGFyYW0gbmFtZSBDbG91ZFdhdGNoIERpbWVuc2lvbiBOYW1lIFN0cmluZyB0byBjaGVja1xuICogQHBhcmFtIHZhbHVlIENsb3VkV2F0Y2ggRGltZW5zaW9uIFZhbHVlIFN0cmluZyB0byBjaGVja1xuICogQHJldHVybnMgRXJyb3IsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvclxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9uKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChuYW1lLmxlbmd0aCA+IERJTUVOU0lPTl9OQU1FX1NUUklOR19NQVhfTEVOKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIERpbWVuc2lvbiBuYW1lIGZvciB2YWx1ZSBcIi5jb25jYXQodmFsdWUsIFwiIHRvIGJlIFwiKS5jb25jYXQoRElNRU5TSU9OX05BTUVfU1RSSU5HX01BWF9MRU4sIFwiIGNoYXJhY3RlcnMgb3IgbGVzcywgYnV0IGl0IHdhcyBcIikuY29uY2F0KG5hbWUubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzXCIpKTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIG5hbWUgZm9yIHZhbHVlIFwiLmNvbmNhdCh2YWx1ZSwgXCIgdG8gYmUgbm9uLWJsYW5rXCIpKTtcbiAgfVxuXG4gIGlmICghUFJJTlRBQkxFX0FTQ0lJX1BBVFRFUk4udGVzdChuYW1lKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gbmFtZSBmb3IgdmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiB0byBjb250YWluIG9ubHkgQVNDSUkgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KG5hbWUpKTtcbiAgfVxuXG4gIGlmICghQVRfTEVBU1RfT05FX05PTl9XSElURVNQQUNFX1BBVFRFUk4udGVzdChuYW1lKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gbmFtZSBmb3IgdmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiB0byBjb250YWluIGF0IGxlYXN0IG9uZSBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdChuYW1lKSk7XG4gIH1cblxuICBpZiAobmFtZS5zdGFydHNXaXRoKFwiOlwiKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gbmFtZSBmb3IgdmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiB0byBub3Qgc3RhcnQgd2l0aCBhIGNvbG9uIChcXFwiOlxcXCIpLCBidXQgaXQgd2FzIFwiKS5jb25jYXQobmFtZSkpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmxlbmd0aCA+IERJTUVOU0lPTl9WQUxVRV9TVFJJTkdfTUFYX0xFTikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gdmFsdWUgZm9yIG5hbWUgXCIuY29uY2F0KG5hbWUsIFwiIHRvIGJlIFwiKS5jb25jYXQoRElNRU5TSU9OX1ZBTFVFX1NUUklOR19NQVhfTEVOLCBcIiBjaGFyYWN0ZXJzIG9yIGxlc3MsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWx1ZS5sZW5ndGgsIFwiIGNoYXJhY3RlcnNcIikpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIHZhbHVlIGZvciBuYW1lIFwiLmNvbmNhdChuYW1lLCBcIiB0byBiZSBub24tYmxhbmtcIikpO1xuICB9XG5cbiAgaWYgKCFQUklOVEFCTEVfQVNDSUlfUEFUVEVSTi50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gdmFsdWUgZm9yIG5hbWUgXCIuY29uY2F0KG5hbWUsIFwiIHRvIGNvbnRhaW4gb25seSBBU0NJSSBjaGFyYWN0ZXJzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsdWUpKTtcbiAgfVxuXG4gIGlmICghQVRfTEVBU1RfT05FX05PTl9XSElURVNQQUNFX1BBVFRFUk4udGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIHZhbHVlIGZvciBuYW1lIFwiLmNvbmNhdChuYW1lLCBcIiB0byBjb250YWluIGF0IGxlYXN0IG9uZSBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWx1ZSwgXCJ9XCIpKTtcbiAgfSAvLyBDb3VsZG4ndCBmaW5kIGFueXRoaW5nIHdyb25nLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG91ZFdhdGNoRGltZW5zaW9uc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQ2xvdWRXYXRjaERpbWVuc2lvbnMuQ2xvdWRXYXRjaERpbWVuc2lvbnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udGV4dFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9ySGFuZGxlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfRXJyb3JIYW5kbGVyLkVycm9ySGFuZGxlcjtcbiAgfVxufSk7XG5leHBvcnRzLk1ldHJpYyA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1ldHJpY3NEcml2ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc0RyaXZlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlB1Ymxpc2hlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNzUHVibGlzaGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgTWV0cmljID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWV0cmljT2JqZWN0XCIpKTtcblxuZXhwb3J0cy5NZXRyaWMgPSBNZXRyaWM7XG5cbnZhciBfS2F0YWxNZXRyaWNzUHVibGlzaGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NQdWJsaXNoZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0NvbnRleHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc0NvbnRleHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0RyaXZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZHJpdmVyL0thdGFsTWV0cmljc0RyaXZlclwiKSk7XG5cbnZhciBfRXJyb3JIYW5kbGVyID0gcmVxdWlyZShcIi4vZHJpdmVyL0Vycm9ySGFuZGxlclwiKTtcblxudmFyIF9DbG91ZFdhdGNoRGltZW5zaW9ucyA9IHJlcXVpcmUoXCIuL3R5cGVzL0Nsb3VkV2F0Y2hEaW1lbnNpb25zXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlSW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlSW50XCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQ291bnRlciB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgYW4gZXZlbnQgaGFwcGVuZWQgb24gYSBwYWdlLCBvciBhcyBhIHNpbXBsZSAxLzAgY291bnRlciB0byB0cmFja1xuICogc3VjY2VzcyBhbmQgZmFpbHVyZS5cbiAqL1xudmFyIEthdGFsTWV0cmljQ291bnRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljQ291bnRlcik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjb3VudGVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBDb3VudGVyIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIENvdW50ZXIgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljQ291bnRlcihuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljQ291bnRlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAqXG4gICAqIEByZXR1cm4gQ291bnRlciB2YWx1ZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IHZhbHVlIGZvciB0aGlzIGNvdW50ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRoaXMgY291bnRlclxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgLy8gTWF0aC5yb3VuZCB3aWxsIGFsc28gY29lcmNlIGZyb20gYSBzdHJpbmcgaWYgbmVjZXNzYXJ5LCBhbmQgcmV0dXJuIE5hTiBpZiBpbnZhbGlkXG4gICAgICB0aGlzLl92YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0eXBlIGZvciB0aGlzIGNvdW50ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIFwiQ291bnRlclwiLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdC5UeXBlcy5Db3VudGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBudW1iZXIgdG8gdGhpcyBjb3VudGVyLlxuICAgICAqXG4gICAgICogQ2FuIGFsc28gYmUgbmVnYXRpdmUgdG8gc3VidHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkVmFsdWUgQW1vdW50IHRvIGFkZCB0byB0aGlzIGNvdW50ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoYWRkVmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgKz0gYWRkVmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNDb3VudGVyLnByb3RvdHlwZSksIFwidmFsaWRhdGlvbkVycm9yXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VwZXJFcnJvcikgcmV0dXJuIHN1cGVyRXJyb3I7XG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZUludC5kZWZhdWx0KSh0aGlzLnZhbHVlLCBcImZpZWxkIHZhbHVlIGluIENvdW50ZXIgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJ1wiKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY0NvdW50ZXI7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljQ291bnRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljU3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogU3RhbmRhcmRpemVkIG1ldHJpYyBmb3IgaW5zdHJ1bWVudGluZyBIVFRQIHJlcXVlc3RzLlxuICpcbiAqIFVuZGVyIHRoZSBob29kIGl0IGlzIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgbmFtZSB5b3UgcHJvdmlkZSBwcmVmaXhlZCB3aXRoIFwiSFRUUFJlcXVlc3QuXCIuXG4gKiBUaGF0IG9iamVjdCB3aWxsIGNvbnRhaW4gYSBtZXRyaWMgc3VmZml4ZWQgd2l0aCBcIi5MYXRlbmN5XCIgZm9yIHRoZSBsYXRlbmN5IG9mIHRoaXMgcmVxdWVzdCwgYW5kIGEgbWV0cmljIHN1ZmZpeGVkXG4gKiB3aXRoIFwiLkZhaWx1cmVcIiB0byByZWNvcmQgdGhlIGZhaWx1cmUgb3Igc3VjY2VzcyBvZiB0aGlzIHJlcXVlc3QuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgcmVxdWVzdCB3aWxsIGJlIHRyYWNrZWQgYXMgYSBmYWlsdXJlOyB0byBtYXJrIGl0IGFzIGEgc3VjY2VzcyBjYWxsIHRoZSBcInNldFN1Y2Nlc3MoKVwiIG1ldGhvZC5cbiAqXG4gKiBJdCBoYXMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdoaWNoIHdpbGwgYmUgZW1pdHRlZCBpZiBzZXQ7IHNlZSB1cmwsIHN0YXR1c0NvZGUsIGFuZCBzdGF0dXNUZXh0LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgZ2F2ZSB0aGUgbmFtZSBcIlNlYXJjaFwiLCB0aGVzZSBtZXRyaWNzIHdpbGwgYmUgY3JlYXRlZDpcbiAqICAgSFRUUFJlcXVlc3QuU2VhcmNoLkxhdGVuY3kgLSBMYXRlbmN5IGZvciB0aGlzIHJlcXVlc3RcbiAqICAgSFRUUFJlcXVlc3QuU2VhcmNoLkZhaWx1cmUgLSBGYWlsdXJlIGZvciB0aGlzIHJlcXVlc3QgKDEgZm9yIGZhaWx1cmUsIDAgZm9yIHN1Y2Nlc3MpXG4gKi9cbnZhciBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lZEF0dGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgX0thdGFsTWV0cmljVGltZWRBdHRlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljSHR0cFJlcXVlc3QpO1xuXG4gIC8qKiBUaGUgcHJlZml4IGZvciB0aGlzIG1ldHJpYy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgVVJMIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSBjb2RlIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSB0ZXh0IG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEhUVFAgUmVxdWVzdCB0aW1lZCBhdHRlbXB0IG1ldHJpYyBpbmNvcnBvcmF0aW5nIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBUaGUgbmFtZSB5b3UgZ2l2ZSB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZSBwcmVmaXhlZCB3aXRoIFwiSFRUUFJlcXVlc3QuXCIuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBtZXRyaWM7IHJlc3VsdGluZyBtZXRyaWNzIHdpbGwgcHJlZml4IHRoaXMgbmFtZSB3aXRoIFwiSFRUUFJlcXVlc3QuXCJcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljSHR0cFJlcXVlc3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljSHR0cFJlcXVlc3QpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LkhUVFBfUkVRVUVTVF9QUkVGSVgsIFwiLlwiKS5jb25jYXQobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHVybCBmb3IgdGhpcyBtZXRyaWMuXG4gICAqXG4gICAqIEEgc3RyaW5nIG1ldHJpYyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHB1Ymxpc2hlZCBmb3IgdGhpcyBtZXRyaWMuICBJdHMgbmFtZSB3aWxsXG4gICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5VUkwnLCBhbmQgaXRzIHZhbHVlIHdpbGwgYmUgdGhlIFVSTCB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVVJMIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFVSTCBmb3IgdGhpcyBtZXRyaWMsIGlmIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBVUkwgZm9yIHRoaXMgbWV0cmljLCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgVVJMIG1ldHJpYyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIFVSTCBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJsTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQSBzdHJpbmcgbWV0cmljIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IHdpbGwgYmUgcHVibGlzaGVkIGZvciB0aGlzIG1ldHJpYy4gIEl0cyBuYW1lIHdpbGxcbiAgICAgKiBiZSB0aGlzIG1ldHJpY3MgbmFtZSBzdWZmaXhlZCB3aXRoICcuU3RhdHVzQ29kZScsIGFuZCBpdHMgdmFsdWUgd2lsbCBiZSB0aGUgc3RhdHVzIGNvZGUgdmFsdWUgZ2l2ZW4gaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzQ29kZVwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX0NPREVfU1VGRklYLCBfS2F0YWxNZXRyaWNTdHJpbmcuZGVmYXVsdCwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNDb2RlTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBBIHN0cmluZyBtZXRyaWMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlzdCBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSBwdWJsaXNoZWQgZm9yIHRoaXMgbWV0cmljLiAgSXRzIG5hbWUgd2lsbFxuICAgICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5TdGF0dXNUZXh0JywgYW5kIGl0cyB2YWx1ZSB3aWxsIGJlIHRoZSBzdGF0dXMgdGV4dCB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1c1RleHQgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMsIG9yIHVuZGVmaW5lZCB0byByZW1vdmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c1RleHRcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19URVhUX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzVGV4dE1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNIdHRwUmVxdWVzdDtcbn0oX0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0O1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJIVFRQX1JFUVVFU1RfUFJFRklYXCIsICdIVFRQUmVxdWVzdCcpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJVUkxfU1VGRklYXCIsICdVUkwnKTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFwiU1RBVFVTX0NPREVfU1VGRklYXCIsICdTdGF0dXNDb2RlJyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIlNUQVRVU19URVhUX1NVRkZJWFwiLCAnU3RhdHVzVGV4dCcpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZWRBdHRlbXB0XCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogU3RhbmRhcmRpemVkIG1ldHJpYyBmb3IgaW5zdHJ1bWVudGluZyBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbi5cbiAqXG4gKiBVbmRlciB0aGUgaG9vZCBpdCBpcyBhIEthdGFsTWV0cmljVGltZWRBdHRlbXB0IHdpdGggdGhlIG5hbWUgXCJJbml0aWFsaXphdGlvblwiLlxuICogVGhhdCBvYmplY3Qgd2lsbCBjb250YWluIGEgbWV0cmljIHN1ZmZpeGVkIHdpdGggXCIuTGF0ZW5jeVwiIGZvciB0aGUgbGF0ZW5jeSBvZiB0aGlzIHJlcXVlc3QsIGFuZCBhIG1ldHJpYyBzdWZmaXhlZFxuICogd2l0aCBcIi5GYWlsdXJlXCIgdG8gcmVjb3JkIHRoZSBmYWlsdXJlIG9yIHN1Y2Nlc3Mgb2YgdGhpcyByZXF1ZXN0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlIHJlcXVlc3Qgd2lsbCBiZSB0cmFja2VkIGFzIGEgZmFpbHVyZTsgdG8gbWFyayBpdCBhcyBhIHN1Y2Nlc3MgY2FsbCB0aGUgXCJzZXRTdWNjZXNzKClcIiBtZXRob2QuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlc2UgbWV0cmljcyB3aWxsIGJlIGNyZWF0ZWQ6XG4gKiAgIEluaXRpYWxpemF0aW9uLkxhdGVuY3kgLSBMYXRlbmN5IGZvciBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvblxuICogICBJbml0aWFsaXphdGlvbi5GYWlsdXJlIC0gRmFpbHVyZSBmb3IgdGhpcyBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbiAoMSBmb3IgZmFpbHVyZSwgMCBmb3Igc3VjY2VzcylcbiAqL1xudmFyIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY1RpbWVkQXR0ZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLCBfS2F0YWxNZXRyaWNUaW1lZEF0dGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbik7XG5cbiAgLyoqIFRoZSBuYW1lIGZvciB0aGlzIG1ldHJpYy4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVkIGF0dGVtcHQgbWV0cmljIG5hbWVkIFwiSW5pdGlhbGl6YXRpb25cIiwgZm9yIHJlY29yZGluZyBsYXRlbmN5IGFuZCBmYWlsdXJlIGluZm9ybWF0aW9uIGFib3V0XG4gICAqIHlvdXIgYXBwbGljYXRpb24ncyBpbml0aWFsaXphdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24oKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbik7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24uSU5JVElBTElaRV9NRVRSSUNfTkFNRSk7XG4gIH1cblxuICByZXR1cm4gS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbjtcbn0oX0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiwgXCJJTklUSUFMSVpFX01FVFJJQ19OQU1FXCIsICdJbml0aWFsaXphdGlvbicpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3RMaXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdExpc3RcIikpO1xuXG52YXIgX09iamVjdFZhbHVlc1BvbnlmaWxsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL09iamVjdFZhbHVlc1BvbnlmaWxsXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogTWV0cmljIG9iamVjdCBsaXN0IHRoYXQgdHJhY2tzIG1ldHJpY3MgYnkgbmFtZSwgYW5kIGdlbmVyYXRlcyBtZXRyaWNzIHByZWZpeGVkIHdpdGggdGhlIG5hbWUgb2YgdGhpcyBvYmplY3QuXG4gKi9cbnZhciBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0TGlzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBfS2F0YWxNZXRyaWNPYmplY3RMaXMpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbmFtZWQgb2JqZWN0IGxpc3QuXG4gICAqXG4gICAqIFRoZSBuYW1lIGdpdmVuIGhlcmUgd2lsbCBiZSB1c2VkIHRvIHByZWZpeCBhbGwgbWV0cmljcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGlzIG1ldHJpY1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QobmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIF90aGlzLm5hbWVkTWV0cmljcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBbe1xuICAgIGtleTogXCJtZXRyaWNMaXN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF9PYmplY3RWYWx1ZXNQb255ZmlsbC5kZWZhdWx0KSh0aGlzLm5hbWVkTWV0cmljcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIG1ldHJpYyB3aXRoIHRoZSBnaXZlbiBuYW1lIHdpdGggYSBuZXcgbWV0cmljIGdlbmVyYXRlZCBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXRyaWMgc3VwcG9ydHMgbW9uaXRvcmluZywgaXRzIGlzTW9uaXRvciBmbGFnIHdpbGwgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBjb250YWluaW5nIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHBhcmFtIG1ldHJpY0NyZWF0b3IgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIGZ1bGwgbmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKiAgICAgICAgYW5kIHJldHVybnMgYSBuZXdseSBjb25zdHJ1Y3RlZCBLYXRhbE1ldHJpY09iamVjdCB3aXRoIHRoaXMgbmFtZSBhbmQgYW4gYXBwcm9wcmlhdGUgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5hbWVkTWV0cmljKHN1Yk5hbWUsIG1ldHJpY0NyZWF0b3IpIHtcbiAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuZ2V0TmFtZUZvclN1Yk1ldHJpYyhzdWJOYW1lKTtcbiAgICAgIHZhciBtZXRyaWMgPSBtZXRyaWNDcmVhdG9yKGZ1bGxOYW1lKTtcblxuICAgICAgaWYgKG1ldHJpYy5jYW5Nb25pdG9yKSB7XG4gICAgICAgIG1ldHJpYy5pc01vbml0b3IgPSB0aGlzLmlzTW9uaXRvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV0gPSBtZXRyaWM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbCwgZGVsZXRlIHRoZSBtZXRyaWMgd2l0aCB0aGUgZ2l2ZSBuYW1lOyBvdGhlcndpc2UgaWYgdGhlIGdpdmVuIG5hbWVkXG4gICAgICogbWV0cmljIGFscmVhZHkgZXhpc3RzIHVwZGF0ZSBpdHMgdmFsdWU7IG90aGVyd2lzZSBjcmVhdGUgYSBuZXcgbWV0cmljIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBzZXQgaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBzcGVjaWFsaXplZCBoZWxwZXIgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIGRlYWwgd2l0aCB0aGUgY29tbW9uIGNhc2Ugb2YgYSB2YWx1ZSBzZXR0ZXIgaW4gYSBtb3JlIGNvbXBsZXhcbiAgICAgKiBtZXRyaWMuICBPdXRzaWRlIG9mIHN1YmNsYXNzZXMsIG90aGVyIG1ldGhvZHMgd2lsbCBwcm9iYWJseSBwcm92ZSBtb3JlIHVzZWZ1bC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBudWxsIHRoZSBtZXRyaWMgd2lsbCBhbHNvIGJlIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIG1ldHJpYyB0byBjcmVhdGUgb3IgZGVsZXRlXG4gICAgICogQHBhcmFtIG5ld1ZhbHVlQ2xhc3MgQ2xhc3Mgb2YgbmV3IG1ldHJpYyB0byBjcmVhdGVcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIG1ldHJpYyAob3IgdW5kZWZpbmVkIHRvIGRlbGV0ZSB0aGUgbWV0cmljKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShzdWJOYW1lLCBuZXdWYWx1ZUNsYXNzLCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZU5hbWVkTWV0cmljKHN1Yk5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuZ2V0T3JDcmVhdGVOYW1lZE1ldHJpYyhzdWJOYW1lLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgbmV3VmFsdWVDbGFzcyhuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtZXRyaWMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdWItbWV0cmljIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdXNlIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgbWV0cmljIGFuZFxuICAgICAqIHN0b3JlIGFuZCByZXR1cm4gdGhhdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHBhcmFtIG1ldHJpY0NyZWF0b3IgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIGZ1bGwgbmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKiAgICAgICAgYW5kIHJldHVybnMgYSBuZXdseSBjb25zdHJ1Y3RlZCBLYXRhbE1ldHJpY09iamVjdCB3aXRoIHRoaXMgbmFtZSBhbmQgYW4gYXBwcm9wcmlhdGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIE1ldHJpYyBvYmplY3Qgd2hpY2ggd2FzIHJldHJpZXZlZCBvciBjcmVhdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPckNyZWF0ZU5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yQ3JlYXRlTmFtZWRNZXRyaWMoc3ViTmFtZSwgbWV0cmljQ3JlYXRvcikge1xuICAgICAgaWYgKCF0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXSkge1xuICAgICAgICB0aGlzLnNldE5hbWVkTWV0cmljKHN1Yk5hbWUsIG1ldHJpY0NyZWF0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZ2l2ZW4gbmFtZWQgc3ViLW1ldHJpYywgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIHtLYXRhbE1ldHJpY09iamVjdCB8IHVuZGVmaW5lZH0gTWV0cmljIG9iamVjdCB3aXRoIHRoaXMgbmFtZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVkTWV0cmljKHN1Yk5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBnaXZlbiBuYW1lZCBzdWItbWV0cmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZU5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZU5hbWVkTWV0cmljKHN1Yk5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG1ldHJpYywgb3IgdW5kZWZpbmVkIGlmIHRoZSBtZXRyaWMgZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEByZXR1cm4gVmFsdWUgZm9yIHRoZSBnaXZlbiBtZXRyaWMsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbWV0cmljIGRvZXMgbm90IGV4aXN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lZE1ldHJpY1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVkTWV0cmljVmFsdWUoc3ViTmFtZSkge1xuICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuZ2V0TmFtZWRNZXRyaWMoc3ViTmFtZSk7XG4gICAgICBpZiAoIW1ldHJpYykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBtZXRyaWMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgbmFtZSBmb3IgdGhlIGdpdmVuIHN1Yi1tZXRyaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEByZXR1cm4gRnVsbCBuYW1lIGZvciB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVGb3JTdWJNZXRyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZUZvclN1Yk1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIi5cIikuY29uY2F0KHN1Yk5hbWUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3Q7XG59KF9LYXRhbE1ldHJpY09iamVjdExpc3QuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1R5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBzaW5nbGUgbWV0cmljIGluIEthdGFsLlxuICpcbiAqIEEgc2luZ2xlIG1ldHJpYyBjb250YWlucyB0aGUgbmFtZSAobWV0cmljS2V5KSwgdmFsdWUsIHR5cGUsIGFuZCB0aGUgaXNNb25pdG9yIGZsYWc7IGV2ZXJ5dGhpbmcgZWxzZSBpcyBpbiB0aGVcbiAqIEthdGFsTWV0cmljc0NvbnRleHQgaXQgaXMgcHVibGlzaGVkIHRvLlxuICovXG52YXIgS2F0YWxNZXRyaWNPYmplY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTWV0cmljIHR5cGVzLlxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEthdGFsTWV0cmljT2JqZWN0IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgbWV0cmljOyBwdWJsaXNoZWQgYXMgbWV0cmljS2V5IGZpZWxkXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY09iamVjdChuYW1lKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNPYmplY3QpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2lzTW9uaXRvciA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgZm9yIHRoaXMgbWV0cmljLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIG5hbWUgaXMgaW1tdXRhYmxlLCBhbmQgdGhpcyBjYW5ub3QgYmUgc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyBOYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBbe1xuICAgIGtleTogXCJuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBOYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWV0cmljS2V5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBtZXRyaWMsIGFuZCByZXR1cm5zIHRoaXMgb2JqZWN0IGZvciBjb250aW51ZWQgdXNlLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGRldGVybWluZXMgaWYgdGhlIG1ldHJpYyBjYW4gYmUgdXNlZCBmb3IgZGFzaGJvYXJkcyBhbmQgYWxhcm1zIChpLmUuIGlmIGl0IHdpbGwgYmUgcHVibGlzaGVkIHRvIFBNRVQpXG4gICAgICogQHBhcmFtIGlzTW9uaXRvciBOZXcgdmFsdWUgZm9yIHRoZSBpc01vbml0b3IgZmxhZzsgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAqIEByZXR1cm5zIFRoaXMgb2JqZWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoTW9uaXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoTW9uaXRvcigpIHtcbiAgICAgIHZhciBpc01vbml0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB0aGlzLmlzTW9uaXRvciA9IGlzTW9uaXRvcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBmb3JjZWQgdG8gYSBib29sZWFuIGJhc2VkIG9uIGl0cyB0cnV0aGluZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzTW9uaXRvciBOZXcgdmFsdWUgZm9yIHRoZSBpc01vbml0b3IgZmxhZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNNb25pdG9yXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybnMgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc01vbml0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbWV0cmljIGNhbiBiZSBtZWFuaW5nZnVsbHkgbW9uaXRvcmVkLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBtZXRyaWMgY2FuIGJlIG1lYW5pbmdmdWxseSBtb25pdG9yZWRcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoaXNNb25pdG9yKSB7XG4gICAgICB0aGlzLl9pc01vbml0b3IgPSAhIWlzTW9uaXRvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY09iamVjdCBtdXN0IGltcGxlbWVudCBjYW5Nb25pdG9yJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVHlwZSBvZiB0aGlzIG1ldHJpYyAob25lIG9mOiBTdHJpbmcsIENvdW50ZXIsIFRpbWVyLCBMaXN0KVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY09iamVjdCBtdXN0IGltcGxlbWVudCB0eXBlIGdldHRlcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgYSB2YWxpZGF0aW9uIGVycm9yIG9uIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZCBpZiBvbmUgaXMgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RXJyb3IgfCB1bmRlZmluZWR9IEVycm9yIGZvdW5kIHdpdGggdGhpcyBvYmplY3QsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvciBpcyBmb3VuZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIGlmICh0aGlzLmlzTW9uaXRvciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0aGlzLmlzTW9uaXRvciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGaWVsZCBpc01vbml0b3Igc2hvdWxkIGJlIGEgYm9vbGVhbiwgYnV0IGl0IHdhcyBhIFwiLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGhpcy5pc01vbml0b3IpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmRlZmF1bHQpKHRoaXMubmFtZSwgJ2ZpZWxkIG5hbWUnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY09iamVjdDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBcIlR5cGVzXCIsIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfRmlyc3RNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvRmlyc3RNYXBcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRyaWMgdGhhdCBjb250YWlucyBhIGxpc3Qgb2Ygb3RoZXIgbWV0cmljczsgd2hlbiBpdCBpcyBwdWJsaXNoZWQsIHRoZSBsaXN0IG9mIG1ldHJpY3MgaXMgcmV0cmlldmVkLCBhbmQgYWxsXG4gKiBhcmUgcHVibGlzaGVkLlxuICovXG52YXIgS2F0YWxNZXRyaWNPYmplY3RMaXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNPYmplY3RMaXN0LCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNPYmplY3RMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEthdGFsTWV0cmljT2JqZWN0TGlzdC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBmb3IgdGhpcyBtZXRyaWMuICBOb3QgcmVhbGx5IHVzZWQsIGJ1dCBwcmVzZW50IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIG1ldHJpY3MuXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY09iamVjdExpc3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljT2JqZWN0TGlzdCk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgZm9yIHRoaXMgb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIG1ldHJpY3MgZm9yIHRoaXMgb2JqZWN0XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNPYmplY3RMaXN0LCBbe1xuICAgIGtleTogXCJtZXRyaWNMaXN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzIG9mIEthdGFsTWV0cmljT2JqZWN0TGlzdCBtdXN0IGltcGxlbWVudCBtZXRyaWNMaXN0IGdldHRlcicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc01vbml0b3JcIixcbiAgICBnZXQ6IC8vIFRoaXMganVzdCBkZWxlZ2F0ZXMgdG8gdGhlIHN1cGVyY2xhc3MsIGJ1dCBpZiB3ZSBvdmVycmlkZSB0aGUgc2V0dGVyIHdpdGhvdXQgb3ZlcnJpZGluZyB0aGUgZ2V0dGVyXG4gICAgLy8gZ2V0dGluZyB0aGUgcHJvcGVydHkgd2lsbCBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCB0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGlzTW9uaXRvcikge1xuICAgICAgKDAsIF9zZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCBpc01vbml0b3IsIHRoaXMsIHRydWUpO1xuICAgICAgdGhpcy5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICBpZiAobWV0cmljLmNhbk1vbml0b3IpIHtcbiAgICAgICAgICBtZXRyaWMuaXNNb25pdG9yID0gaXNNb25pdG9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYW55IG9mIHRoZSBjb250YWluZWQgbWV0cmljcyBhcmUgaW52YWxpZCwgcmV0dXJuIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkOyBvdGhlcndpc2UgcmV0dXJuXG4gICAgICogdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaXNuJ3QgY2FsbGVkIGJ5IHRoZSBwdWJsaXNoZXI7IGl0IHZhbGlkYXRlcyBlYWNoIHN1Yi1tZXRyaWMgb24gaXRzIG93bi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVycm9yIGZvdW5kIHdpdGggc3VibWV0cmljLCBpZiBhbnk7IGVsc2UgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgLy8gRG9lc24ndCBtYWtlIHNlbnNlIHRvIGNoZWNrIHN1cGVyY2xhc3MgZXJyb3IgaGVyZSwgc2luY2UgaXQgaXMgdGhlIGNvbnRhaW5lZCBtZXRyaWNzIHRoYXQgbWF0dGVyLlxuICAgICAgcmV0dXJuICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkodGhpcy5tZXRyaWNMaXN0LCBmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgIHJldHVybiBtZXRyaWMudmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0TGlzdDtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFN0cmluZyB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIHN0b3JlIGFyYml0cmFyeSBzdHJpbmdzIG9mIGRhdGEuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1N0cmluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNTdHJpbmcpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFN0cmluZyBuYW1lXG4gICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljU3RyaW5nKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNTdHJpbmcpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJ0cnVuY2F0ZVwiLCBmYWxzZSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3RyaW5nIG1ldHJpYy5cbiAgICpcbiAgICogQHJldHVybiBWYWx1ZSBmb3IgdGhpcyBtZXRyaWNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZywgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzdHJpbmcgbWV0cmljLlxuICAgICAqXG4gICAgICogVGhlIG5ldyB2YWx1ZSBzaG91bGQgYmUgYSBzdHJpbmcsIGJ1dCBudW1iZXIgYW5kIGJvb2xlYW4gdHlwZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBzdHJpbmdzLlxuICAgICAqIEZvciBvdGhlciB0eXBlcywgaW5jbHVkaW5nIHVuZGVmaW5lZCBhbmQgbnVsbCwgdGhlIHZhbHVlIHdpbGwgYmUgYWNjZXB0ZWQsIGJ1dCB3aWxsIGZhaWwgdmFsaWRhdGlvbiB3aGVuIHB1Ymxpc2hpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGlvbiBmbGFnIGZvciB0aGlzIHN0cmluZyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBJZiBzZXQsIHRoZSB2YWx1ZSBoZXJlIHdpbGwgYmUgYXV0b21hdGljYWxseSB0cnVuY2F0ZWQgdG8gdGhlIG1heGltdW0gc2l6ZSBhbGxvd2VkIGJ5IHRoZSBjdXJyZW50IHNjaGVtYS5cbiAgICAgKiBPdGhlcndpc2UsIHNlbmRpbmcgYSB2YWx1ZSBsYXJnZXIgdGhhbiBhbGxvd2VkIHdpbGwgcmVzdWx0IGluIGEgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnVlIHRvIGF1dG9tYXRpY2FsbHkgdHJ1bmNhdGUgbWV0cmljcywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHR5cGUgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIlN0cmluZ1wiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuU3RyaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5Nb25pdG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgc3VwZXJFcnJvciA9ICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZy5wcm90b3R5cGUpLCBcInZhbGlkYXRpb25FcnJvclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN1cGVyRXJyb3IpIHJldHVybiBzdXBlckVycm9yO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBmaWVsZCB2YWx1ZSBpbiBTdHJpbmcgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJyB0byBiZSB0eXBlIHN0cmluZywgYnV0IGl0IHdhcyBcIikuY29uY2F0KCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh0aGlzLnZhbHVlKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiBLYXRhbE1ldHJpY1N0cmluZy5NQVhfU0laRSkge1xuICAgICAgICBpZiAodGhpcy50cnVuY2F0ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cmluZygwLCBLYXRhbE1ldHJpY1N0cmluZy5NQVhfU0laRSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIGZpZWxkIHZhbHVlIGluIFN0cmluZyBtZXRyaWNzIG9iamVjdCAnXCIuY29uY2F0KHRoaXMubmFtZSwgXCInIHRvIGJlIFwiKS5jb25jYXQoS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUsIFwiIGNoYXJhY3RlcnMgb3IgbGVzcywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHRoaXMudmFsdWUubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRGlkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY1N0cmluZztcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNTdHJpbmc7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZywgXCJNQVhfU0laRVwiLCAyNTYpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY0NvdW50ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljQ291bnRlclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIE1ldHJpYyB0aGF0IHBhaXJzIGEgdGltZXIgYW5kIGEgZmFpbHVyZSBjb3VudGVyIHRvIHJlY29yZCB0aGUgdGltZSBhbmQgc3RhdHVzIG9mIGFuIGF0dGVtcHQgdG8gZG8gc29tZXRoaW5nLlxuICovXG52YXIgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY05hbWVkT2JqZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgX0thdGFsTWV0cmljTmFtZWRPYmplKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljVGltZWRBdHRlbXB0KTtcblxuICAvKiogVGhlIHN1Yi1tZXRyaWMgbmFtZSBmb3IgbGF0ZW5jeS4gKi9cblxuICAvKiogVGhlIHN1Yi1tZXRyaWMgbmFtZSBmb3IgZmFpbHVyZSBjb3VudC4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVkIGF0dGVtcHQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBUaGlzIHdpbGwgY3JlYXRlIHR3byBpbm5lciBtZXRyaWNzLCBhIEthdGFsTWV0cmljQ291bnRlciB0aGF0IGhhcyB0aGUgZ2l2ZW4gbmFtZSB3aXRoIFwiLkZhaWx1cmVcIiBhcHBlbmRlZCxcbiAgICogYW5kIGEgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCB0aGF0IGhhcyB0aGUgZ2l2ZW4gbmFtZSB3aXRoIFwiLkxhdGVuY3lcIiBhcHBlbmRlZC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGlzIGF0dGVtcHRcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljVGltZWRBdHRlbXB0KG5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcblxuICAgIF90aGlzLnNldE5hbWVkTWV0cmljKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LkxBVEVOQ1lfU1VGRklYLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBfS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5kZWZhdWx0KG5hbWUpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuc2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuRkFJTFVSRV9TVUZGSVgsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IF9LYXRhbE1ldHJpY0NvdW50ZXIuZGVmYXVsdChuYW1lLCAxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBmYWlsdXJlIGNvdW50ZXIgbWV0cmljIGJhc2VkIG9uIHRoZSBnaXZlbiBmYWlsdXJlIHN0YXR1cy5cbiAgICpcbiAgICogSWYgZmFpbHVyZSBpcyB0cnVlIHRoZSBjb3VudGVyIHdpbGwgaGF2ZSBhIHZhbHVlIG9mIDE7IGlmIGl0IGlzIGZhbHNlIHRoZSBjb3VudGVyIHdpbGwgaGF2ZSBhIHZhbHVlIG9mIDAuXG4gICAqXG4gICAqIEBwYXJhbSBmYWlsdXJlIFdoZXRoZXIgdGhpcyBpcyBhIGZhaWx1cmUgb3Igbm90OyBkZWZhdWx0IHRydWVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgW3tcbiAgICBrZXk6IFwic2V0RmFpbHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGYWlsdXJlKCkge1xuICAgICAgdmFyIGZhaWx1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB2YXIgZmFpbHVyZUNvdW50ID0gZmFpbHVyZSA/IDEgOiAwO1xuICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuZmFpbHVyZU1ldHJpYztcbiAgICAgIG1ldHJpYy52YWx1ZSA9IGZhaWx1cmVDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmYWlsdXJlIHN0YXR1cyB0byBmYWxzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3VjY2VzcygpIHtcbiAgICAgIHRoaXMuc2V0RmFpbHVyZShmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGF0ZW5jeSBtZXRyaWMgdG8gdGhlIGdpdmVuIHZhbHVlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBOb3RlIHlvdSBkb24ndCBub3JtYWxseSBoYXZlIHRvIHNldCB0aGlzLCB0aGUgdW5kZXJseWluZyBtZXRyaWMgaXMgYSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoIHRoYXQgd2lsbCBzdGFydFxuICAgICAqIGFuZCBzdG9wIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0ZW5jeU1zIExhdGVuY3kgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRMYXRlbmN5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExhdGVuY3kobGF0ZW5jeU1zKSB7XG4gICAgICB2YXIgbWV0cmljID0gdGhpcy5sYXRlbmN5TWV0cmljO1xuICAgICAgbWV0cmljLnZhbHVlID0gbGF0ZW5jeU1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRpbWVyIHN0b3B3YXRjaCBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGltZXIgc3RvcHdhdGNoIG1ldHJpYyBmb3IgdGhpcyBhdHRlbXB0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsYXRlbmN5TWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5MQVRFTkNZX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmFpbHVyZSBjb3VudGVyIG1ldHJpYyBmb3IgdGhpcyBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQHJldHVybiBGYWlsdXJlIGNvdW50ZXIgbWV0cmljIGZvciB0aGlzIGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWlsdXJlTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5GQUlMVVJFX1NVRkZJWCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdDtcbn0oX0thdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LCBcIkxBVEVOQ1lfU1VGRklYXCIsICdMYXRlbmN5Jyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgXCJGQUlMVVJFX1NVRkZJWFwiLCAnRmFpbHVyZScpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZUludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9WYWxpZGF0ZVNpbXBsZUludFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFRpbWVyIHR5cGUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gcmVjb3JkIGEgdGltZS4gIFRoaXMgY2xhc3MgcmVxdWlyZXMgZXhwbGljaXQgdmFsdWU7IHNlZSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoIGZvciBhdXRvbWF0aWNcbiAqIHRpbWluZy5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNUaW1lcik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lciBtZXRyaWMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoZSBtZXRyaWNcbiAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNUaW1lcihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljVGltZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgdGltZXJcbiAgICpcbiAgICogQHJldHVybiBUaW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBbe1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHRpbWVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHRpbWVyIHZhbHVlIGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE1hdGgucm91bmQgd2lsbCBhbHNvIGNvZXJjZSBmcm9tIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeSwgYW5kIHJldHVybiBOYU4gaWYgaW52YWxpZFxuXG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHlwZSBmb3IgdGhpcyB0aW1lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHJldHVybnMgXCJUaW1lclwiLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdC5UeXBlcy5UaW1lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgc3VwZXJFcnJvciA9ICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLnByb3RvdHlwZSksIFwidmFsaWRhdGlvbkVycm9yXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VwZXJFcnJvcikgcmV0dXJuIHN1cGVyRXJyb3I7XG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZUludC5kZWZhdWx0KSh0aGlzLnZhbHVlLCBcImZpZWxkIHZhbHVlIGluIFRpbWVyIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIidcIikpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lcjtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0XCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFN1YmNsYXNzIG9mIEthdGFsTWV0cmljVGltZXIgdGhhdCBjYW4gYmUgc3RhcnRlZCBhbmQgc3RvcHBlZCwgYW5kIHdpbGwgcmVjb3JkIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiBzdGFydGluZyBhbmRcbiAqIHN0b3BwaW5nLiAgQnkgZGVmYXVsdCBpdCB3aWxsIHN0YXJ0IHdoZW4gdGhlIG9iamVjdCBpcyBjcmVhdGVkLCBhbmQgc3RvcHBlZCB3aGVuIHRoZSB2YWx1ZSBpcyByZXRyaWV2ZWQgd2l0aFxuICogdGhlIGdldHRlciBcInZhbHVlXCIuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLCBfS2F0YWxNZXRyaWNUaW1lcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHN0YXJ0aW5nIHRpbWUuICBJZiBubyBzdGFydGluZyB0aW1lIGlzIGdpdmVuLCB0aGUgY3VycmVudCB0aW1lIGlzIHVzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgdGltZXJcbiAgICogQHBhcmFtIHN0YXJ0VGltZSBNaWxsaXNlY29uZCBlcG9jaCB0aW1lIGZvciB0aGUgc3RhcnQgdGltZTsgZGVmYXVsdHMgdG8gbm93XG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKG5hbWUsIHN0YXJ0VGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgdW5kZWZpbmVkKTtcblxuICAgIF90aGlzLnN0YXJ0KHN0YXJ0VGltZSk7XG5cbiAgICBfdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZS1zdGFydCB0aW1lciB3aXRoIHRoZSBnaXZlbiBzdGFydCB0aW1lLCBvciB0aGUgY3VycmVudCB0aW1lIGlmIG5vbmUgaXMgZ2l2ZW4uXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgV2hlbiB0aGUgdGltZXIgd2FzIHN0YXJ0ZWQsIGluIGVwb2NoIG1pbGxpc2Vjb25kczsgZGVmYXVsdHMgdG8gbm93XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCwgW3tcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBzdGFydFRpbWUgfHwgdGhpcy5ub3coKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgdGltZXIgYW5kIHJlY29yZCB0aGUgZWxhcHNlZCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3BUaW1lIFdoZW4gdGhlIHRpbWVyIHdhcyBzdG9wcGVkLCBpbiBlcG9jaCBtaWxsaXNlY29uZHM7IGRlZmF1bHRzIHRvIG5vd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKHN0b3BUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWUgPSBzdG9wVGltZSB8fCB0aGlzLm5vdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgdGltZXIgaGFzIGJlZW4gc3RvcHBlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRpbWVyIGhhcyBiZWVuIHN0b3BwZWQgeWV0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1N0b3BwZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHdoZW4gdGhlIHRpbWVyIHdhcyBzdGFydGVkIGFuZCBzdG9wcGVkOyBpZiB0aGUgdGltZXIgaGFzIG5vdCB5ZXQgYmVlbiBzdG9wcGVkLFxuICAgICAqIHN0b3AgaXQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFbGFwc2VkIHRpbWUgYmV0d2VlbiB3aGVuIHRpbWVyIHdhcyBzdGFydGVkIGFuZCBzdG9wcGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0gLy8gUmVseSBvbiBzdXBlci52YWx1ZSBzZXR0ZXIgdG8gcm91bmRcblxuXG4gICAgICAgICgwLCBfc2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcy5zdG9wVGltZSAtIHRoaXMuc3RhcnRUaW1lLCB0aGlzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3aGVuIHRoaXMgdGltZXIgd2FzIHN0YXJ0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFN0YXJ0IHRpbWUsIGluIGVwb2NoIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgICxcbiAgICBzZXQ6XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBtZXRyaWMuICBOb3RlIHRoaXMgd2lsbCBvdmVycmlkZSB0aGUgc3RvcHdhdGNoIGJlaGF2aW9yIGFuZCBqdXN0IHVzZSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAoMCwgX3NldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5wcm90b3R5cGUpLCBcInZhbHVlXCIsIHZhbHVlLCB0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgd2hlbiB0aGlzIHRpbWVyIHdhcyBzdG9wcGVkIChvciB1bmRlZmluZWQgaWYgaXQgaXMgc3RpbGwgcnVubmluZylcbiAgICAgKlxuICAgICAqIEByZXR1cm4gU3RvcCB0aW1lLCBpbiBlcG9jaCBtaWxsc2Vjb25kcywgb3IgdW5kZWZpbmVkIGlmIHRoZSBzdG9wd2F0Y2ggaXMgc3RpbGwgcnVubmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFRpbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2g7XG59KF9LYXRhbE1ldHJpY1RpbWVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyoqXG4gKiBNZXRyaWMgdHlwZXMuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1R5cGU7XG5cbihmdW5jdGlvbiAoS2F0YWxNZXRyaWNUeXBlKSB7XG4gIEthdGFsTWV0cmljVHlwZVtcIlN0cmluZ1wiXSA9IFwiU3RyaW5nXCI7XG4gIEthdGFsTWV0cmljVHlwZVtcIkNvdW50ZXJcIl0gPSBcIkNvdW50ZXJcIjtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiVGltZXJcIl0gPSBcIlRpbWVyXCI7XG4gIEthdGFsTWV0cmljVHlwZVtcIkxpc3RcIl0gPSBcIkxpc3RcIjtcbn0pKEthdGFsTWV0cmljVHlwZSB8fCAoS2F0YWxNZXRyaWNUeXBlID0ge30pKTtcblxuO1xudmFyIF9kZWZhdWx0ID0gS2F0YWxNZXRyaWNUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ291bnRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNDb3VudGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cFJlcXVlc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljSHR0cFJlcXVlc3QuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbml0aWFsaXphdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9iamVjdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJpbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZWRBdHRlbXB0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXJTdG9wd2F0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2guZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNTdHJpbmdcIikpO1xuXG52YXIgX0thdGFsTWV0cmljQ291bnRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNDb3VudGVyXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb25cIikpO1xuXG52YXIgX0thdGFsTWV0cmljSHR0cFJlcXVlc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljSHR0cFJlcXVlc3RcIikpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHR3byBJSUZFcyB0aGF0IHRoZSBTdXNoaSBsaWJyYXJ5IGNvbnRhaW5zLiBBIGZha2UgQ1NNIGFuZCBXaW5kb3cgb2JqZWN0IGFyZSBjcmVhdGVkIGFuZCBwcm92aWRlZFxuICogdG8gdGhlIGZ1bmN0aW9ucyBzbyB0aGF0IHRoZXkgYWN0dWFsbHkgZXhlY3V0ZSBpbiBhIGNvbnRyb2xsZWQgZW52aXJvbm1lbnQgYXdheSBmcm9tIGFueSBDU00gY29kZSB0aGF0IG1pZ2h0IGJlIGV4ZWN1dGluZ1xuICogYXQgdGhlIHBsYXRmb3JtIGxldmVsIHdpdGhpbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgYmFzaWMgcnVuIG9yZGVyIGlzIHRoZSBmb2xsb3dpbmc6XG4gKiAxLiBCdWlsZCB0aGUgbW9jayBDU00gb2JqZWN0LCB0aGVuIGJ1aWxkIGEgbW9jayBXaW5kb3cgb2JqZWN0IHRoYXQgcmVmZXJlbmNlcyB0aGUgQ1NNIG9iamVjdCBhcyB1ZV9jc21cbiAqIDIuIFJ1biB0aGUgdHJhbnNwb3J0YXRpb24tY2xpZW50cy5qcyBTY3JpcHQgZnJvbSBTdXNoaUphdmFzY3JpcHRDbGllbnQgcHJvdmlkaW5nIHRoZSBtb2Nrcy4gSXQgd2lsbCBtb2RpZnkgZ2xvYmFscyBvbiB0aGUgbW9jayBvYmplY3RzLlxuICogMy4gUnVuIHRoZSBzdXNoaS1jbGllbnQuanMgc2NyaXB0IGZyb20gU3VzaGlKYXZhU2NyaXB0Q2xpZW50IHByb3ZpZGluZyB0aGUgbW9ja3MuIEl0IHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBzdXNoaSBjbGllbnQgYW5kIGluamVjdCBpdCBpbnRvIHRoZSBDU00gZ2xvYmFscyBpbiB0aGUgbW9ja3MuXG4gKiA0LiB3aGVuZXZlciBldmVudCgpIGlzIGNhbGxlZCwgcmVmZXIgdG8gdGhlIGVuY2Fwc3VsYXRlZCBjc20gb2JqZWN0IHRvIGFkZCB0aGUgZXZlbnQgdG8gdGhlIHF1ZXVlLlxuICovXG52YXIgU3VzaGlDbGllbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdXNoaUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlU3VzaGlVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU3VzaGlVcmwocmVnaW9uLCBzb3VyY2VHcm91cCkge1xuICAgICAgaWYgKCFzb3VyY2VHcm91cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXNoaSBEcml2ZXIgd2FzIG5vdCBwcm92aWRlZCB3aXRoIGEgc291cmNlIGdyb3VwLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbWFpbjtcblxuICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLk5BOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktbmFcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuRVU6XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1ldVwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3VzaGlDbGllbnQuUkVHSU9OUy5GRTpcbiAgICAgICAgICBkb21haW4gPSBcInVuYWdpLWZlXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLkNOOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktY25cIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCByZWdpb24gJ1wiLmNvbmNhdChyZWdpb24sIFwiJyBwcm92aWRlZCB0byBTdXNoaUNsaWVudC5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJodHRwczovL1wiLmNvbmNhdChkb21haW4sIFwiLmFtYXpvbi5jb20vMS9ldmVudHMvXCIpLmNvbmNhdChzb3VyY2VHcm91cCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNzbVVzZXJDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNzbVVzZXJDb250ZXh0KHN1c2hpVXJsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGhpUHJpRmx1c2hJbnRlcnZhbDogMTAwMCxcbiAgICAgICAgbG93UHJpRmx1c2hJbnRlcnZhbDogMTAwMDAsXG4gICAgICAgIHJlcXVlc3RJZDogXCIxXCIsXG4gICAgICAgIGVycm9yQ2hhbm5lbDogXCJqc2VyclwiLFxuICAgICAgICBzZXNzaW9uU3RvcmFnZVdyYXBwZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3JIYW5kbGVyRnVuY3Rpb246IGNvbnNvbGUubG9nLFxuICAgICAgICBzdXNoaVVybDogc3VzaGlVcmxcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdXNoaSBDbGllbnQgZm9yIGEgcmVnaW9uIGFuZCBzb3VyY2UgZ3JvdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gUmVnaW9uIGluIFN1c2hpQ2xpZW50LlJFR0lPTlNcbiAgICAgKiBAcGFyYW0gc291cmNlR3JvdXAgU3VzaGkgRWVsIHNvdXJjZSBncm91cFxuICAgICAqIEBwYXJhbSBlcnJvckhhbmRsZXIgRXJyb3IgaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgQ1NNIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICogQHBhcmFtIGNsaWVudE92ZXJyaWRlIEFuIG9wdGlvbmFsIHRyYW5zcG9ydGF0aW9uIGNsaWVudCBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBjbGllbnRzIChuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBhbmQgWERvbWFpblJlcXVlc3Qgb3IgWE1MSHR0cFJlcXVlc3QpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJSRUdJT05TXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBOQTogXCJOQVwiLFxuICAgICAgICBFVTogXCJFVVwiLFxuICAgICAgICBGRTogXCJGRVwiLFxuICAgICAgICBDTjogXCJDTlwiXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFN1c2hpQ2xpZW50KCkge1xuICAgIHZhciByZWdpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFN1c2hpQ2xpZW50LlJFR0lPTlMuTkE7XG4gICAgdmFyIHNvdXJjZUdyb3VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICB2YXIgY2xpZW50T3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTdXNoaUNsaWVudCk7XG4gICAgdmFyIHN1c2hpVXJsID0gU3VzaGlDbGllbnQuY3JlYXRlU3VzaGlVcmwocmVnaW9uLCBzb3VyY2VHcm91cCk7XG4gICAgdmFyIGNzbVVzZXJDb250ZXh0ID0gU3VzaGlDbGllbnQuY3JlYXRlQ3NtVXNlckNvbnRleHQoc3VzaGlVcmwsIG9wdGlvbnMpO1xuICAgIHRoaXMudWVfY3NtID0gdGhpcy5zZXR1cE1vY2tDU01PYmplY3QoY3NtVXNlckNvbnRleHQpO1xuICAgIHRoaXMuZW5jYXBzdWxhdGVkV2luZG93ID0gdGhpcy5zZXR1cE1vY2tXaW5kb3codGhpcy51ZV9jc20pO1xuICAgIHRoaXMudHJhbnNwb3J0YXRpb25DbGllbnRDb2RlKHRoaXMudWVfY3NtLCB3aW5kb3cpO1xuXG4gICAgaWYgKGNsaWVudE92ZXJyaWRlKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5fc0JjbiA9IHtcbiAgICAgICAgaXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZW5kcG9pbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICBjbGllbnRPdmVycmlkZShlbmRwb2ludCwgcGF5bG9hZCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnRDb2RlKHRoaXMudWVfY3NtLCB0aGlzLmVuY2Fwc3VsYXRlZFdpbmRvdyk7XG4gICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdXNoaUNsaWVudCwgW3tcbiAgICBrZXk6IFwiZXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnQoZGF0YSwgcHJvZHVjZXJJZCwgc2NoZW1hSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlN1c2hpQ2xpZW50IHdyYXBwZXIgcHVibGlzaGluZyB0aGUgZm9sbG93aW5nOlwiLCB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBwcm9kdWNlcklkOiBwcm9kdWNlcklkLFxuICAgICAgICAgIHNjaGVtYUlkOiBzY2hlbWFJZCxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy51ZV9jc20udWUuZXZlbnQoZGF0YSwgcHJvZHVjZXJJZCwgc2NoZW1hSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgcGxhbiB0byBlbWl0IDEwMDAgb3IgbW9yZSBldmVudHMgcGVyIGluc3RhbnRpYXRlZCBjbGllbnQsXG4gICAgICogY2FsbCByZXNldCBhZnRlciBjYWxsaW5nIGV2ZW50IHRvIGFsbG93IHRoZSBDU00gY2xpZW50IHRvIGNvbnRpbnVlIHNlbmRpbmcgZXZlbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5ldmVudC5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQganVzdCBiZWZvcmUgZWFjaCB0aW1lIG1ldHJpY3MgYXJlXG4gICAgICogZmx1c2hlZCB0byB0aGUgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IHN1c2hpIHdpbGwgY2FsbCBiZWZvcmUgZmx1c2hlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uU3VzaGlGbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1c2hpRmx1c2goY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLm9uU3VzaGlGbHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFnZSB1bmxvYWRzLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2VuZCBhbnkgZmluYWwgbWV0cmljcyB0byBzdXNoaSwgc3VjaCBhcyBwYWdlIHZpc2l0XG4gICAgICogZHVyYXRpb24gb3IgYmF0Y2hlZCBjb3VudGVycy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IHN1c2hpIHdpbGwgY2FsbCBiZWZvcmUgdW5sb2FkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25TdXNoaVVubG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1c2hpVW5sb2FkKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5vblN1c2hpVW5sb2FkKGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBNb2NrQ1NNT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwTW9ja0NTTU9iamVjdChjc21Vc2VyQ29udGV4dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGV4ZWNTdHViID0gZnVuY3Rpb24gZXhlY1N0dWIoY2FsbGJhY2ssIGF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgIH07XG5cbiAgICAgIHZhciBldmVudFN0dWIgPSBmdW5jdGlvbiBldmVudFN0dWIobG9nLCBwcm9kdWNlciwgZXZlbnRUeXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlN1c2hpQ2xpZW50IENTTSBzdHViIGNhbGxlZCBpbiB1bnN1cHBvcnRlZCBtYW5uZXI6IGV2ZW50KClcIik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGxvZ0V2ZW50LCBjaGFubmVsKSB7XG4gICAgICAgIGlmIChfdGhpcy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICBfdGhpcy5lcnJvckhhbmRsZXIobG9nRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkIGluIFN1c2hpQ2xpZW50IGNoYW5uZWwgXCIgKyBjaGFubmVsLCBsb2dFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBhdHRhY2hIYW5kbGVyID0gZnVuY3Rpb24gYXR0YWNoSGFuZGxlcihldnQsIGhhbmRsZXIsIGNvbnRhaW5lcikge1xuICAgICAgICAvL1RPRE8gbWlnaHQgYmUgYWJsZSB0byBqdXN0IHVzZSB3aW5kb3cudWUuYXR0YWNoP1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgd2luZG93OyAvL29rIHRvIHVzZSByZWFsIHdpbmRvdyBnbG9iYWwgaGVyZS5cblxuICAgICAgICBpZiAod2luZG93LkV2ZW50VGFyZ2V0ICYmIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUgJiYgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyLmNhbGwoY29udGFpbmVyLCBldnQsIGhhbmRsZXIsICEhd2luZG93LnVlX2NsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsICEhd2luZG93LnVlX2NsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgY29udGFpbmVyLmF0dGFjaEV2ZW50KFwib25cIiArIGV2dCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVlX2hwc2k6IGNzbVVzZXJDb250ZXh0LmhpUHJpRmx1c2hJbnRlcnZhbCxcbiAgICAgICAgdWVfbHBzaTogY3NtVXNlckNvbnRleHQubG93UHJpRmx1c2hJbnRlcnZhbCxcbiAgICAgICAgdWU6IHtcbiAgICAgICAgICBzc3c6IGNzbVVzZXJDb250ZXh0LnNlc3Npb25TdG9yYWdlV3JhcHBlcixcbiAgICAgICAgICBsb2c6IGVycm9ySGFuZGxlcixcbiAgICAgICAgICBleGVjOiBleGVjU3R1YixcbiAgICAgICAgICBldmVudDogZXZlbnRTdHViLFxuICAgICAgICAgIGF0dGFjaDogYXR0YWNoSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICB1ZUxvZ0Vycm9yOiBjc21Vc2VyQ29udGV4dC5lcnJvckhhbmRsZXJGdW5jdGlvbixcbiAgICAgICAgdWVfc3VybDogY3NtVXNlckNvbnRleHQuc3VzaGlVcmwsXG4gICAgICAgIHVlX2lkOiBjc21Vc2VyQ29udGV4dC5yZXF1ZXN0SWQsXG4gICAgICAgIHVlX2Vycl9jaGFuOiBjc21Vc2VyQ29udGV4dC5lcnJvckNoYW5uZWxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwTW9ja1dpbmRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cE1vY2tXaW5kb3codWVfY3NtKSB7XG4gICAgICAvL2FwcGFyZW50bHkgY2Fubm90IHJlZiB0aGUgc2V0VGltZW91dCBmdW5jdGlvbiBkaXJlY3RseSBpbiBzb21lIGJyb3dzZXJzIHNvIHdlIGhhdmUgdG8gd3JhcCBpdC5cbiAgICAgIHZhciB0aW1lb3V0V3JhcHBlciA9IGZ1bmN0aW9uIHRpbWVvdXRXcmFwcGVyKGZuLCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZW91dCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1ZV9jc206IHVlX2NzbSxcbiAgICAgICAgdWVMb2dFcnJvcjogdWVfY3NtLnVlTG9nRXJyb3IsXG4gICAgICAgIHVlOiB1ZV9jc20udWUsXG4gICAgICAgIHNldFRpbWVvdXQ6IHRpbWVvdXRXcmFwcGVyXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2RlIHdpdGhpbiBmdW5jdGlvbiBwdWxsZWQgZGlyZWN0bHkgZnJvbVxuICAgICAqIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL1N1c2hpSmF2YVNjcmlwdENsaWVudC9ibG9icy9tYWlubGluZS8tLS9qYXZhc2NyaXB0L3N1c2hpLWNsaWVudC5qc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xpZW50Q29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGllbnRDb2RlKHVlX2NzbSwgd2luZG93KSB7XG4gICAgICB1ZV9jc20udWUuZXhlYyhmdW5jdGlvbiAoYiwgaykge1xuICAgICAgICBmdW5jdGlvbiBBKCkge1xuICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1thXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGg7XG5cbiAgICAgICAgICAgICAgaWYgKGMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHQuYnVpbGRQYXlsb2FkKGwsIGUpO1xuICAgICAgICAgICAgICAgIGggPSBjLnNlbmQoSiwgYik7XG4gICAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBkdW1teUV4Y2VwdGlvbjtcblxuICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGQpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQih7XG4gICAgICAgICAgICBtOiBcIkFsbCBzdXBwb3J0ZWQgY2xpZW50cyBmYWlsZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiBcIkNTTVN1c2hpQ2xpZW50X1RSQU5TUE9SVEFUSU9OX0ZBSUxcIixcbiAgICAgICAgICAgIGY6IFwic3VzaGktY2xpZW50LmpzXCIsXG4gICAgICAgICAgICBsb2dMZXZlbDogXCJFUlJPUlwiXG4gICAgICAgICAgfSwgay51ZV9lcnJfY2hhbiB8fCBcImpzZXJyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbi5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICBuW2FdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEEoZC5fc0JjbiB8fCB7fSwgZC5fYWp4IHx8IHt9KTtcbiAgICAgICAgICAgIGUgPSBbXTtcbiAgICAgICAgICAgIGYgPSB7fTtcbiAgICAgICAgICAgIGwgPSB7fTtcbiAgICAgICAgICAgIHUgPSB2ID0gcSA9IHcgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEsoKSB7XG4gICAgICAgICAgdmFyIGEgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICBjID0gZnVuY3Rpb24gYyhhKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAgPiBhID8gXCIwXCIgKyBhIDogYTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID8gYS50b0lTT1N0cmluZygpIDogYS5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgKyBjKGEuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgKyBjKGEuZ2V0VVRDRGF0ZSgpKSArIFwiVFwiICsgYyhhLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgKyBjKGEuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICsgYyhhLmdldFVUQ1NlY29uZHMoKSkgKyBcIi5cIiArIFN0cmluZygoYS5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDFFMykudG9GaXhlZCgzKSkuc2xpY2UoMiwgNSkgKyBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHgoYSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgICAgfSBjYXRjaCAoYykge31cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQyhhLCBjLCBoLCBnKSB7XG4gICAgICAgICAgdmFyIHAgPSAhMTtcbiAgICAgICAgICBnID0gZyB8fCB7fTtcbiAgICAgICAgICByKys7XG4gICAgICAgICAgciA9PSBEICYmIEIoe1xuICAgICAgICAgICAgbTogXCJNYXggbnVtYmVyIG9mIFN1c2hpIExvZ3MgZXhjZWVkZWRcIixcbiAgICAgICAgICAgIGY6IFwic3VzaGktY2xpZW50LmpzXCIsXG4gICAgICAgICAgICBsb2dMZXZlbDogXCJFUlJPUlwiLFxuICAgICAgICAgICAgYXR0cmlidXRpb246IFwiQ1NNU3VzaGlDbGllbnRfTUFYX0NBTExTXCJcbiAgICAgICAgICB9LCBrLnVlX2Vycl9jaGFuIHx8IFwianNlcnJcIik7XG4gICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgaWYgKGYgPSAhKHIgPj0gRCkpIChmID0gYSAmJiAtMSA8IGEuY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKFwiT2JqZWN0XCIpICYmIGMgJiYgLTEgPCBjLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZihcIlN0cmluZ1wiKSAmJiBoICYmIC0xIDwgaC5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoXCJTdHJpbmdcIikpIHx8IEwrKztcbiAgICAgICAgICBmICYmIChkLmNvdW50ICYmIGQuY291bnQoXCJFdmVudDpcIiArIGgsIDEpLCBhLnByb2R1Y2VySWQgPSBhLnByb2R1Y2VySWQgfHwgYywgYS5zY2hlbWFJZCA9IGEuc2NoZW1hSWQgfHwgaCwgYS50aW1lc3RhbXAgPSBLKCksIGMgPSBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKSwgaCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgMTIpLCBhLm1lc3NhZ2VJZCA9IGIudWVfaWQgKyBcIi1cIiArIGMgKyBcIi1cIiArIGgsIGcgJiYgIWcuc3NkICYmIChhLnNlc3Npb25JZCA9IGEuc2Vzc2lvbklkIHx8IGIudWVfc2lkLCBhLnJlcXVlc3RJZCA9IGEucmVxdWVzdElkIHx8IGIudWVfaWQsIGEub2JmdXNjYXRlZE1hcmtldHBsYWNlSWQgPSBhLm9iZnVzY2F0ZWRNYXJrZXRwbGFjZUlkIHx8IGIudWVfbWlkKSwgKGMgPSB4KGEpKSA/IChjID0gYy5sZW5ndGgsIChlLmxlbmd0aCA9PSBNIHx8IHEgKyBjID4gTikgJiYgbSgpLCBxICs9IGMsIGEgPSB7XG4gICAgICAgICAgICBkYXRhOiB0LmNvbXByZXNzRXZlbnQoYSlcbiAgICAgICAgICB9LCBlLnB1c2goYSksIChnIHx8IHt9KS5uID8gMCA9PT0gRSA/IG0oKSA6IHUgfHwgKHUgPSBrLnNldFRpbWVvdXQobSwgRSkpIDogdiB8fCAodiA9IGsuc2V0VGltZW91dChtLCBPKSksIHAgPSAhMCkgOiBwID0gITEpO1xuICAgICAgICAgICFwICYmIGIudWVfaW50ICYmIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTIE5leHVzIEFQSSBjYWxsXCIpO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gRigpIHtcbiAgICAgICAgICBpZiAoIUcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgeS5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICB5W2FdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIG5bYV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5sZW5ndGggJiYgKGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cgJiYgKGEgPSB4KHtcbiAgICAgICAgICAgICAgZGN0OiBsLFxuICAgICAgICAgICAgICBldnQ6IGVcbiAgICAgICAgICAgIH0pLCBiLnVlLnNzdyhcImVlbGRhdGFcIiwgYSksIGIudWUuc3N3KFwiZWVsc3RzXCIsIFwidW5rXCIpKSwgQShkLl9zQmNuIHx8IHt9KSk7XG4gICAgICAgICAgICBHID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSChhKSB7XG4gICAgICAgICAgeS5wdXNoKGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSShhKSB7XG4gICAgICAgICAgbi5wdXNoKGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEQgPSAxRTMsXG4gICAgICAgICAgICBNID0gNDk5LFxuICAgICAgICAgICAgTiA9IDUyNDI4OCxcbiAgICAgICAgICAgIHMgPSBmdW5jdGlvbiBzKCkge30sXG4gICAgICAgICAgICBkID0gYi51ZSB8fCB7fSxcbiAgICAgICAgICAgIEIgPSBkLmxvZyB8fCBzLFxuICAgICAgICAgICAgUCA9IGIudWV4IHx8IHM7XG5cbiAgICAgICAgKGIudWV0IHx8IHMpKFwiYmJcIiwgXCJ1ZV9zdXNoaV92MVwiLCB7XG4gICAgICAgICAgd2I6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIEogPSBiLnVlX3N1cmwgfHwgXCJodHRwczovL3VuYWdpLW5hLmFtYXpvbi5jb20vMS9ldmVudHMvY29tLmFtYXpvbi5jc20ubmV4dXNjbGllbnQuZ2FtbWFcIixcbiAgICAgICAgICAgIFEgPSBbXCJtZXNzYWdlSWRcIiwgXCJ0aW1lc3RhbXBcIl0sXG4gICAgICAgICAgICB6ID0gXCIjXCIsXG4gICAgICAgICAgICBlID0gW10sXG4gICAgICAgICAgICBmID0ge30sXG4gICAgICAgICAgICBsID0ge30sXG4gICAgICAgICAgICBxID0gMCxcbiAgICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgICAgTCA9IDAsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIHkgPSBbXSxcbiAgICAgICAgICAgIG4gPSBbXSxcbiAgICAgICAgICAgIEcgPSAhMSxcbiAgICAgICAgICAgIHUsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgRSA9IHZvaWQgMCA9PT0gYi51ZV9ocHNpID8gMUUzIDogYi51ZV9ocHNpLFxuICAgICAgICAgICAgTyA9IHZvaWQgMCA9PT0gYi51ZV9scHNpID8gMUU0IDogYi51ZV9scHNpLFxuICAgICAgICAgICAgdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBhKGEpIHtcbiAgICAgICAgICAgIGZbYV0gPSB6ICsgdysrO1xuICAgICAgICAgICAgbFtmW2FdXSA9IGE7XG4gICAgICAgICAgICByZXR1cm4gZlthXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjKGIpIHtcbiAgICAgICAgICAgIGlmICghKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGcgPSBbXSwgZCA9IGIubGVuZ3RoLCBlID0gMDsgZSA8IGQ7IGUrKykge1xuICAgICAgICAgICAgICAgICAgZ1tlXSA9IGMoYltlXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGcgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoZCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgICBiLmhhc093blByb3BlcnR5KGQpICYmIChnW2ZbZF0gPyBmW2RdIDogYShkKV0gPSAtMSA9PT0gUS5pbmRleE9mKGQpID8gYyhiW2RdKSA6IGJbZF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBiICYmIChiLmxlbmd0aCA+ICh6ICsgdykubGVuZ3RoIHx8IGIuY2hhckF0KDApID09PSB6KSA/IGZbYl0gPyBmW2JdIDogYShiKSA6IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXByZXNzRXZlbnQ6IGMsXG4gICAgICAgICAgICBidWlsZFBheWxvYWQ6IGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHgoe1xuICAgICAgICAgICAgICAgIGNzOiB7XG4gICAgICAgICAgICAgICAgICBkY3Q6IGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2ZW50czogZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZC5ldmVudCAmJiBkLmV2ZW50LmlzU3R1Yikge1xuICAgICAgICAgICAgaWYgKGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBiLnVlLnNzdyhcImVlbHN0c1wiKS52YWw7XG5cbiAgICAgICAgICAgICAgaWYgKGEgJiYgXCJ1bmtcIiA9PT0gYSAmJiAoYSA9IGIudWUuc3N3KFwiZWVsZGF0YVwiKS52YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGM7XG5cbiAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjID0gSlNPTi5wYXJzZShhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGYpIHt9XG5cbiAgICAgICAgICAgICAgICAgIGMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMgJiYgYy5ldnQgaW5zdGFuY2VvZiBBcnJheSAmJiBjLmRjdCBpbnN0YW5jZW9mIE9iamVjdCAmJiAoZSA9IGMuZXZ0LCBsID0gYy5kY3QsIGUgJiYgbCAmJiAobSgpLCBiLnVlLnNzdyhcImVlbGRhdGFcIiwgXCJ7fVwiKSwgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJzY3NcIikpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkLmV2ZW50LnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBhWzNdID0gYVszXSB8fCB7fTtcbiAgICAgICAgICAgICAgYVszXS5uID0gMTtcbiAgICAgICAgICAgICAgQy5hcHBseSh0aGlzLCBhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZC5vblN1c2hpVW5sb2FkLnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBIKGFbMF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLm9uU3VzaGlGbHVzaC5yZXBsYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgSShhWzBdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICBkLmF0dGFjaChcImJlZm9yZXVubG9hZFwiLCBGKTtcbiAgICAgICAgZC5hdHRhY2goXCJwYWdlaGlkZVwiLCBGKTtcbiAgICAgICAgZC5fY21wcyA9IHQ7XG4gICAgICAgIGQuZXZlbnQgPSBDO1xuXG4gICAgICAgIGQuZXZlbnQucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgciA9IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgZC5vblN1c2hpVW5sb2FkID0gSDtcbiAgICAgICAgZC5vblN1c2hpRmx1c2ggPSBJO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgay5QICYmIGsuUC5yZWdpc3RlciAmJiBrLlAucmVnaXN0ZXIoXCJzdXNoaS1jbGllbnRcIiwgcyk7XG4gICAgICAgIH0gY2F0Y2ggKFIpIHtcbiAgICAgICAgICBiLnVlTG9nRXJyb3IoUiwge1xuICAgICAgICAgICAgbG9nTGV2ZWw6IFwiV0FSTlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBQKFwibGRcIiwgXCJ1ZV9zdXNoaV92MVwiLCB7XG4gICAgICAgICAgd2I6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LCBcIk54cy1KUy1DbGllbnRcIikodWVfY3NtLCB3aW5kb3cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIGlzIHB1bGxlZCBkaXJlY3RseSBmcm9tOlxuICAgICAqIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL1N1c2hpSmF2YVNjcmlwdENsaWVudC9ibG9icy9tYWlubGluZS8tLS9qYXZhc2NyaXB0L3RyYW5zcG9ydGF0aW9uLWNsaWVudHMuanNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zcG9ydGF0aW9uQ2xpZW50Q29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc3BvcnRhdGlvbkNsaWVudENvZGUodWVfY3NtLCB3aW5kb3cpIHtcbiAgICAgIHVlX2NzbS51ZS5leGVjKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgIHZhciBlID0gZnVuY3Rpb24gZSgpIHt9LFxuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChiLCBkKSB7XG4gICAgICAgICAgICAgIGlmIChkICYmIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAoYy5YRG9tYWluUmVxdWVzdCkgYSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpLCBhLm9uZXJyb3IgPSBlLCBhLm9udGltZW91dCA9IGUsIGEub25wcm9ncmVzcyA9IGUsIGEub25sb2FkID0gZSwgYS50aW1lb3V0ID0gMDtlbHNlIGlmIChjLlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCAhKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gYSkpIHRocm93IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKCFhKSB0aHJvdyBcIlwiO1xuICAgICAgICAgICAgICAgIGEub3BlbihcIlBPU1RcIiwgYiwgITApO1xuICAgICAgICAgICAgICAgIGEuc2V0UmVxdWVzdEhlYWRlciAmJiBhLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICAgICAgICAgIGEuc2VuZChkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgIH0oKSxcbiAgICAgICAgICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoYywgZCkge1xuICAgICAgICAgICAgICBpZiAoYyAmJiBkKSBpZiAobmF2aWdhdG9yLnNlbmRCZWFjb24oYywgZCkpIGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cgJiYgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJzY3NcIik7ZWxzZSB0aHJvdyBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkOiAhIW5hdmlnYXRvci5zZW5kQmVhY29uICYmICEoYy5jb3Jkb3ZhICYmIGMuY29yZG92YS5wbGF0Zm9ybUlkICYmIFwiaW9zXCIgPT0gYy5jb3Jkb3ZhLnBsYXRmb3JtSWQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIGIudWUuX2FqeCA9IGY7XG4gICAgICAgIGIudWUuX3NCY24gPSBnO1xuICAgICAgfSwgXCJUcmFuc3BvcnRhdGlvbi1jbGllbnRzXCIpKHVlX2NzbSwgd2luZG93KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN1c2hpQ2xpZW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdXNoaUNsaWVudDsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKFwiLi90b1Byb3BlcnR5S2V5LmpzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoXCIuL3RvUHJvcGVydHlLZXkuanNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xuZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9XG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiKTtcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2UuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi9kZWZpbmVQcm9wZXJ0eS5qc1wiKTtcbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgc2V0ID0gUmVmbGVjdC5zZXQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgdmFyIGRlc2M7XG4gICAgICBpZiAoYmFzZSkge1xuICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgIGRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcbiAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTtcbn1cbmZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkge1xuICB2YXIgcyA9IHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NldCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2UsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJpbWl0aXZlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZShcIi4vdG9QcmltaXRpdmUuanNcIik7XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBTdHJpbmcoaSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJvcGVydHlLZXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiXCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhyLG4sYSl7dmFyIG89W107Zm9yKHZhciB0IGluIHIpIWZ1bmN0aW9uKHQpe3ZhciBlO09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLHQpJiZ2b2lkIDAhPT1yW3RdJiYoYSYmQXJyYXkuaXNBcnJheShyW3RdKSYmclt0XS5sZW5ndGg/clt0XS5mb3JFYWNoKGZ1bmN0aW9uKHIpe2U9MCE9PXI/cnx8XCJcIjowLG8ucHVzaChcIlwiLmNvbmNhdCh0LFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhlKS50cmltKCkpKSl9KTooZT1uP1N0cmluZyhyW3RdKS50b0xvd2VyQ2FzZSgpfHxcIlwiOjAhPT1yW3RdP3JbdF18fFwiXCI6MCxvLnB1c2goXCJcIi5jb25jYXQodCxcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZSkudHJpbSgpKSkpKSl9KHQpO3JldHVyblwiP1wiLmNvbmNhdChvLmpvaW4oXCImXCIpKX1mdW5jdGlvbiBhcHBlbmRQYXRoKHIsdCxlKXt2b2lkIDA9PT10JiYodD1cIlwiKSxcIi9cIj09PXRbdC5sZW5ndGgtMV0mJih0PXQuc2xpY2UoMCwtMSkpO3ZhciBuPVN0cmluZyhyKS50cmltKCk7cmV0dXJuIGUmJihuPW4udG9Mb3dlckNhc2UoKSksMD09PW4uaW5kZXhPZihcIi9cIik/dCs9bjp0Kz1cIi9cIi5jb25jYXQobiksdH1mdW5jdGlvbiBidWlsZEhhc2gocix0KXt2YXIgZT1cIiNcIi5jb25jYXQoU3RyaW5nKHIpLnRyaW0oKSk7cmV0dXJuIHQ/ZS50b0xvd2VyQ2FzZSgpOmV9ZnVuY3Rpb24gYnVpbGRVcmwocix0KXt2YXIgZTtyZXR1cm4gbnVsbD09PXI/ZT1cIlwiOlwib2JqZWN0XCI9PXR5cGVvZiByPyhlPVwiXCIsdD1yKTplPXIsbnVsbCE9dCYmdC5wYXRoJiYoZT1hcHBlbmRQYXRoKHQucGF0aCxlLHQubG93ZXJDYXNlKSksbnVsbCE9dCYmdC5xdWVyeVBhcmFtcyYmKGUrPWJ1aWxkUXVlcnlTdHJpbmcodC5xdWVyeVBhcmFtcyx0Lmxvd2VyQ2FzZSx0LmRpc2FibGVDU1YpKSxudWxsIT10JiZ0Lmhhc2gmJihlKz1idWlsZEhhc2godC5oYXNoLHQubG93ZXJDYXNlKSksZX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLmFwcGVuZFBhdGg9YXBwZW5kUGF0aCxleHBvcnRzLmJ1aWxkSGFzaD1idWlsZEhhc2gsZXhwb3J0cy5idWlsZFF1ZXJ5U3RyaW5nPWJ1aWxkUXVlcnlTdHJpbmcsZXhwb3J0cy5idWlsZFVybD1idWlsZFVybCxleHBvcnRzLmRlZmF1bHQ9YnVpbGRVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZC11cmwuanMubWFwXG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiI2FhLWNoYWxsZW5nZS13aG9sZS1wYWdlLWlmcmFtZSB7XFxuICAgIG92ZXJmbG93OmhpZGRlbjtcXG4gICAgb3BhY2l0eToxLjA7XFxuICAgIHBvc2l0aW9uOmZpeGVkO1xcbiAgICB0b3A6MHB4O1xcbiAgICBib3R0b206MHB4O1xcbiAgICByaWdodDowcHg7XFxuICAgIGJvcmRlcjpub25lO1xcbiAgICBtYXJnaW46MDtcXG4gICAgcGFkZGluZzowO1xcbiAgICBoZWlnaHQ6MTAwJTtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgei1pbmRleDo5OTk5OTk7XFxufVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXVxuICBdKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaCAoZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG4iLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgSG9zdG5hbWVSZXNvbHZlcj1mdW5jdGlvbigpe3ZhciBfMDAwPVsnXFx4NjVcXHg2N1xceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjlcXHg2ZVxceDc0XFx4NjVcXHg2N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2MVxceDc1XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2OVxceDZlJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDY5XFx4NzQnLCdcXHg2MVxceDc0XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg3M1xceDY3JywnXFx4NmVcXHg2YycsJ1xceDZhXFx4NzBcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDY1XFx4NzMnLCdcXHg2NlxceDcyXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY5XFx4NmVcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzVcXHg2YlxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2MlxceDcyXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYzXFx4NjEnLCdcXHg2NFxceDY1JywnXFx4NjJcXHg3MlxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2OVxceDZlJywnXFx4NzBcXHg2Y1xceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg3OFxceDYzXFx4NmZcXHg3MlxceDcwXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NmNcXHgyZVxceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzRcXHg3MlxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDZkXFx4NzhcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzNcXHg2MScsJ1xceDY1XFx4NzNcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2NFxceDY1XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDcwXFx4NmMnLCdcXHg3MFxceDZjJywnXFx4NzVcXHg3MycsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2NFxceDY1JywnXFx4NjFcXHg3NScsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2NlxceDcyXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYzXFx4NjFcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzNcXHg2NVxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg3OFxceDYzXFx4NmZcXHg3MlxceDcwXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY1XFx4NjcnLCdcXHg2OVxceDZlXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYxXFx4NzQnLCdcXHg2MVxceDc1XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDZkXFx4NzhcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJlXFx4NzRcXHg3MicsJ1xceDc1XFx4NmInLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2MScsJ1xceDczXFx4NjFcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjRcXHg2NVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjFcXHg3NCcsJ1xceDYzXFx4NjFcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjlcXHg3NFxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2YVxceDcwXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYxXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDY0XFx4NzVcXHg2MlxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3M1xceDYxXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc1XFx4NmJcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzNcXHg2NVxceDJlXFx4NjlcXHg2ZVxceDc0XFx4NjVcXHg2N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NzNcXHg2MScsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4MmVcXHg3NVxceDZiJywnXFx4NjZcXHg3MicsJ1xceDY1XFx4NzNcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzRcXHg3MicsJ1xceDY5XFx4NzQnLCdcXHg3NFxceDcyXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2MVxceDY1JywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJlXFx4NjJcXHg3MicsJ1xceDZlXFx4NmNcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjFcXHg2NVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjlcXHg2ZVxceDc0XFx4NjVcXHg2N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2MVxceDc0XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY1XFx4NzUnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NzNcXHg2NScsJ1xceDYxXFx4NjUnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkXFx4MmVcXHg2ZFxceDc4JywnXFx4NzNcXHg2NScsJ1xceDZhXFx4NzAnLCdcXHg3M1xceDY3XFx4MmVcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2ZVxceDZjJywnXFx4NjVcXHg2N1xceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDczXFx4NjdcXHgyZFxceDcwXFx4NzJcXHg2NVxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg3MFxceDY0XFx4NzhcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDY1XFx4NjcnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDJlXFx4NmFcXHg3MCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZVxceDYxXFx4NzUnLCdcXHg3M1xceDY3JywnXFx4NjJcXHg3MicsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2NlxceDcyJywnXFx4NjlcXHg3NFxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2ZVxceDZjXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDZkXFx4NzgnLCdcXHg2NVxceDczJ107ZnVuY3Rpb24gSG9zdG5hbWVSZXNvbHZlcigpe3ZhciBfbDFpaUlMTGk9ZnVuY3Rpb24oXzBRMFEwbzBRLF8wT08wUTBPbyl7dmFyIF9MMUw9WydcXHg2MlxceDZmXFx4NjRcXHg3OScsJ1xceDYxJywuOTQyMjE2NzAyMDYzMDM2MywyMzEwXTt2YXIgX1FPMDAwb1EwPV9MMUxbM10sX29RMDBRUU9PPV9MMUxbMl07dmFyIF9Rb29Rb1EwMD1fTDFMWzBdO3JldHVybiBfTDFMWzFdO307fUhvc3RuYW1lUmVzb2x2ZXIuZ2V0U2VydmljZUhvc3RuYW1lQnlDb25maWd1cmF0aW9uPWZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pe3ZhciBfUyQ9WydcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJ107dmFyIF9sSUxsTGlJTD1mdW5jdGlvbihfcyRzc1MyenosX29PT29RT09RKXt2YXIgX28wMD1bJ1xceDYyXFx4NmNcXHg2ZlxceDYyXFx4NDEnLC43NzMzNDM0NjgxNzU1ODk1LCdcXHg2MlxceDZjXFx4NmZcXHg2MlxceDRmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NScsLjQ5NzQxMTgxNTk1MTg2NTQ1XTt2YXIgX1pzc1NzenpaPV9vMDBbMV07dmFyIF9zenNaWnMkUz1fbzAwWzNdO3ZhciBfMDBPbzBvT089X28wMFswXTtyZXR1cm4gX28wMFsyXTt9O2lmKGNvbmZpZ3VyYXRpb24gaW4gSG9zdG5hbWVSZXNvbHZlci5ET01BSU5fUkVBTE1fSE9TVE5BTUUpe3JldHVybiBIb3N0bmFtZVJlc29sdmVyLkRPTUFJTl9SRUFMTV9IT1NUTkFNRVtjb25maWd1cmF0aW9uXTt9ZWxzZXtyZXR1cm4gX1MkWzBdO319O0hvc3RuYW1lUmVzb2x2ZXIuZ2V0U2VydmljZUhvc3RuYW1lQnlIb3N0bmFtZT1mdW5jdGlvbihob3N0bmFtZSl7dmFyIF9RMDA9WydcXHg3MFxceDcyXFx4NmZcXHg2NCcsJ1xceDc0XFx4NjVcXHg3M1xceDc0JywnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyJ107aWYoSG9zdG5hbWVSZXNvbHZlci5pc0RldmVsb3BtZW50KGhvc3RuYW1lKSl7dmFyIF9zU3Nzc3NzMj1mdW5jdGlvbihfc3paenNaJFMsX2kxSTExMTExKXt2YXIgX2lsMT1bJ1xceDZlXFx4NmZcXHg2NFxceDY1Jyw0Nzk5MywuNzE1ODk1MjQ1Mzg5NzMwNSwnXFx4NmZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1JywxOTc5Nl07dmFyIF9pTGxJaWxsST1faWwxWzNdLF9PT29PT1FvUT1faWwxWzRdO3ZhciBfaWlMMWxsbGw9X2lsMVsxXSxfME8wb29Rb289X2lsMVsyXTtyZXR1cm4gX2lsMVswXTt9O3JldHVybiB0aGlzLmdldFNlcnZpY2VIb3N0QnlDb3VudHJ5Q29kZShfUTAwWzFdLHRoaXMuZ2V0Q291bnRyeUNvZGVQcmVmaXgoaG9zdG5hbWUpKTt9ZWxzZSBpZihIb3N0bmFtZVJlc29sdmVyLmlzUHJlUHJvZChob3N0bmFtZSkpe3JldHVybiB0aGlzLmdldFNlcnZpY2VIb3N0QnlDb3VudHJ5Q29kZShfUTAwWzJdLHRoaXMuZ2V0Q291bnRyeUNvZGVQcmVmaXgoaG9zdG5hbWUpKTt9ZWxzZXt2YXIgY291bnRyeUNvZGU9SG9zdG5hbWVSZXNvbHZlci5nZXRDb3VudHJ5Q29kZVN1ZmZpeChob3N0bmFtZSk7cmV0dXJuIHRoaXMuZ2V0U2VydmljZUhvc3RCeUNvdW50cnlDb2RlKF9RMDBbMF0sY291bnRyeUNvZGUpO319O0hvc3RuYW1lUmVzb2x2ZXIuZ2V0U2VydmljZUhvc3RCeUNvdW50cnlDb2RlPWZ1bmN0aW9uKGRvbWFpbixjb3VudHJ5Q29kZSl7dmFyIF8xbD1bJ1xceDJlJywnXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJ107cmV0dXJuIHRoaXMuZ2V0U2VydmljZUhvc3RuYW1lQnlDb25maWd1cmF0aW9uKGRvbWFpbitfMWxbMF0rY291bnRyeUNvZGUudG9VcHBlckNhc2UoKStfMWxbMV0pO307SG9zdG5hbWVSZXNvbHZlci5pc0RldmVsb3BtZW50PWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgXzExaT1bJ1xceDZjXFx4NmZcXHg2M1xceDYxXFx4NmNcXHg2OFxceDZmXFx4NzNcXHg3NCcsJ1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsLjY3MDUxMzEzNjkwMTgxMzYsJ1xceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywuMTE5NzYwNDQ1MTY4ODE4MTIsJ1xceDY0XFx4NjVcXHg3NlxceDJkXFx4NjRcXHg3M1xceDZiJ107dmFyIF8wT08wT1EwTz1fMTFpWzNdLF9saUxJbGlsST1fMTFpWzVdO3JldHVybiBob3N0bmFtZS5zdGFydHNXaXRoKF8xMWlbNl0pJiZob3N0bmFtZS5lbmRzV2l0aChfMTFpWzFdKXx8aG9zdG5hbWUuc3RhcnRzV2l0aChfMTFpWzBdKXx8aG9zdG5hbWUuZW5kc1dpdGgoXzExaVsyXSl8fGhvc3RuYW1lLmVuZHNXaXRoKF8xMWlbNF0pO307SG9zdG5hbWVSZXNvbHZlci5pc1ByZVByb2Q9ZnVuY3Rpb24oaG9zdG5hbWUpe3ZhciBfT1EwPVsnXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NzBcXHg2NFxceDc4XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzBcXHg3MlxceDY1XFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDcwXFx4NjRcXHg3OFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2NFxceDc1XFx4NjJcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg3OFxceDYzXFx4NmZcXHg3MlxceDcwXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCddO3JldHVybiBob3N0bmFtZS5lbmRzV2l0aChfT1EwWzJdKXx8aG9zdG5hbWUuZW5kc1dpdGgoX09RMFswXSl8fGhvc3RuYW1lLmVuZHNXaXRoKF9PUTBbM10pfHxob3N0bmFtZS5lbmRzV2l0aChfT1EwWzRdKXx8aG9zdG5hbWUuZW5kc1dpdGgoX09RMFsxXSk7fTtIb3N0bmFtZVJlc29sdmVyLmdldENvdW50cnlDb2RlUHJlZml4PWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgXzJTMj1bJ1xceDJlJywwLDMzNjY1LCdcXHgyZCcsLjUyMDc1NzQ1ODU0MTA3MzIsJ1xceDY0XFx4NmZcXHg2ZFxceDQ4XFx4NjFcXHg3M1xceDY4JywnXFx4NzVcXHg3MycsMV07dmFyIHNwbGl0cz1ob3N0bmFtZS5zcGxpdChfMlMyWzNdKTtpZihzcGxpdHMubGVuZ3RoPl8yUzJbN10pe3ZhciBwcmVmaXhfMT1zcGxpdHNbXzJTMlsxXV07dmFyIF8yWlpTcyQyMj1fMlMyWzJdO2lmKHRoaXMuQ09VTlRSWV9DT0RFUy5zb21lKGZ1bmN0aW9uKGUpe3ZhciBfeno9Wy44NDE5ODEzNTA0NDU4NTg2LCdcXHg2ZlxceDYyXFx4NjZcXHg3NVxceDczXFx4NjNcXHg2MVxceDc0XFx4NjUnLCdcXHg2YVxceDczXFx4NmZcXHg2ZVxceDQ0XFx4NmZcXHg2ZFxceDQ4XFx4NjFcXHg3M1xceDY4J107dmFyIF8kWnpTJDJaUz1fenpbMV0sX1EwUU8wUVEwPV96elsyXSxfTzAwT08wTzA9X3p6WzBdO3JldHVybiBlPT09cHJlZml4XzE7fSkpe3ZhciBfbzBPUU9vb289ZnVuY3Rpb24oX3pzUzJzc3okLF8wME9PUVEwTyl7dmFyIF9RUTA9Wy4zNzMzODgzMzAyMzI3NDE4Nyw0NDI4LDIxMDMxLCdcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDRhXFx4NzNcXHg2ZlxceDZlJywzNjc1MiwnXFx4NzVcXHg3M1xceDY1XFx4NzJcXHg2MVxceDY3XFx4NjVcXHg2ZVxceDc0XFx4NDRcXHg2MVxceDc0XFx4NjFcXHg0Y1xceDY5XFx4NzNcXHg3NCddO3ZhciBfTDExSUkxaTE9X1FRMFsxXSxfbGwxMUlMaTE9X1FRMFs0XTt2YXIgX1FRb1FRMG9vPV9RUTBbNV0sX0xpbElJaWxpPV9RUTBbMF0sX2lMbExpaUxMPV9RUTBbMl07cmV0dXJuIF9RUTBbM107fTtyZXR1cm4gcHJlZml4XzE7fX1zcGxpdHM9aG9zdG5hbWUuc3BsaXQoXzJTMlswXSk7aWYoc3BsaXRzLmxlbmd0aD5fMlMyWzddKXt2YXIgX3MkJFpaJFMkPV8yUzJbNF0sX1FRUW9vME9PPV8yUzJbNV07dmFyIHByZWZpeF8yPXNwbGl0c1tfMlMyWzFdXTtpZih0aGlzLkNPVU5UUllfQ09ERVMuc29tZShmdW5jdGlvbihlKXt2YXIgX1p6PVtdO3ZhciBfenp6UzJzU1o9ZnVuY3Rpb24oX0xpaWlMMWxJLF9TMnoyU3NTUyxfenpTJCR6enMpe3ZhciBfWnpaPVsnXFx4NmNcXHg2OVxceDczXFx4NzRcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkXFx4NDZcXHg3N1xceDYzXFx4NjlcXHg2ZCcsJ1xceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDRhXFx4NzNcXHg2ZlxceDZlJywuNzU3ODQxNTkyODE0NjY5NiwxMDA4NV07dmFyIF96elNzMnNzWj1fWnpaWzJdO3ZhciBfczIyJFNTczI9X1p6WlswXSxfb09Pb1Ewb089X1p6WlszXTtyZXR1cm4gX1p6WlsxXTt9O3JldHVybiBlPT09cHJlZml4XzI7fSkpe3JldHVybiBwcmVmaXhfMjt9fXJldHVybiBfMlMyWzZdO307SG9zdG5hbWVSZXNvbHZlci5nZXRDb3VudHJ5Q29kZVN1ZmZpeD1mdW5jdGlvbihob3N0bmFtZSl7dmFyIF9aWj1bJ1xceDc1XFx4NzMnLCdcXHgyZScsMV07dmFyIHNwbGl0cz1ob3N0bmFtZS5zcGxpdChfWlpbMV0pO3ZhciBfTGxpMUwxTEw9ZnVuY3Rpb24oXzJTJDJzU1N6LF8wb29vUTAwTyl7dmFyIF9paUw9Wy4zMDYzNTQ2Mjg2NDkzMzY0LDI4Mzk1LCdcXHg2NlxceDc3XFx4NjNcXHg2OVxceDZkXFx4NGZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1Jyw5NTE3LCdcXHg2NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NDRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDQ0XFx4NjFcXHg3NFxceDYxJyw2ODY2XTt2YXIgX0xsTExsaUlJPV9paUxbNF0sXzFJbGxsbGkxPV9paUxbMF0sX0lsaWxsSTFsPV9paUxbM107dmFyIF9sMWxpbEwxMT1faWlMWzVdLF9acyRzJCRTMj1faWlMWzJdO3JldHVybiBfaWlMWzFdO307aWYoc3BsaXRzLmxlbmd0aD5fWlpbMl0pe3ZhciBzdWZmaXhfMT1zcGxpdHNbc3BsaXRzLmxlbmd0aC1fWlpbMl1dO2lmKHRoaXMuQ09VTlRSWV9DT0RFUy5zb21lKGZ1bmN0aW9uKGUpe3ZhciBfTGw9W107cmV0dXJuIGU9PT1zdWZmaXhfMTt9KSl7cmV0dXJuIHN1ZmZpeF8xO319cmV0dXJuIF9aWlswXTt9O0hvc3RuYW1lUmVzb2x2ZXIuRE9NQUlOX1JFQUxNX0hPU1ROQU1FPXsnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDRlXFx4NDFcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMjNdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDRlXFx4NDFcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMjVdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NGVcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFszMV0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1NVxceDUzXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzIzXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1NVxceDUzXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzI1XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDU1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMzFdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFszM10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs0Nl0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0M1xceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzQyXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDRkXFx4NThcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMzldLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDRkXFx4NThcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMjBdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NGRcXHg1OFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs2OF0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0MVxceDU0XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzY0XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0MVxceDU0XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzRdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDFcXHg1NFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs0NV0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1M1xceDQ3XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzcxXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1M1xceDQ3XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzc0XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDUzXFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNV0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0MVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzM4XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0MVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzFdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDFcXHg1NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs3N10sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0NFxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzQ0XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0NFxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzI0XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ0XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMjldLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDVcXHg1NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs0NF0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDVcXHg1NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFsyNF0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0NVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzI5XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDUwXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMThdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDUwXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMTddLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NTBcXHg0Y1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFsyNl0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1NFxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzU5XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1NFxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzE5XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDU0XFx4NTJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNDBdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDlcXHg1NFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs0N10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDlcXHg1NFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs4MV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0OVxceDU0XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzNdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDFcXHg0NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs2M10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDFcXHg0NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs0OV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0MVxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzYwXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDRhXFx4NTBcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNDhdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDRhXFx4NTBcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbN10sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0YVxceDUwXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzc2XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ2XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNDhdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ2XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbN10sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0NlxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzc2XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ3XFx4NDJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNTFdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ3XFx4NDJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMTFdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDdcXHg0MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs1NF0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1NVxceDRiXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzUxXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1NVxceDRiXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzExXSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDU1XFx4NGJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNTRdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NTNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs1MF0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs0M10sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg1M1xceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzUzXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ5XFx4NGVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMTBdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ5XFx4NGVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMzZdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDlcXHg0ZVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFsyXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ1XFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMF0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDVcXHg0N1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs3M10sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0NVxceDQ3XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzc1XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ2XFx4NTJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbOV0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDZcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFszMl0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0NlxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzgwXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNTZdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbMjJdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDVcXHg1M1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs4XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDRlXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbODJdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDRlXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNjJdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NGVcXHg0Y1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFs3Ml0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1M1xceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzUyXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1M1xceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzM0XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDUzXFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl8wMDBbNjZdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDJcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFsxNV0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDJcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6XzAwMFsxMl0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0MlxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfMDAwWzYxXX07SG9zdG5hbWVSZXNvbHZlci5DT1VOVFJZX0NPREVTPVtfMDAwWzM3XSxfMDAwWzc4XSxfMDAwWzMwXSxfMDAwWzE0XSxfMDAwWzI3XSxfMDAwWzU3XSxfMDAwWzU4XSxfMDAwWzEzXSxfMDAwWzY3XSxfMDAwWzgzXSxfMDAwWzcwXSxfMDAwWzQxXSxfMDAwWzY1XSxfMDAwWzIxXSxfMDAwWzI4XSxfMDAwWzE2XSxfMDAwWzM1XSxfMDAwWzU1XSxfMDAwWzg0XSxfMDAwWzZdLF8wMDBbNjldLF8wMDBbNzldXTtyZXR1cm4gSG9zdG5hbWVSZXNvbHZlcjt9KCk7ZXhwb3J0cy5Ib3N0bmFtZVJlc29sdmVyPUhvc3RuYW1lUmVzb2x2ZXI7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEhvc3RuYW1lUmVzb2x2ZXJfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NDhcXHg2ZlxceDczXFx4NzRcXHg2ZVxceDYxXFx4NmRcXHg2NVxceDUyXFx4NjVcXHg3M1xceDZmXFx4NmNcXHg3NlxceDY1XFx4NzInKTt2YXIgS2F0YWxFbmRwb2ludFJlc29sdmVyPWZ1bmN0aW9uKCl7dmFyIF9PTz1bJ1xceDYxXFx4NzAnLCdcXHg2OFxceDc0XFx4NzRcXHg3MFxceDczXFx4M2FcXHgyZlxceDJmXFx4NzZcXHgzM1xceDMyXFx4NjJcXHg2N1xceDY3XFx4NjJcXHg2ZFxceDZhXFx4NjFcXHgyZVxceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4MmRcXHg2MVxceDcwXFx4NjlcXHgyZVxceDc1XFx4NzNcXHgyZFxceDc3XFx4NjVcXHg3M1xceDc0XFx4MmRcXHgzMlxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4NjFcXHg3N1xceDczXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZlxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmZcXHg3NlxceDMxXFx4MmZcXHg2Y1xceDZmXFx4NjcnLCdcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnLCdcXHg2OFxceDc0XFx4NzRcXHg3MFxceDczXFx4M2FcXHgyZlxceDJmXFx4NmRcXHg2MlxceDY0XFx4NzZcXHg2N1xceDZmXFx4NmFcXHgzMlxceDM3XFx4NjhcXHgyZVxceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4MmRcXHg2MVxceDcwXFx4NjlcXHgyZVxceDc1XFx4NzNcXHgyZFxceDY1XFx4NjFcXHg3M1xceDc0XFx4MmRcXHgzMVxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4NjFcXHg3N1xceDczXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZlxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmZcXHg3NlxceDMxXFx4MmZcXHg2Y1xceDZmXFx4NjcnLCdcXHg2OFxceDc0XFx4NzRcXHg3MFxceDczXFx4M2FcXHgyZlxceDJmXFx4NzlcXHgzM1xceDZhXFx4MzVcXHg2N1xceDM5XFx4NjVcXHgzNlxceDc5XFx4MzRcXHgyZVxceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4MmRcXHg2MVxceDcwXFx4NjlcXHgyZVxceDc1XFx4NzNcXHgyZFxceDY1XFx4NjFcXHg3M1xceDc0XFx4MmRcXHgzMVxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4NjFcXHg3N1xceDczXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZlxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmZcXHg3NlxceDMxXFx4MmZcXHg2Y1xceDZmXFx4NjcnLCdcXHg2N1xceDYxXFx4NmRcXHg2ZFxceDYxJywnXFx4NjJcXHg2NVxceDc0XFx4NjEnLCdcXHg3MFxceDcyXFx4NmZcXHg2NCddO2Z1bmN0aW9uIEthdGFsRW5kcG9pbnRSZXNvbHZlcigpe3ZhciBfMiQyWiRTejI9X09PWzJdO31LYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0S2F0YWxMb2dnZXJFbmRwb2ludD1mdW5jdGlvbigpe3ZhciBfSTE9W107dmFyIHN0YWdlPXRoaXMuZ2V0U3RhZ2VCeUhvc3RuYW1lKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gdGhpcy5LQVRBTF9MT0dHRVJfRU5EUE9JTlRTX01BUFtzdGFnZV07fTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0U3RhZ2VCeUhvc3RuYW1lPWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgX3Mkej1bNDI0MzEsJ1xceDY1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0XFx4NDVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzQnLCdcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnLCdcXHg2NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NDRcXHg2MVxceDc0XFx4NjEnLCdcXHg2NFxceDZmXFx4NmQnXTtpZihIb3N0bmFtZVJlc29sdmVyXzEuSG9zdG5hbWVSZXNvbHZlci5pc0RldmVsb3BtZW50KGhvc3RuYW1lKSl7dmFyIF9zWnNTWjIkWj1mdW5jdGlvbihfbDFsSWxpSWwpe3ZhciBfJDI9WydcXHg2MicsJ1xceDY2XFx4NzdcXHg2M1xceDY5XFx4NmRcXHg0ZVxceDZmXFx4NjRcXHg2NScsJ1xceDY0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0XFx4NDhcXHg2MVxceDczXFx4NjgnXTt2YXIgXzJ6UzJ6UyQkPV8kMlsyXSxfeiRzU1MyWlM9XyQyWzBdO3JldHVybiBfJDJbMV07fTtyZXR1cm4gdGhpcy5CRVRBX1NUQUdFO31lbHNlIGlmKEhvc3RuYW1lUmVzb2x2ZXJfMS5Ib3N0bmFtZVJlc29sdmVyLmlzUHJlUHJvZChob3N0bmFtZSkpe3ZhciBfb1FPT29vb1E9X3MkelsyXSxfUW8wMFFRUTA9X3Mkels0XTtyZXR1cm4gdGhpcy5HQU1NQV9TVEFHRTt9dmFyIF8xTGxMTExsaT1fcyR6WzNdLF9Pb09RTzAwMD1fcyR6WzFdLF9Rb28wUTAwTz1fcyR6WzBdO3JldHVybiB0aGlzLlBST0RfU1RBR0U7fTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0U3RhZ2VCeUhvc3RDb25maWc9ZnVuY3Rpb24oaG9zdENvbmZpZyl7dmFyIF9vMD1bJ1xceDZlXFx4NzVcXHg2Y1xceDZjXFx4NDhcXHg2ZlxceDczXFx4NzRcXHg0M1xceDZmXFx4NmVcXHg2NlxceDY5XFx4NjcnLCdcXHg3MFxceDcyXFx4NmZcXHg2NCcsJ1xceDYyXFx4NDVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnLCdcXHgyZScsMCwnXFx4NzRcXHg2NVxceDczXFx4NzQnLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzInXTt2YXIgX09Rb09Rb28wPV9vMFsyXTt2YXIgY29uZmlndXJhdGlvbj1fbzBbMF07aWYoaG9zdENvbmZpZyl7dmFyIF9pTElMMWxJbD1mdW5jdGlvbihfcyQkMnNaenMsX0xsaUxJMUxJLF9PMFFRT09RMCl7dmFyIF8wbz1bMTMzNjcsJ1xceDYzXFx4NmZcXHg2Y1xceDZjXFx4NjVcXHg2M1xceDc0XFx4NmZcXHg3MlxceDQ1XFx4NmMnLDI5OTg2LDQwMzEyXTt2YXIgX2lMMTFJaWxpPV8wb1syXTt2YXIgX0lJMWlJTGlpPV8wb1swXSxfME9Rb1EwbzA9XzBvWzNdO3JldHVybiBfMG9bMV07fTtjb25maWd1cmF0aW9uPWhvc3RDb25maWcuc3BsaXQoX28wWzNdKVtfbzBbNF1dO31zd2l0Y2goY29uZmlndXJhdGlvbil7Y2FzZSBfbzBbNV06cmV0dXJuIHRoaXMuQkVUQV9TVEFHRTtjYXNlIF9vMFs2XTpyZXR1cm4gdGhpcy5HQU1NQV9TVEFHRTtjYXNlIF9vMFsxXTpyZXR1cm4gdGhpcy5QUk9EX1NUQUdFO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZ2V0U3RhZ2VCeUhvc3RuYW1lKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpKTt9fTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0UGFnZVR5cGVNZXRyaWNOYW1lPWZ1bmN0aW9uKGNsaWVudERhdGEsbG9nZ2VyKXt2YXIgX1FPPVsnXFx4NDZcXHg2MVxceDY5XFx4NmNcXHg2NVxceDY0XFx4MjBcXHg3NFxceDZmXFx4MjBcXHg3MFxceDYxXFx4NzJcXHg3M1xceDY1XFx4MjBcXHg2M1xceDZjXFx4NjlcXHg2NVxceDZlXFx4NzRcXHg0M1xceDZmXFx4NmVcXHg3NFxceDY1XFx4NzhcXHg3NFxceDJlJywnXFx4NmVcXHg2ZlxceDY0XFx4NjVcXHg0YVxceDczXFx4NmZcXHg2ZVxceDQ1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg3OFxceDc0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDcyXFx4NjVcXHg2NlxceDJkXFx4NjlcXHg2NCcsMjg5MTgsNDU1ODYsJ1xceDJlJ107dmFyIF9zWiRac1NzWj1mdW5jdGlvbihfb09vbzBRMG8sX2xJMTFsbExJKXt2YXIgX3pzPVsnXFx4NjFcXHg0NFxceDZmXFx4NmQnLDMyNjE4LDEwNzc0LCdcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnXTt2YXIgXzIyU3pzJHMyPV96c1szXTt2YXIgX29RMFFRMG8wPV96c1swXTt2YXIgX2lsbElJMTFMPV96c1sxXTtyZXR1cm4gX3pzWzJdO307aWYoY2xpZW50RGF0YVtfUU9bM11dPT10aGlzLkFQX0NMSUVOVF9JRCYmY2xpZW50RGF0YVtfUU9bMl1dKXt0cnl7dmFyIF9paUxMMTFpbD1fUU9bNV0sXyRTczIkMnMyPV9RT1s0XTt2YXIgY2xpZW50Q29udGV4dD1KU09OLnBhcnNlKGNsaWVudERhdGFbX1FPWzJdXSk7cmV0dXJuIGNsaWVudENvbnRleHQucGFnZVR5cGU/X1FPWzZdK2NsaWVudENvbnRleHQucGFnZVR5cGU6dGhpcy5FTVBUWV9TVFJJTkc7fWNhdGNoKGVycil7bG9nZ2VyLmVycm9yKF9RT1swXSxlcnIubWVzc2FnZSk7dmFyIF9sMWlMTGxMbD1fUU9bMV07cmV0dXJuIHRoaXMuRU1QVFlfU1RSSU5HO319cmV0dXJuIHRoaXMuRU1QVFlfU1RSSU5HO307S2F0YWxFbmRwb2ludFJlc29sdmVyLkJFVEFfU1RBR0U9X09PWzZdO0thdGFsRW5kcG9pbnRSZXNvbHZlci5HQU1NQV9TVEFHRT1fT09bNV07S2F0YWxFbmRwb2ludFJlc29sdmVyLlBST0RfU1RBR0U9X09PWzddO0thdGFsRW5kcG9pbnRSZXNvbHZlci5LQVRBTF9MT0dHRVJfRU5EUE9JTlRTX01BUD17J1xceDYyXFx4NjVcXHg3NFxceDYxJzpfT09bMV0sJ1xceDY3XFx4NjFcXHg2ZFxceDZkXFx4NjEnOl9PT1s0XSwnXFx4NzBcXHg3MlxceDZmXFx4NjQnOl9PT1szXX07S2F0YWxFbmRwb2ludFJlc29sdmVyLkVNUFRZX1NUUklORz0nJztLYXRhbEVuZHBvaW50UmVzb2x2ZXIuQVBfQ0xJRU5UX0lEPV9PT1swXTt2YXIgX3MyWlMkU1NaPWZ1bmN0aW9uKF96Mloyc1NTcyxfMlNaMnokWiQpe3ZhciBfWiR6PVsuMzAxOTE5MzM2ODI5NTkxOCwuOTYzNjE3NTExMDEyMzIsJ1xceDc1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NCcsNjUzMV07dmFyIF9PUW9PMFFvTz1fWiR6WzNdLF8kUzJ6JCQyej1fWiR6WzBdO3ZhciBfME8wb09Pb089X1okelsxXTtyZXR1cm4gX1okelsyXTt9O3JldHVybiBLYXRhbEVuZHBvaW50UmVzb2x2ZXI7fSgpO2V4cG9ydHMuS2F0YWxFbmRwb2ludFJlc29sdmVyPUthdGFsRW5kcG9pbnRSZXNvbHZlcjsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgYnVpbGRfdXJsX3RzXzE9cmVxdWlyZSgnXFx4NjJcXHg3NVxceDY5XFx4NmNcXHg2NFxceDJkXFx4NzVcXHg3MlxceDZjXFx4MmRcXHg3NFxceDczJyk7cmVxdWlyZSgnXFx4MmVcXHgyZlxceDYzXFx4NzNcXHg3M1xceDJmXFx4NjlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1XFx4MmVcXHg2M1xceDczXFx4NzMnKTt2YXIgQUNJQ1Nlc3Npb25Db250ZXh0XzE9cmVxdWlyZSgnXFx4MmVcXHgyZlxceDY0XFx4NjFcXHg3NFxceDYxXFx4MmZcXHg0MVxceDQzXFx4NDlcXHg0M1xceDUzXFx4NjVcXHg3M1xceDczXFx4NjlcXHg2ZlxceDZlXFx4NDNcXHg2ZlxceDZlXFx4NzRcXHg2NVxceDc4XFx4NzQnKTt2YXIgQUNJQ0NsaWVudFJlcXVlc3RfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZlxceDQxXFx4NDNcXHg0OVxceDQzXFx4NDNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzQnKTt2YXIgQUFtYXRpb25SZXN1bHRfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZlxceDQxXFx4NDFcXHg2ZFxceDYxXFx4NzRcXHg2OVxceDZmXFx4NmVcXHg1MlxceDY1XFx4NzNcXHg3NVxceDZjXFx4NzQnKTt2YXIgQUNJQ1VzZXJSZXNwb25zZV8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJmXFx4NDFcXHg0M1xceDQ5XFx4NDNcXHg1NVxceDczXFx4NjVcXHg3MlxceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjUnKTt2YXIgSG9zdG5hbWVSZXNvbHZlcl8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg0OFxceDZmXFx4NzNcXHg3NFxceDZlXFx4NjFcXHg2ZFxceDY1XFx4NTJcXHg2NVxceDczXFx4NmZcXHg2Y1xceDc2XFx4NjVcXHg3MicpO3ZhciBBQ0lDRXJyb3JfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZlxceDQxXFx4NDNcXHg0OVxceDQzXFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MicpO3ZhciBrYXRhbF9sb2dnZXJfMT1yZXF1aXJlKCdcXHg0MFxceDYxXFx4NmRcXHg3YVxceDZlXFx4MmZcXHg2YlxceDYxXFx4NzRcXHg2MVxceDZjXFx4MmRcXHg2Y1xceDZmXFx4NjdcXHg2N1xceDY1XFx4NzInKTt2YXIgS2F0YWxFbmRwb2ludFJlc29sdmVyXzE9cmVxdWlyZSgnXFx4MmVcXHgyZlxceDRiXFx4NjFcXHg3NFxceDYxXFx4NmNcXHg0NVxceDZlXFx4NjRcXHg3MFxceDZmXFx4NjlcXHg2ZVxceDc0XFx4NTJcXHg2NVxceDczXFx4NmZcXHg2Y1xceDc2XFx4NjVcXHg3MicpO3ZhciBrYXRhbF9tZXRyaWNzXzE9cmVxdWlyZSgnXFx4NDBcXHg2MVxceDZkXFx4N2FcXHg2ZVxceDJmXFx4NmJcXHg2MVxceDc0XFx4NjFcXHg2Y1xceDJkXFx4NmRcXHg2NVxceDc0XFx4NzJcXHg2OVxceDYzXFx4NzMnKTt2YXIga2F0YWxfbWV0cmljc19kcml2ZXJfc3VzaGlfMT1yZXF1aXJlKCdcXHg0MFxceDYxXFx4NmRcXHg3YVxceDZlXFx4MmZcXHg2YlxceDYxXFx4NzRcXHg2MVxceDZjXFx4MmRcXHg2ZFxceDY1XFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3M1xceDJkXFx4NjRcXHg3MlxceDY5XFx4NzZcXHg2NVxceDcyXFx4MmRcXHg3M1xceDc1XFx4NzNcXHg2OFxceDY5Jyk7dmFyIEFDSUM9ZnVuY3Rpb24oKXt2YXIgX0wxPVt0cnVlLCdcXHgyZlxceDYxXFx4NjFcXHg3NVxceDc0XFx4MmZcXHg3NlxceDY1XFx4NzJcXHg2OVxceDY2XFx4NzlcXHgyZicsJ1xceDczXFx4NzRcXHg2MVxceDc0XFx4NjlcXHg2M1xceDUzXFx4NjVcXHg3M1xceDczXFx4NjlcXHg2ZlxceDZlXFx4NTRcXHg2ZlxceDZiXFx4NjVcXHg2ZScsbnVsbCwnXFx4NzNcXHg3NFxceDYxXFx4NzRcXHg2OVxceDYzXFx4NDNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NDNcXHg2ZlxceDZlXFx4NzRcXHg2NVxceDc4XFx4NzQnLDMsJ1xceDQxXFx4NDNcXHg0OVxceDQzJywnXFx4NjFcXHg2ZFxceDdhXFx4MmRcXHg2MVxceDYxXFx4NmRcXHg2MVxceDc0XFx4NjlcXHg2ZlxceDZlXFx4MmRcXHg3MlxceDY1XFx4NzNcXHg3MCcsMTVlMywnXFx4MzEnLCdcXHg1MFxceDQxXFx4NTNcXHg1MycsJ1xceDZmXFx4NmVcXHg2NVxceDcyXFx4NzJcXHg2ZlxceDcyJ107ZnVuY3Rpb24gQUNJQyhhY2ljS2F0YWxMb2dnZXIpe3RoaXMubG9nZ2VyPXtsb2c6ZnVuY3Rpb24oYXJncyl7dmFyIF9zUz1bXTt9fTt0aGlzLnNlc3Npb25Db250ZXh0PW5ldyBBQ0lDU2Vzc2lvbkNvbnRleHRfMS5BQ0lDU2Vzc2lvbkNvbnRleHQoKTt0aGlzLl9vbmVycm9yPV9MMVszXTtpZihhY2ljS2F0YWxMb2dnZXIhPV9MMVszXSl7dmFyIF8wUW9PUU8wMD1mdW5jdGlvbihfMTFsbDFMbGwpe3ZhciBfTEw9Wy43NTMzODgzNjE5MzQ2NDkzLDkwNTAsJ1xceDc1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NFxceDQyXFx4NmNcXHg2ZlxceDYyJywuODk2NzY3MzAwNjEyMDgwNF07dmFyIF9sSWlsaTFMMT1fTExbMV0sX3pzelpTU1NaPV9MTFsyXSxfT09vT1FPbzA9X0xMWzNdO3JldHVybiBfTExbMF07fTt0aGlzLmFjaWNLYXRhbExvZ2dlcj1hY2ljS2F0YWxMb2dnZXI7fWVsc2V7dmFyIF9vMDBvUU9PTz1mdW5jdGlvbihfczJ6c1NzJCQsX3paMjJ6U1okKXt2YXIgX2xsPVsnXFx4NjZcXHg3N1xceDYzXFx4NjlcXHg2ZCcsLjkyNTQwNDkxMDA2MzM4MjMsLjY2Mzk0NTQwMzU4OTg2MTNdO3ZhciBfTElpbGlJTGw9X2xsWzFdLF9Pb1FvUU9Pbz1fbGxbMl07cmV0dXJuIF9sbFswXTt9O3RoaXMuYWNpY0thdGFsTG9nZ2VyPXRoaXMuc2V0dXBLYXRhbExvZ2dlcigpO310aGlzLnNldHVwSWZyYW1lRXZlbnRMaXN0ZW5lcigpO31BQ0lDLnByb3RvdHlwZS5zZXR1cEFDSUM9ZnVuY3Rpb24oY2xpZW50SW5wdXREYXRhKXt2YXIgX3NTWj1bJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2OFxceDZmXFx4NzNcXHg3NFxceDJkXFx4NjNcXHg2ZlxceDZlXFx4NjZcXHg2OVxceDY3JywnXFx4NjJcXHg0MlxceDZmXFx4NjRcXHg3OScsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg3NVxceDczXFx4NjVcXHgyZFxceDcwXFx4NmZcXHg3M1xceDc0XFx4MmRcXHg3MlxceDY1XFx4NzFcXHg3NVxceDY1XFx4NzNcXHg3NFxceDJkXFx4NmRcXHg2NVxceDc0XFx4NjhcXHg2ZlxceDY0JyxudWxsLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NzRcXHg2OVxceDZkXFx4NjVcXHg2ZlxceDc1XFx4NzQnLC4zNjA1MTU1MjM0NzQwMDY1LCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1XFx4MmRcXHg2OVxceDY0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY1XFx4NzJcXHg3MlxceDZmXFx4NzJcXHgyZFxceDYzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmInLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NmRcXHg2ZlxceDY0XFx4NjUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2ZlxceDczXFx4NzQnLGZhbHNlXTt2YXIgc2VydmljZUhvc3Q9Y2xpZW50SW5wdXREYXRhW19zU1pbOV1dfHxfc1NaWzNdO3ZhciBjb25maWd1cmF0aW9uPWNsaWVudElucHV0RGF0YVtfc1NaWzBdXXx8X3NTWlszXTt0aGlzLnNldFNlcnZpY2VIb3N0KHNlcnZpY2VIb3N0LGNvbmZpZ3VyYXRpb24pO3RoaXMuX29uZXJyb3I9Y2xpZW50SW5wdXREYXRhW19zU1pbN11dfHxfc1NaWzNdO3RoaXMuc2V0Q2xpZW50UmVxdWVzdChjbGllbnRJbnB1dERhdGEpO3RoaXMubW9kZT1jbGllbnRJbnB1dERhdGFbX3NTWls4XV18fF9zU1pbM107dGhpcy50aW1lb3V0PWNsaWVudElucHV0RGF0YVtfc1NaWzRdXXx8QUNJQy5ERUZBVUxUX1JFUVVFU1RfVElNRU9VVDt2YXIgX1N6JFpaMnokPWZ1bmN0aW9uKF9vbzBPT1EwTyxfWiRzJFNzJFope3ZhciBfUVE9WzE2NjA5LDM4ODg2LC45OTAzMjI4MTg1MjY3NTE5LC4wODI3NjQ1ODc0MzI4OTQzOSwuMTkyMzI4MjAxMTQ3NzAxMjIsJ1xceDY0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzQnXTt2YXIgX1FPME8wTzBvPV9RUVsyXSxfMG9Rb1FPb289X1FRWzBdLF9MaUlJbDFsbD1fUVFbM107dmFyIF9JMUlJTDFJbD1fUVFbNF0sX2lpaUkxaUkxPV9RUVs1XTtyZXR1cm4gX1FRWzFdO307dGhpcy51c2VSZXF1ZXN0TWV0aG9kUG9zdD1jbGllbnRJbnB1dERhdGFbX3NTWlsyXV18fF9zU1pbMTBdO3RoaXMuZW5hYmxlQ3VzdG9taXplZElmcmFtZT1jbGllbnRJbnB1dERhdGFbX3NTWls2XV07aWYodGhpcy5lbmFibGVDdXN0b21pemVkSWZyYW1lKXt2YXIgX3N6JCRTMnpaPV9zU1pbMV0sX09PbzAwT29vPV9zU1pbNV07dGhpcy5pZnJhbWU9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2xpZW50SW5wdXREYXRhW19zU1pbNl1dKTt9dGhpcy5zZXRLYXRhbE1ldHJpY3MoY2xpZW50SW5wdXREYXRhKTt0aGlzLnNlbmRBcm5vbGRIdHRwUmVxdWVzdCh0aGlzLmNyZWF0ZU5ld1Nlc3Npb25SZXF1ZXN0VVJMKCksdGhpcy50aW1lb3V0KTt9O0FDSUMucHJvdG90eXBlLnNldHVwQUNJQ2ZvckFzeW5jUmVwb3J0aW5nPWZ1bmN0aW9uKGNsaWVudElucHV0RGF0YSl7dmFyIF9PMD1bJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2OFxceDZmXFx4NzNcXHg3NFxceDJkXFx4NjNcXHg2ZlxceDZlXFx4NjZcXHg2OVxceDY3JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY4XFx4NmZcXHg3M1xceDc0JyxudWxsXTt2YXIgc2VydmljZUhvc3Q9Y2xpZW50SW5wdXREYXRhW19PMFsxXV18fF9PMFsyXTt2YXIgY29uZmlndXJhdGlvbj1jbGllbnRJbnB1dERhdGFbX08wWzBdXXx8X08wWzJdO3RoaXMuc2V0U2VydmljZUhvc3Qoc2VydmljZUhvc3QsY29uZmlndXJhdGlvbik7dGhpcy5zZXRDbGllbnRSZXF1ZXN0KGNsaWVudElucHV0RGF0YSk7aWYod2luZG93Lm5hdmlnYXRvciYmbmF2aWdhdG9yLnNlbmRCZWFjb24pe25hdmlnYXRvci5zZW5kQmVhY29uKHRoaXMuY3JlYXRlTmV3U2Vzc2lvblJlcXVlc3RVUkwoKSxKU09OLnN0cmluZ2lmeSh0aGlzLmNsaWVudFJlcXVlc3QpKTt9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQy5wcm90b3R5cGUsX0wxWzExXSx7c2V0OmZ1bmN0aW9uKG9uRXJyb3Ipe3ZhciBfb089WydcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzRcXHg0OVxceDY0JywuOTM3ODQzNzk4NTMyNTk0NV07dmFyIF8wMFFRUU9vTz1fb09bMF0sX3p6U3MyU1pzPV9vT1sxXTt0aGlzLl9vbmVycm9yPW9uRXJyb3I7fSxlbnVtZXJhYmxlOl9MMVswXSxjb25maWd1cmFibGU6X0wxWzBdfSk7QUNJQy5wcm90b3R5cGUuc2V0U2VydmljZUhvc3Q9ZnVuY3Rpb24oc2VydmljZUhvc3QsY29uZmlndXJhdGlvbil7dmFyIF8yUz1bJ1xceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZScsJ1xceDY4XFx4NzRcXHg3NFxceDcwXFx4NzNcXHgzYVxceDJmXFx4MmYnLG51bGxdO2lmKHNlcnZpY2VIb3N0PT1fMlNbMl0pe2lmKGNvbmZpZ3VyYXRpb24hPV8yU1syXSl7c2VydmljZUhvc3Q9SG9zdG5hbWVSZXNvbHZlcl8xLkhvc3RuYW1lUmVzb2x2ZXIuZ2V0U2VydmljZUhvc3RuYW1lQnlDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO31lbHNle3ZhciBfTExsSTFMSUw9XzJTWzBdO3NlcnZpY2VIb3N0PUhvc3RuYW1lUmVzb2x2ZXJfMS5Ib3N0bmFtZVJlc29sdmVyLmdldFNlcnZpY2VIb3N0bmFtZUJ5SG9zdG5hbWUod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCkpO319dmFyIF9PME9vUU9PMD1mdW5jdGlvbihfSUxJTElMMTEpe3ZhciBfaUk9WzM0Mzc1LC4yNDU4MjYxMjc2NTk5ODIwMiwuMDM1ODg1ODA3NDEzODI1OTY1LDE4MDc2LCdcXHg2MlxceDZmXFx4NjRcXHg3OVxceDUzXFx4NzRcXHg2MVxceDc0XFx4NjVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDQ2XFx4NzdcXHg2M1xceDY5XFx4NmQnXTt2YXIgX09RUTAwUVFRPV9pSVsyXTt2YXIgXzFpSWkxaWkxPV9pSVs0XSxfejIyU3Mkc1o9X2lJWzNdLF8wME9PUVFPbz1faUlbMV07cmV0dXJuIF9pSVswXTt9O3RoaXMuc2VydmljZUVuZHBvaW50PV8yU1sxXStzZXJ2aWNlSG9zdCtBQ0lDLlNFUlZJQ0VfQkFTRV9QQVRIO307QUNJQy5wcm90b3R5cGUuc2V0dXBLYXRhbExvZ2dlcj1mdW5jdGlvbigpe3ZhciBfMDA9WydcXHg2NFxceDZmXFx4NmQnLC4zMjEwMjY4OTIzMTg0NjY3LC4wODY1NTE2NzM4ODUzMjczNl07dmFyIF9aelpaWnpzej1fMDBbMV0sX2wxaUlJMUlpPV8wMFsyXSxfSUwxSTFJTGw9XzAwWzBdO3ZhciBhY2ljS2F0YWxMb2dnZXI9bmV3IGthdGFsX2xvZ2dlcl8xLmRlZmF1bHQoe3VybDpLYXRhbEVuZHBvaW50UmVzb2x2ZXJfMS5LYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0S2F0YWxMb2dnZXJFbmRwb2ludCgpfSk7YWNpY0thdGFsTG9nZ2VyLmFkZEVycm9yTGlzdGVuZXIoZnVuY3Rpb24oZXJyb3Ipe3ZhciBfaUw9W3RydWVdO3JldHVybiBfaUxbMF07fSk7cmV0dXJuIGFjaWNLYXRhbExvZ2dlcjt9O0FDSUMucHJvdG90eXBlLnNldEthdGFsTWV0cmljcz1mdW5jdGlvbihjbGllbnRJbnB1dERhdGEpe3ZhciBfaUkxPVsnXFx4NjVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzRcXHg1M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzQnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NzJcXHg2NVxceDY2XFx4MmRcXHg2OVxceDY0JywnXFx4MmUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2ZlxceDczXFx4NzRcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDY2XFx4NjlcXHg2NycsJ1xceDU1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnLDM3NTk0XTt2YXIgX3RoaXM9dGhpczt2YXIgbWV0cmljc0Vycm9ySGFuZGxlcj1mdW5jdGlvbihlcnIpe3ZhciBfMno9WydcXHg0NlxceDYxXFx4NjlcXHg2Y1xceDY1XFx4NjRcXHgyMFxceDc0XFx4NmZcXHgyMFxceDcwXFx4NzVcXHg2MlxceDZjXFx4NjlcXHg3M1xceDY4XFx4MjBcXHg3NFxceDY4XFx4NjVcXHgyMFxceDZkXFx4NjVcXHg3NFxceDcyXFx4NjlcXHg2M1xceDczXFx4MmUnXTtfdGhpcy5hY2ljS2F0YWxMb2dnZXIuZXJyb3IoXzJ6WzBdLGVycik7fTt2YXIgZG9tYWluPUthdGFsRW5kcG9pbnRSZXNvbHZlcl8xLkthdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRTdGFnZUJ5SG9zdENvbmZpZyhjbGllbnRJbnB1dERhdGFbX2lJMVszXV0pO3ZhciBfbzBRb09RUTA9X2lJMVs1XSxfbzAwUU8wUU89X2lJMVswXTt2YXIgbWV0cmljc0RyaXZlcj1uZXcga2F0YWxfbWV0cmljc19kcml2ZXJfc3VzaGlfMS5kZWZhdWx0LkJ1aWxkZXIoKS53aXRoRG9tYWluUmVhbG0oZG9tYWluLF9pSTFbNF0pLndpdGhFcnJvckhhbmRsZXIobWV0cmljc0Vycm9ySGFuZGxlcikuYnVpbGQoKTt2YXIga2F0YWxNZXRyaWNzU2VydmljZU5hbWU9Y2xpZW50SW5wdXREYXRhW19pSTFbMV1dK0thdGFsRW5kcG9pbnRSZXNvbHZlcl8xLkthdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRQYWdlVHlwZU1ldHJpY05hbWUoY2xpZW50SW5wdXREYXRhLHRoaXMuYWNpY0thdGFsTG9nZ2VyKStfaUkxWzJdK3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTt2YXIgaW5pdGlhbE1ldHJpY3NDb250ZXh0PW5ldyBrYXRhbF9tZXRyaWNzXzEuQ29udGV4dC5CdWlsZGVyKCkud2l0aFNpdGUoQUNJQy5LQVRBTF9NRVRSSUNTX1NFUlZJQ0VfTkFNRSkud2l0aFNlcnZpY2VOYW1lKGthdGFsTWV0cmljc1NlcnZpY2VOYW1lKS5idWlsZCgpO3RoaXMuYWNpY0thdGFsTWV0cmljc1B1Ymxpc2hlcj1uZXcga2F0YWxfbWV0cmljc18xLlB1Ymxpc2hlcihtZXRyaWNzRHJpdmVyLG1ldHJpY3NFcnJvckhhbmRsZXIsaW5pdGlhbE1ldHJpY3NDb250ZXh0KTt9O0FDSUMucHJvdG90eXBlLnNldENsaWVudFJlcXVlc3Q9ZnVuY3Rpb24oZGF0YSl7dmFyIF8xMT1bJ1xceDYyJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NzRcXHg3OVxceDcwXFx4NjUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjVcXHg3NlxceDY1XFx4NmVcXHg3NFxceDJkXFx4NzRcXHg3MlxceDY5XFx4NjdcXHg2N1xceDY1XFx4NzInLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NmRcXHg2ZlxceDY0XFx4NjFcXHg2YycsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2NlxceDc3XFx4NjNcXHg2OVxceDZkJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg3OFxceDc0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDcyXFx4NjVcXHg2NlxceDJkXFx4NjlcXHg2NCcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2NlxceDZmXFx4NzJcXHg2M1xceDY1XFx4MmRcXHg2YVxceDczXFx4MmRcXHg2NlxceDZjXFx4NzVcXHg3M1xceDY4JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDZkXFx4NmZcXHg2NFxceDY1JywzODg0LCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4NGNcXHg2ZlxceDYxXFx4NjRcXHg0M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiJywnXFx4NDNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4MjBcXHg3MlxceDY1XFx4NjZcXHg2NVxceDcyXFx4NjVcXHg2ZVxceDYzXFx4NjVcXHgyMFxceDY5XFx4NjRcXHgyMFxceDY5XFx4NzNcXHgyMFxceDZlXFx4NmZcXHg3NFxceDIwXFx4NzBcXHg3MlxceDZmXFx4NzZcXHg2OVxceDY0XFx4NjVcXHg2NCcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYxXFx4NjFcXHgyZFxceDY1XFx4NzhcXHg3NFxceDY1XFx4NzJcXHg2ZVxceDYxXFx4NmNcXHgyZFxceDc0XFx4NmZcXHg2YlxceDY1XFx4NmUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjVcXHg3OFxceDc0XFx4NjVcXHg3MlxceDZlXFx4NjFcXHg2Y1xceDJkXFx4NjlcXHg2NCcsJ1xceDQzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDIwXFx4NjNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDIwXFx4NjZcXHg3NVxceDZlXFx4NjNcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDIwXFx4NjlcXHg3M1xceDIwXFx4NmVcXHg2ZlxceDc0XFx4MjBcXHg3MFxceDcyXFx4NmZcXHg3NlxceDY5XFx4NjRcXHg2NVxceDY0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYyXFx4NzlcXHg3MFxceDYxXFx4NzNcXHg3M1xceDJkXFx4NmRcXHg2NVxceDYzXFx4NjhcXHg2MVxceDZlXFx4NjlcXHg3M1xceDZkJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY0XFx4NjlcXHg3M1xceDZkXFx4NjlcXHg3M1xceDczXFx4NDNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YicsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2Y1xceDZmXFx4NjNcXHg2MVxceDZjXFx4NjUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2NVxceDYxXFx4NjRcXHg2NVxceDcyXFx4MmRcXHg2NlxceDZmXFx4NmZcXHg3NFxceDY1XFx4NzInXTtpZighZGF0YVtfMTFbNl1dKXt0aHJvdyBuZXcgRXJyb3IoXzExWzExXSk7fWlmKCFkYXRhW18xMVsxMl1dKXt2YXIgXzBvT09RUW9vPV8xMVswXSxfMDBPT09Rb289XzExWzldO3Rocm93IG5ldyBFcnJvcihfMTFbMTVdKTt9dGhpcy5jbGllbnRSZXF1ZXN0PW5ldyBBQ0lDQ2xpZW50UmVxdWVzdF8xLkFDSUNDbGllbnRSZXF1ZXN0KGRhdGFbXzExWzZdXSxkYXRhW18xMVsxMl1dLGRhdGFbXzExWzE3XV0sZGF0YVtfMTFbMTBdXSxkYXRhW18xMVs1XV0sZGF0YVtfMTFbMThdXSxkYXRhW18xMVs0XV0sZGF0YVtfMTFbMTRdXSxkYXRhW18xMVsxOV1dLGRhdGFbXzExWzE2XV0sZGF0YVtfMTFbM11dLGRhdGFbXzExWzFdXSxkYXRhW18xMVs4XV0sZGF0YVtfMTFbMl1dLGRhdGFbXzExWzEzXV0sZGF0YVtfMTFbN11dKTt9O0FDSUMucHJvdG90eXBlLnNldHVwSWZyYW1lRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbigpe3ZhciBfT29vPVsnXFx4NzNcXHg2NVxceDc0XFx4NzVcXHg3MFxceDQ5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NVxceDQ1XFx4NzZcXHg2NVxceDZlXFx4NzRcXHg0Y1xceDY5XFx4NzNcXHg3NFxceDY1XFx4NmVcXHg2NVxceDcyJywnXFx4NmRcXHg2NVxceDczXFx4NzNcXHg2MVxceDY3XFx4NjUnXTt2YXIgX3RoaXM9dGhpczt0aGlzLmxvZ2dlci5sb2coX09vb1swXSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoX09vb1sxXSxmdW5jdGlvbihldmVudCl7dmFyIF9JbD1bXTtyZXR1cm4gX3RoaXMuaGFuZGxlSWZyYW1lTWVzc2FnZShldmVudCk7fSk7fTtBQ0lDLnByb3RvdHlwZS5oYW5kbGVJZnJhbWVNZXNzYWdlPWZ1bmN0aW9uKGV2ZW50KXt2YXIgX29vPVsnXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg0M1xceDZmXFx4NmRcXHg3MFxceDZjXFx4NjVcXHg3NFxceDY1XFx4NjQnLDEyOTkzLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDczXFx4NjhcXHg2ZlxceDc3XFx4NmUnLCdcXHg0M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyMFxceDUzXFx4NjhcXHg2ZlxceDc3XFx4NmUnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDcyXFx4NjVcXHg2ZFxceDZmXFx4NzZcXHg2NScsJ1xceDUyXFx4NjVcXHg2ZFxceDZmXFx4NzZcXHg2NVxceDIwXFx4NzdcXHg2OFxceDZmXFx4NmNcXHg2NVxceDJkXFx4NzBcXHg2MVxceDY3XFx4NjVcXHgyMFxceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NVxceDIwXFx4NjJcXHg2NVxceDY2XFx4NmZcXHg3MlxceDY1XFx4MjBcXHg2OFxceDYxXFx4NzNcXHg2OFxceDIwXFx4NjNcXHg2OFxceDYxXFx4NmVcXHg2N1xceDY1XFx4MjBcXHg2NlxceDZmXFx4NzJcXHgyMFxceDZkXFx4NmZcXHg2NFxceDY1XFx4NmNcXHgyMFxceDc2XFx4NjlcXHg2NVxceDc3XFx4MjBcXHg2OVxceDZlXFx4MjBcXHg3NVxceDcyXFx4NmMnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDY0XFx4NjlcXHg3M1xceDZkXFx4NjlcXHg3M1xceDczJywnXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1M1xceDc1XFx4NzBcXHg3MFxceDcyXFx4NjVcXHg3M1xceDczXFx4NjVcXHg2NCcsJ1xceDYxXFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NmNcXHg2ZlxceDYxXFx4NjRcXHg2NVxceDY0JywnXFx4NjVcXHg3NlxceDY1XFx4NmVcXHg3NFxceDIwXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgzYVxceDIwJywnXFx4NGNcXHg2ZlxceDYxXFx4NjRcXHgyMFxceDQxXFx4NmNcXHg3NFxceDY1XFx4NzJcXHg2ZVxceDYxXFx4NzRcXHg2NVxceDIwXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1N1xceDY5XFx4NzRcXHg2OFxceDIwXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1NFxceDc5XFx4NzBcXHg2NVxceDNhXFx4MjAnLCdcXHg0M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyMFxceDQ0XFx4NjlcXHg3M1xceDZkXFx4NjlcXHg3M1xceDczXFx4NjVcXHg2NCcsMCwnXFx4NjFcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MmRcXHg3M1xceDc1XFx4NzBcXHg3MFxceDcyXFx4NjVcXHg3M1xceDczXFx4NjVcXHg2NCcsJ1xceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NGNcXHg2ZlxceDYxXFx4NjRcXHg2NVxceDY0JywnXFx4NjFcXHg2MVxceDJkXFx4NmNcXHg2ZlxceDYxXFx4NjRcXHgyZFxceDYxXFx4NmNcXHg3NFxceDY1XFx4NzJcXHg2ZVxceDYxXFx4NzRcXHg2NVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1JywnXFx4NjFcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MmRcXHg2M1xceDZmXFx4NmRcXHg3MFxceDZjXFx4NjVcXHg3NFxceDY1J107aWYoZXZlbnQuZGF0YSl7dmFyIF8kMiQyc3MkWj1fb29bMV07dGhpcy5sb2dnZXIubG9nKF9vb1s5XStldmVudC5kYXRhKTt2YXIganNvblBhcnNlZEV2ZW50PXZvaWQgX29vWzEyXTt0cnl7anNvblBhcnNlZEV2ZW50PUpTT04ucGFyc2UoZXZlbnQuZGF0YSk7fWNhdGNoKGVycil7dmFyIF9vT28wb08wUT1mdW5jdGlvbihfaTFpTGlsTDEsX29vb29RbzAwKXt2YXIgX1N6Mj1bMjU0MTksMjkwMzQsMzMzODRdO3ZhciBfc3pzelMyWno9X1N6MlsyXTt2YXIgX1FPT29RMFFvPV9TejJbMF07cmV0dXJuIF9TejJbMV07fTt0aGlzLmxvZ2dlci5sb2coZXJyLm1lc3NhZ2UpO3JldHVybjt9c3dpdGNoKGpzb25QYXJzZWRFdmVudC5ldmVudElkKXtjYXNlIF9vb1syXTp0aGlzLmxvZ2dlci5sb2coX29vWzNdKTticmVhaztjYXNlIF9vb1s4XTp0aGlzLmxvZ2dlci5sb2coX29vWzE0XSk7dGhpcy5yZXNpemVJZnJhbWUoKTt0aGlzLmV4ZWN1dGVDaGFsbGVuZ2VMb2FkQ2FsbGJhY2soanNvblBhcnNlZEV2ZW50LnBheWxvYWQpO2JyZWFrO2Nhc2UgX29vWzE1XTp0aGlzLmxvZ2dlci5sb2coX29vWzEwXStqc29uUGFyc2VkRXZlbnQucGF5bG9hZC5jaGFsbGVuZ2VUeXBlKTt0aGlzLmNsaWVudFJlcXVlc3QuY2hhbGxlbmdlVHlwZVZhbHVlPWpzb25QYXJzZWRFdmVudC5wYXlsb2FkLmNoYWxsZW5nZVR5cGU7dGhpcy5zZW5kQXJub2xkSHR0cFJlcXVlc3QodGhpcy5jcmVhdGVOZXdTZXNzaW9uUmVxdWVzdFVSTCgpKTticmVhaztjYXNlIF9vb1sxM106dGhpcy5sb2dnZXIubG9nKF9vb1s3XSk7dGhpcy5hZGRSZXNwb25zZShqc29uUGFyc2VkRXZlbnQucGF5bG9hZCk7dGhpcy5zZW5kQXJub2xkSHR0cFJlcXVlc3QodGhpcy5jcmVhdGVVc2VyQW5zd2VyUmVxdWVzdFVSTCgpKTticmVhaztjYXNlIF9vb1sxNl06dGhpcy5sb2dnZXIubG9nKF9vb1swXSk7dGhpcy5hZGRSZXNwb25zZShqc29uUGFyc2VkRXZlbnQucGF5bG9hZCk7dGhpcy5sb2dnZXIubG9nKHRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0KTt0aGlzLnNlbmRBcm5vbGRIdHRwUmVxdWVzdCh0aGlzLmNyZWF0ZVVzZXJBbnN3ZXJSZXF1ZXN0VVJMKCkpO2JyZWFrO2Nhc2UgX29vWzZdOnRoaXMubG9nZ2VyLmxvZyhfb29bMTFdKTt0aGlzLmV4ZWN1dGVEaXNtaXNzQ2FsbGJhY2soKTticmVhaztjYXNlIF9vb1s0XTp0aGlzLmxvZ2dlci5sb2coX29vWzVdKTt0aGlzLnJlbW92ZVdob2xlUGFnZUlmcmFtZSgpO2JyZWFrO319fTtBQ0lDLnByb3RvdHlwZS5yZXNpemVJZnJhbWU9ZnVuY3Rpb24oKXt2YXIgXzJ6Wj1bJ1xceDcwXFx4NzgnXTtpZih0aGlzLmVuYWJsZUN1c3RvbWl6ZWRJZnJhbWUpe3ZhciBfenpaMlpaejI9ZnVuY3Rpb24oX29RUVFvUVFvKXt2YXIgXyQkPVsnXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjVcXHg1NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzQnLC44ODg4MTYyNTUxNjE4NzU5LDIxNTg5LCdcXHg2NFxceDZmXFx4NmRcXHg0MlxceDZjXFx4NmZcXHg2MicsJ1xceDY2XFx4NzdcXHg2M1xceDY5XFx4NmRcXHg0M1xceDZmXFx4NmNcXHg2Y1xceDY1XFx4NjNcXHg3NFxceDZmXFx4NzInLC41OTEwMzgyNjkzMjQxNDJdO3ZhciBfU3p6WnNaeno9XyQkWzVdO3ZhciBfTGlJSTFsSTE9XyQkWzJdLF9sMUwxbExMbD1fJCRbM10sXyQkWnpTMiQyPV8kJFs0XTt2YXIgX2xJbElJMWlsPV8kJFswXTtyZXR1cm4gXyQkWzFdO307dGhpcy5pZnJhbWUud2lkdGg9dGhpcy5pZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoK18yelpbMF07dGhpcy5pZnJhbWUuaGVpZ2h0PXRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQrXzJ6WlswXTt9fTtBQ0lDLnByb3RvdHlwZS5hZGRSZXNwb25zZT1mdW5jdGlvbih1c2VyUmVzcG9uc2VEYXRhKXt2YXIgX2kxPVtdO3ZhciB1c2VyUmVzcG9uc2U9bmV3IEFDSUNVc2VyUmVzcG9uc2VfMS5BQ0lDVXNlclJlc3BvbnNlKHRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0LmFjdGlvblR5cGVWYWx1ZSxKU09OLnN0cmluZ2lmeSh1c2VyUmVzcG9uc2VEYXRhKSk7dGhpcy5jdXJyZW50VXNlclJlc3BvbnNlPXVzZXJSZXNwb25zZTt0aGlzLnNlc3Npb25Db250ZXh0LmFkZFJlc3BvbnNlKHVzZXJSZXNwb25zZSk7fTtBQ0lDLnByb3RvdHlwZS5hZGRSZXN1bHQ9ZnVuY3Rpb24ocmVzdWx0U3RyaW5nKXt2YXIgX3MkPVtudWxsXTtpZighcmVzdWx0U3RyaW5nKXt2YXIgXzBPMG9vT1FPPWZ1bmN0aW9uKF8kc1NTU3MkJCl7dmFyIF9vTzA9WydcXHg2NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0Jyw0MDc1MiwuNzkzNTM0MTUzMTYxNzE3NV07dmFyIF9Rb1FPUU8wTz1fb08wWzFdLF9pSWlMaUxpaT1fb08wWzJdO3JldHVybiBfb08wWzBdO307cmV0dXJuIF9zJFswXTt9dmFyIHJlc3VsdEpzb249SlNPTi5wYXJzZShyZXN1bHRTdHJpbmcpO3ZhciByZXN1bHQ9bmV3IEFBbWF0aW9uUmVzdWx0XzEuQUFtYXRpb25SZXN1bHQocmVzdWx0SnNvbi5jbGllbnRTaWRlQ29udGV4dCxyZXN1bHRKc29uLnNlc3Npb25Ub2tlbixyZXN1bHRKc29uLmFjdGlvblR5cGUpO3ZhciBfc1MyWlokejI9ZnVuY3Rpb24oX09vbzBRb1FPKXt2YXIgX2lsPVsuNzY5OTk0MjI3MDAxOTEwNCwyMTEzNV07dmFyIF96WlMyWiRzMj1faWxbMF07cmV0dXJuIF9pbFsxXTt9O3RoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0PXJlc3VsdDt0aGlzLnNlc3Npb25Db250ZXh0LmFkZFJlc3VsdChyZXN1bHQpO3JldHVybiByZXN1bHQ7fTtBQ0lDLnByb3RvdHlwZS5jcmVhdGVOZXdTZXNzaW9uUmVxdWVzdFVSTD1mdW5jdGlvbigpe3ZhciBfMUk9WydcXHg2MlxceDZjXFx4NmZcXHg2MlxceDQ0XFx4NjFcXHg3NFxceDYxXFx4NGNcXHg2OVxceDczXFx4NzQnLCdcXHg0M1xceDcyXFx4NjVcXHg2MVxceDc0XFx4NjVcXHg0ZVxceDY1XFx4NzdcXHg1M1xceDY1XFx4NzNcXHg3M1xceDY5XFx4NmZcXHg2ZVxceDUyXFx4NjVcXHg3MVxceDc1XFx4NjVcXHg3M1xceDc0XFx4NTVcXHg1MlxceDRjXFx4M2FcXHgyMCddO3ZhciBfMWkxbExpaUk9XzFJWzBdO3ZhciB1cmw9YnVpbGRfdXJsX3RzXzEuZGVmYXVsdCh0aGlzLnNlcnZpY2VFbmRwb2ludCx7cGF0aDp0aGlzLmNsaWVudFJlcXVlc3QuY2xpZW50UmVmZXJlbmNlSWRWYWx1ZSxxdWVyeVBhcmFtczp7Y29udGV4dDp1bmRlZmluZWQsb3B0aW9uczpKU09OLnN0cmluZ2lmeSh0aGlzLmNsaWVudFJlcXVlc3QuY2xpZW50T3B0aW9ucyl9fSk7dGhpcy5sb2dnZXIubG9nKF8xSVsxXSt1cmwpO3JldHVybiB1cmw7fTtBQ0lDLnByb3RvdHlwZS5jcmVhdGVVc2VyQW5zd2VyUmVxdWVzdFVSTD1mdW5jdGlvbigpe3ZhciBfbGxJPVsnXFx4MmYnLCdcXHg0M1xceDcyXFx4NjVcXHg2MVxceDc0XFx4NjVcXHg1NVxceDczXFx4NjVcXHg3MlxceDQxXFx4NmVcXHg3M1xceDc3XFx4NjVcXHg3MlxceDUyXFx4NjVcXHg3MVxceDc1XFx4NjVcXHg3M1xceDc0XFx4NTVcXHg1MlxceDRjXFx4M2FcXHgyMCddO3ZhciB1cmw9YnVpbGRfdXJsX3RzXzEuZGVmYXVsdCh0aGlzLnNlcnZpY2VFbmRwb2ludCx7cGF0aDp0aGlzLmNsaWVudFJlcXVlc3QuY2xpZW50UmVmZXJlbmNlSWRWYWx1ZStfbGxJWzBdK3RoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0LnNlc3Npb25Ub2tlblZhbHVlLHF1ZXJ5UGFyYW1zOntjb250ZXh0OnRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0LmNsaWVudFNpZGVDb250ZXh0VmFsdWUsb3B0aW9uczpKU09OLnN0cmluZ2lmeSh0aGlzLmNsaWVudFJlcXVlc3QuY2xpZW50T3B0aW9ucykscmVzcG9uc2U6SlNPTi5zdHJpbmdpZnkodGhpcy5jdXJyZW50VXNlclJlc3BvbnNlKX19KTt0aGlzLmxvZ2dlci5sb2coX2xsSVsxXSt1cmwpO3JldHVybiB1cmw7fTtBQ0lDLnByb3RvdHlwZS5sb2FkQ2hhbGxlbmdlVmlldz1mdW5jdGlvbih2aWV3KXt2YXIgX29vTz1bMzcxMzksJ1xceDY1XFx4NmNcXHg0NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDRhXFx4NzNcXHg2ZlxceDZlJywnXFx4NzVcXHg2ZVxceDY0XFx4NjVcXHg2NlxceDY5XFx4NmVcXHg2NVxceDY0JywnXFx4NzVcXHg3M1xceDY1XFx4NzJcXHg2MVxceDY3XFx4NjVcXHg2ZVxceDc0XFx4NDVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjUnXTtpZih0eXBlb2YgdGhpcy5pZnJhbWU9PT1fb29PWzJdJiYhdGhpcy5lbmFibGVDdXN0b21pemVkSWZyYW1lKXt2YXIgX0wxSTFJTDExPV9vb09bMF07dGhpcy5pZnJhbWU9dGhpcy5jcmVhdGVJZnJhbWUoKTt9dmFyIF9PTzBRUU9RMD1fb29PWzNdLF9PUU9RMFEwbz1fb29PWzFdO3ZhciBpZnJhbWVEb2N1bWVudD10aGlzLmlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O2lmcmFtZURvY3VtZW50Lm9wZW4oKTtpZnJhbWVEb2N1bWVudC53cml0ZSh2aWV3KTtpZnJhbWVEb2N1bWVudC5jbG9zZSgpO307QUNJQy5wcm90b3R5cGUucmVtb3ZlV2hvbGVQYWdlSWZyYW1lPWZ1bmN0aW9uKCl7dmFyIF9aMj1bJ1xceDUyXFx4NjVcXHg2ZFxceDZmXFx4NzZcXHg2OVxceDZlXFx4NjdcXHgyMFxceDc3XFx4NjhcXHg2ZlxceDZjXFx4NjVcXHgyZFxceDcwXFx4NjFcXHg2N1xceDY1XFx4MjBcXHg2OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjVcXHgyMFxceDY2XFx4NzJcXHg2ZlxceDZkXFx4MjBcXHg3MFxceDYxXFx4NjdcXHg2NVxceDIxJywnXFx4NzJcXHg2NVxceDZkXFx4NmZcXHg3NlxceDY1XFx4NTdcXHg2OFxceDZmXFx4NmNcXHg2NVxceDUwXFx4NjFcXHg2N1xceDY1XFx4NDlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1JywnXFx4NjFcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MmRcXHg3N1xceDY4XFx4NmZcXHg2Y1xceDY1XFx4MmRcXHg3MFxceDYxXFx4NjdcXHg2NVxceDJkXFx4NjlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1J107dGhpcy5sb2dnZXIubG9nKF9aMlsxXSk7dmFyIGlmcmFtZT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChfWjJbMl0pO2lmKGlmcmFtZSl7dGhpcy5sb2dnZXIubG9nKF9aMlswXSk7aWZyYW1lLnJlbW92ZSgpO3RoaXMuaWZyYW1lPXVuZGVmaW5lZDt9fTtBQ0lDLnByb3RvdHlwZS5leGVjdXRlRGlzbWlzc0NhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIF8kcz1bLjc0OTQyMTM3Nzg0OTM4MjZdO3RoaXMucmVtb3ZlV2hvbGVQYWdlSWZyYW1lKCk7dmFyIF9zczIkU1p6JD1fJHNbMF07dGhpcy5jbGllbnRSZXF1ZXN0LmRpc21pc3NDYWxsYmFja0Z1bmN0aW9uKHt9KTt9O0FDSUMucHJvdG90eXBlLmV4ZWN1dGVDaGFsbGVuZ2VMb2FkQ2FsbGJhY2s9ZnVuY3Rpb24oY2hhbGxlbmdlTG9hZERhdGEpe3ZhciBfaWk9W251bGwsJ1xceDYyXFx4NDNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyXFx4NDNcXHg2MVxceDcwXFx4NzRcXHg2M1xceDY4XFx4NjEnXTtpZihjaGFsbGVuZ2VMb2FkRGF0YT09X2lpWzBdKXt0aGlzLmNsaWVudFJlcXVlc3QuY2hhbGxlbmdlTG9hZENhbGxiYWNrRnVuY3Rpb24oe2hlaWdodDonJyx3aWR0aDonJ30pO31lbHNle3ZhciBfSUlsbEwxaUk9X2lpWzFdO3RoaXMuY2xpZW50UmVxdWVzdC5jaGFsbGVuZ2VMb2FkQ2FsbGJhY2tGdW5jdGlvbih7aGVpZ2h0OmNoYWxsZW5nZUxvYWREYXRhLmZyYW1lSGVpZ2h0LHdpZHRoOmNoYWxsZW5nZUxvYWREYXRhLmZyYW1lV2lkdGh9KTt9fTtBQ0lDLnByb3RvdHlwZS5leGVjdXRlQUNJQ0NhbGxiYWNrPWZ1bmN0aW9uKGFhbWF0aW9uUmVzdWx0KXt2YXIgX09vMD1bJ1xceDY1XFx4NmNcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkJyxudWxsLCdcXHg2MlxceDZjXFx4NmZcXHg2MlxceDQzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxJywnXFx4NmZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJ107aWYoYWFtYXRpb25SZXN1bHQ9PV9PbzBbMV0pe3ZhciBfaUwxbDFJSWk9X09vMFsyXSxfbzAwUVFRb1E9X09vMFszXSxfJCR6JFpaJDI9X09vMFswXTthYW1hdGlvblJlc3VsdD1uZXcgQUFtYXRpb25SZXN1bHRfMS5BQW1hdGlvblJlc3VsdChBQ0lDLlNUQVRJQ19DTElFTlRfQ09OVEVYVCxBQ0lDLlNUQVRJQ19TRVNTSU9OX1RPS0VOLEFDSUMuU1RBVElDX0FDVElPTl9UWVBFKTt9dGhpcy5jbGllbnRSZXF1ZXN0LmNhbGxiYWNrRnVuY3Rpb24oYWFtYXRpb25SZXN1bHQpO307QUNJQy5wcm90b3R5cGUuY3JlYXRlSWZyYW1lPWZ1bmN0aW9uKCl7dmFyIF9RMD1bJ1xceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NScsJ1xceDYxXFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NzdcXHg2OFxceDZmXFx4NmNcXHg2NVxceDJkXFx4NzBcXHg2MVxceDY3XFx4NjVcXHgyZFxceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NSddO3ZhciBpZnJtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoX1EwWzBdKTtpZnJtLmlkPV9RMFsxXTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcm0pO3JldHVybiBpZnJtO307QUNJQy5wcm90b3R5cGUuc2VuZEFybm9sZEh0dHBSZXF1ZXN0PWZ1bmN0aW9uKHVybCx0aW1lb3V0LHJldHJ5VGltZXMpe3ZhciBfWlM9WzI4NjU2LCdcXHg1MFxceDRmXFx4NTNcXHg1NCcsJ1xceDYxXFx4NmVcXHg3NFxceDY5XFx4MmRcXHg2M1xceDczXFx4NzJcXHg2NlxceDc0XFx4NmZcXHg2YlxceDY1XFx4NmVcXHgyZFxceDYxXFx4MzJcXHg3YScsdHJ1ZSwnXFx4MmVcXHg3MlxceDY1XFx4NzNcXHg3MFxceDZmXFx4NmVcXHg3M1xceDY1XFx4NTRcXHg2OVxceDZkXFx4NjUnLCdcXHg3M1xceDY1XFx4NmVcXHg2NFxceDQxXFx4NzJcXHg2ZVxceDZmXFx4NmNcXHg2NFxceDQ4XFx4NzRcXHg3NFxceDcwXFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzQnLCdcXHg2M1xceDZmXFx4NmVcXHg3NFxceDY1XFx4NmVcXHg3NCcsJ1xceDQzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg2ZVxceDc0XFx4MmRcXHg1NFxceDc5XFx4NzBcXHg2NScsMjkwNTAsJ1xceDYzXFx4NzNcXHg3MlxceDY2XFx4MjBcXHg3NFxceDZmXFx4NmJcXHg2NVxceDZlXFx4M2FcXHgyMCcsJ1xceDY2XFx4NzdcXHg2M1xceDY5XFx4NmQnLCdcXHg2MVxceDcwJywnXFx4NDdcXHg0NVxceDU0JywnXFx4NjFcXHg3MFxceDcwXFx4NmNcXHg2OVxceDYzXFx4NjFcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDJmXFx4NmFcXHg3M1xceDZmXFx4NmUnLCdcXHg2ZFxceDY1XFx4NzRcXHg2MVxceDViXFx4NmVcXHg2MVxceDZkXFx4NjVcXHgzZFxceDIyXFx4NjNcXHg3M1xceDcyXFx4NjZcXHgyZFxceDc0XFx4NmZcXHg2YlxceDY1XFx4NmVcXHgyMlxceDVkJywwLC45NDExMTI5Nzk3NTY1Mzc0XTt2YXIgX3RoaXM9dGhpcztpZih0aW1lb3V0PT09dm9pZCBfWlNbMTVdKXt0aW1lb3V0PUFDSUMuREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQ7fWlmKHJldHJ5VGltZXM9PT12b2lkIF9aU1sxNV0pe3JldHJ5VGltZXM9QUNJQy5ERUZBVUxUX1JFVFJZX1RJTUVTO310aGlzLmxvZ2dlci5sb2coX1pTWzVdKTt2YXIgcmVzcG9uc2VUaW1lTWV0cmljTmFtZT1fWlNbNF07dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3QoKTtpZih0aGlzLmNsaWVudFJlcXVlc3QuY2xpZW50UmVmZXJlbmNlSWRWYWx1ZT09PV9aU1sxMV18fHRoaXMudXNlUmVxdWVzdE1ldGhvZFBvc3Qpe3hoci5vcGVuKF9aU1sxXSx1cmwsX1pTWzNdKTtyZXNwb25zZVRpbWVNZXRyaWNOYW1lPV9aU1sxXStyZXNwb25zZVRpbWVNZXRyaWNOYW1lO31lbHNle3ZhciBfME9RTzAwT289X1pTWzE2XSxfb28wUW9vMFE9X1pTWzBdLF8kJDJ6WnNTUz1fWlNbMTBdO3hoci5vcGVuKF9aU1sxMl0sdXJsLF9aU1szXSk7cmVzcG9uc2VUaW1lTWV0cmljTmFtZT1fWlNbMTJdK3Jlc3BvbnNlVGltZU1ldHJpY05hbWU7fXhoci5zZXRSZXF1ZXN0SGVhZGVyKF9aU1s3XSxfWlNbMTNdKTtpZih0aGlzLmlmcmFtZSl7dmFyIGNzcmZUb2tlblRhZz10aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKF9aU1sxNF0pO3ZhciBfSUxpbExsbEk9X1pTWzhdO2lmKGNzcmZUb2tlblRhZyl7dGhpcy5jc3JmVG9rZW49Y3NyZlRva2VuVGFnLmdldEF0dHJpYnV0ZShfWlNbNl0pO3RoaXMubG9nZ2VyLmxvZyhfWlNbOV0rdGhpcy5jc3JmVG9rZW4pO3hoci5zZXRSZXF1ZXN0SGVhZGVyKF9aU1syXSx0aGlzLmNzcmZUb2tlbik7fX14aHIudGltZW91dD10aW1lb3V0O3ZhciByZXF1ZXN0U3RhcnRUaW1lPW5ldyBEYXRlKCkudmFsdWVPZigpO3hoci5zZW5kKEpTT04uc3RyaW5naWZ5KHtjb250ZXh0OnRoaXMuZ2V0Y2xpZW50U2lkZUNvbnRleHQoKSxvcHRpb25zOkpTT04uc3RyaW5naWZ5KHRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRPcHRpb25zKSxyZXNwb25zZTpKU09OLnN0cmluZ2lmeSh0aGlzLmN1cnJlbnRVc2VyUmVzcG9uc2UpLGZ3Y2ltQmxvYjp0aGlzLmNsaWVudFJlcXVlc3QuZndjaW1CbG9iVmFsdWV9KSk7eGhyLm9uZXJyb3I9ZnVuY3Rpb24oKXt2YXIgX2xpPVsuMjExMTMzMTA0MDU3NjIzMiwnXFx4NGVcXHg2NVxceDc0XFx4NzdcXHg2ZlxceDcyXFx4NmJcXHgyMFxceDQ1XFx4NzJcXHg3MlxceDZmXFx4NzJcXHgzYVxceDIwJywwLCdcXHg2M1xceDYxXFx4NzBcXHg3NFxceDYzXFx4NjhcXHg2MScsbnVsbCwzODcxMSwnXFx4MjBcXHg3MlxceDY1XFx4NzRcXHg3MlxceDY5XFx4NjVcXHg3M1xceDIwXFx4NzJcXHg2NVxceDZkXFx4NjFcXHg2OVxceDZlXFx4NjlcXHg2ZVxceDY3XFx4MmUnLDEsJ1xceDYzXFx4NmZcXHg2Y1xceDZjXFx4NjVcXHg2M1xceDc0XFx4NmZcXHg3MlxceDQ1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0JywnXFx4NzVcXHg3M1xceDY1XFx4NzJcXHg2MVxceDY3XFx4NjVcXHg2ZVxceDc0JywnXFx4NDZcXHg2MVxceDY5XFx4NmNcXHg2NVxceDY0XFx4MjBcXHg3NFxceDZmXFx4MjBcXHg2M1xceDZmXFx4NmVcXHg2ZVxceDY1XFx4NjNcXHg3NFxceDIwXFx4NzRcXHg2ZlxceDIwXFx4NzRcXHg2OFxceDY1XFx4MjBcXHg3M1xceDY1XFx4NzJcXHg3NlxceDY1XFx4NzJcXHgyZSddO3ZhciBfTGkxTElsMUk9X2xpWzVdLF9RUVEwbzBPTz1fbGlbM10sX0xsSWxsaWxMPV9saVs5XTtpZihyZXRyeVRpbWVzPT1fbGlbMl0pe3ZhciBfb09Rb1FvUTA9X2xpWzBdLF9TeiRaMnNTcz1fbGlbOF07X3RoaXMuYWNpY0thdGFsTG9nZ2VyLmVycm9yKF9saVsxMF0seydcXHg1NVxceDUyXFx4NGMnOnVybH0pO2lmKF90aGlzLl9vbmVycm9yKXtfdGhpcy5fb25lcnJvcihuZXcgQUNJQ0Vycm9yXzEuQUNJQ0Vycm9yKCkpO31lbHNle190aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2soX2xpWzRdKTt9fWVsc2V7X3RoaXMuYWNpY0thdGFsTG9nZ2VyLmVycm9yKF9saVsxXStyZXRyeVRpbWVzK19saVs2XSx7J1xceDU1XFx4NTJcXHg0Yyc6dXJsfSk7X3RoaXMuc2VuZEFybm9sZEh0dHBSZXF1ZXN0KHVybCx1bmRlZmluZWQscmV0cnlUaW1lcy1fbGlbN10pO319O3hoci5vbnRpbWVvdXQ9ZnVuY3Rpb24oKXt2YXIgXyR6PVsnXFx4NTRcXHg2OVxceDZkXFx4NjVcXHg2ZlxceDc1XFx4NzRcXHgzYVxceDIwXFx4NzJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzRcXHgyMFxceDc0XFx4NmZcXHg2ZlxceDZiXFx4MjBcXHg2Y1xceDZmXFx4NmVcXHg2N1xceDY1XFx4NzJcXHgyMFxceDc0XFx4NjhcXHg2MVxceDZlXFx4MjBcXHg2NVxceDc4XFx4NzBcXHg2NVxceDYzXFx4NzRcXHg2NVxceDY0XFx4MmUnLG51bGxdO190aGlzLmFjaWNLYXRhbExvZ2dlci5lcnJvcihfJHpbMF0seydcXHg1NVxceDUyXFx4NGMnOnVybH0pO2lmKF90aGlzLl9vbmVycm9yKXt2YXIgX08wUVEwUVFRPWZ1bmN0aW9uKF8wUU9vUU9vbyxfMWkxTGxMSUksX09RMG9vUU8wKXt2YXIgX0lMPVszOTQyNSw0NTM2OSwyNDQwNF07dmFyIF9TJFNTenNzJD1fSUxbMl07dmFyIF9RUW8wUU9PUT1fSUxbMF07cmV0dXJuIF9JTFsxXTt9O190aGlzLl9vbmVycm9yKG5ldyBBQ0lDRXJyb3JfMS5BQ0lDRXJyb3IoKSk7fWVsc2V7X3RoaXMuZXhlY3V0ZUFDSUNDYWxsYmFjayhfJHpbMV0pO319O3hoci5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgX1NaPVsnXFx4NzNcXHg2NVxceDZlXFx4NjRcXHg0MVxceDcyXFx4NmVcXHg2ZlxceDZjXFx4NjRcXHg0OFxceDc0XFx4NzRcXHg3MFxceDUyXFx4NjVcXHg3MVxceDc1XFx4NjVcXHg3M1xceDc0J107dmFyIHJlcXVlc3RFbmRUaW1lPW5ldyBEYXRlKCkudmFsdWVPZigpO190aGlzLmFjaWNLYXRhbE1ldHJpY3NQdWJsaXNoZXIubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QoX1NaWzBdKS5wdWJsaXNoVGltZXJNb25pdG9yKHJlc3BvbnNlVGltZU1ldHJpY05hbWUscmVxdWVzdEVuZFRpbWUtcmVxdWVzdFN0YXJ0VGltZSk7dmFyIF8kWiRaMnN6JD1mdW5jdGlvbihfMWxMSUwxTDEpe3ZhciBfMFE9WydcXHg2ZlxceDYyXFx4NjZcXHg3NVxceDczXFx4NjNcXHg2MVxceDc0XFx4NjVcXHg0NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0JywnXFx4NjRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDQyXFx4NGNcXHg2OVxceDczXFx4NzQnLC44MjgwNTE4NTkyMTk2NTQyLDUxOTcsMzU3NTIsJ1xceDYzXFx4NmZcXHg2Y1xceDZjXFx4NjVcXHg2M1xceDc0XFx4NmZcXHg3MicsJ1xceDYyXFx4NDlcXHg2NFxceDRlXFx4NmZcXHg2NFxceDY1JywuMDI2ODQ1Nzg5NzE2NTkxMjRdO3ZhciBfMUlJSUlJbDE9XzBRWzFdLF8kU1paenpaJD1fMFFbM107dmFyIF9MbElJbGxpTD1fMFFbNF0sX29PUTBRMG8wPV8wUVsyXSxfT1FPME8wb289XzBRWzZdO3ZhciBfenp6JFNTWno9XzBRWzBdLF9Rb29RT1FPUT1fMFFbN107cmV0dXJuIF8wUVs1XTt9O190aGlzLnByb2Nlc3NBcm5vbGRIdHRwUmVzcG9uc2UoeGhyKTt9O307QUNJQy5wcm90b3R5cGUuZ2V0Y2xpZW50U2lkZUNvbnRleHQ9ZnVuY3Rpb24oKXt2YXIgX3paPVs0MjUxNyxudWxsLDM0NTA5LCdcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzRcXHg0NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDU1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NCcsLjA4MjI3NzY0OTUxNjM5MTVdO3ZhciBfbGxMaWlJaUk9X3paWzNdLF8xTEkxMWlMST1felpbMF07aWYodGhpcy5jdXJyZW50QUFtYXRpb25SZXN1bHQpe3ZhciBfMiQkJHoyelo9X3paWzRdLF9vUVFRT1FvUT1felpbMl07cmV0dXJuIHRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0LmNsaWVudFNpZGVDb250ZXh0VmFsdWU7fXJldHVybiBfelpbMV07fTtBQ0lDLnByb3RvdHlwZS5wcm9jZXNzQXJub2xkSHR0cFJlc3BvbnNlPWZ1bmN0aW9uKHhocil7dmFyIF9aJD1bJ1xceDJlJywnXFx4NDhcXHg1NFxceDU0XFx4NTBcXHgyMFxceDQ1XFx4NzJcXHg3MlxceDZmXFx4NzJcXHgyMCcsMjAwLG51bGwsJ1xceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjVcXHg0OFxceDY1XFx4NjFcXHg2NFxceDY1XFx4NzJcXHgyMFxceDY5XFx4NzNcXHgyMFxceDZlXFx4NzVcXHg2Y1xceDZjXFx4MmUnLC43NTIwNjIxMjY3NDQzOTk0LDE0NDc5LDQ0MDc5LCdcXHg3MFxceDcyXFx4NmZcXHg2M1xceDY1XFx4NzNcXHg3M1xceDQxXFx4NzJcXHg2ZVxceDZmXFx4NmNcXHg2NFxceDQ4XFx4NzRcXHg3NFxceDcwXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NSddO3RoaXMubG9nZ2VyLmxvZyhfWiRbOF0pO3ZhciBzdGF0dXM9eGhyLnN0YXR1czt2YXIgX3paUzIyU3NaPV9aJFs2XSxfbGxsbGxpbDE9X1okWzVdO3RoaXMubG9nZ2VyLmxvZyhzdGF0dXMpO2lmKHN0YXR1cyE9X1okWzJdKXt0aGlzLmFjaWNLYXRhbExvZ2dlci5lcnJvcihfWiRbMV0rc3RhdHVzK19aJFswXSx7J1xceDUzXFx4NzRcXHg2MVxceDc0XFx4NzVcXHg3Myc6eGhyLnN0YXR1c1RleHR9KTt0aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2soX1okWzNdKTt9ZWxzZXt2YXIgYWFtYXRpb25SZXN1bHQ9dGhpcy5hZGRSZXN1bHQoeGhyLmdldFJlc3BvbnNlSGVhZGVyKEFDSUMuQUFNQVRJT05fU0VSVklDRV9SRVNQT05TRV9IRUFERVIpKTt0aGlzLmxvZ2dlci5sb2coYWFtYXRpb25SZXN1bHQpO2lmKCFhYW1hdGlvblJlc3VsdCl7dGhpcy5hY2ljS2F0YWxMb2dnZXIuZXJyb3IoX1okWzRdLHsnXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NVxceDU1XFx4NTJcXHg0Yyc6eGhyLnJlc3BvbnNlVVJMLCdcXHg1MlxceDY1XFx4NzNcXHg3MFxceDZmXFx4NmVcXHg3M1xceDY1XFx4NTRcXHg2NVxceDc4XFx4NzQnOiEheGhyLnJlc3BvbnNlVGV4dCwnXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NVxceDQ4XFx4NjVcXHg2MVxceDY0XFx4NjVcXHg3Mic6eGhyLmdldFJlc3BvbnNlSGVhZGVyKEFDSUMuQUFNQVRJT05fU0VSVklDRV9SRVNQT05TRV9IRUFERVIpfSk7dmFyIF9pbDFpaWxMMT1mdW5jdGlvbihfb29RMG8wMG8sX3pTcyRTenoyLF8xMUlMSUxsSSl7dmFyIF9PUT1bLjg4NTQ5MzUxNTEyMDU4MTgsLjM1NjMxNTQwODMzMTIxMjM0LCdcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDQ1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1JywnXFx4NmNcXHg2OVxceDczXFx4NzRcXHg0MlxceDZmXFx4NjRcXHg3OSddO3ZhciBfUyRTJFNaWno9X09RWzJdLF9saTFpMTFJbD1fT1FbM10sX09vMFFPTzBvPV9PUVsxXTtyZXR1cm4gX09RWzBdO307dGhpcy5leGVjdXRlQUNJQ0NhbGxiYWNrKF9aJFszXSk7fWVsc2UgaWYoYWFtYXRpb25SZXN1bHQuYWN0aW9uVHlwZVZhbHVlPT1BQ0lDLkFBTUFUSU9OX1BBU1NfQUNUSU9OX1RZUEUpe3RoaXMuZXhlY3V0ZUFDSUNDYWxsYmFjayhhYW1hdGlvblJlc3VsdCk7fWVsc2UgaWYodGhpcy5tb2RlJiZBQ0lDLkRFVEVDVElPTl9PTkxZX01PREVMPT09dGhpcy5tb2RlKXt2YXIgX1pTJFN6MnpaPV9aJFs3XTt0aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2soYWFtYXRpb25SZXN1bHQpO31lbHNle3ZhciB2aWV3PXhoci5yZXNwb25zZVRleHQ7dmFyIF9JbElpaWlsaT1mdW5jdGlvbihfbDFsaTFpTEksX2xJMWlpTExsKXt2YXIgXzBPPVsuNDMwMzI4ODU5MjUzNDE3MzUsLjAwMTE5ODc3NTkxNDk0MDc3NSwuMzg1NzY2NTkwMzg5MDk3MiwxNjkxLCdcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0OFxceDYxXFx4NzNcXHg2OCddO3ZhciBfMFEwMFFRMDA9XzBPWzNdO3ZhciBfc3MkWloyMiQ9XzBPWzJdLF9sMUwxMUlMST1fME9bMF0sXzFpMWxpMUxpPV8wT1s0XTtyZXR1cm4gXzBPWzFdO307dGhpcy5sb2FkQ2hhbGxlbmdlVmlldyh2aWV3KTt9fX07QUNJQy5ERUZBVUxUX1JFUVVFU1RfVElNRU9VVD1fTDFbOF07QUNJQy5ERUZBVUxUX1JFVFJZX1RJTUVTPV9MMVs1XTtBQ0lDLkFBTUFUSU9OX1NFUlZJQ0VfUkVTUE9OU0VfSEVBREVSPV9MMVs3XTtBQ0lDLkFBTUFUSU9OX1BBU1NfQUNUSU9OX1RZUEU9X0wxWzEwXTtBQ0lDLlNFUlZJQ0VfQkFTRV9QQVRIPV9MMVsxXTtBQ0lDLlNUQVRJQ19DTElFTlRfQ09OVEVYVD1fTDFbNF07QUNJQy5TVEFUSUNfU0VTU0lPTl9UT0tFTj1fTDFbMl07QUNJQy5TVEFUSUNfQUNUSU9OX1RZUEU9X0wxWzEwXTtBQ0lDLkRFVEVDVElPTl9PTkxZX01PREVMPV9MMVs5XTtBQ0lDLktBVEFMX01FVFJJQ1NfU0VSVklDRV9OQU1FPV9MMVs2XTtyZXR1cm4gQUNJQzt9KCk7ZXhwb3J0cy5BQ0lDPUFDSUM7IiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2lmcmFtZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIidcXHg3NVxceDczXFx4NjVcXHgyMFxceDczXFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3NCc7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJ1xceDVmXFx4NWZcXHg2NVxceDczXFx4NGRcXHg2ZlxceDY0XFx4NzVcXHg2Y1xceDY1Jyx7dmFsdWU6dHJ1ZX0pO3ZhciBBQW1hdGlvblJlc3VsdD1mdW5jdGlvbigpe3ZhciBfT09PPVsnXFx4NjFcXHg2M1xceDc0XFx4NjlcXHg2ZlxceDZlXFx4NTRcXHg3OVxceDcwXFx4NjVcXHg1NlxceDYxXFx4NmNcXHg3NVxceDY1JywnXFx4NzNcXHg2NVxceDczXFx4NzNcXHg2OVxceDZmXFx4NmVcXHg1NFxceDZmXFx4NmJcXHg2NVxceDZlXFx4NTZcXHg2MVxceDZjXFx4NzVcXHg2NScsJ1xceDYzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDUzXFx4NjlcXHg2NFxceDY1XFx4NDNcXHg2ZlxceDZlXFx4NzRcXHg2NVxceDc4XFx4NzRcXHg1NlxceDYxXFx4NmNcXHg3NVxceDY1Jyx0cnVlXTt2YXIgX3pzWjIkc3paPWZ1bmN0aW9uKF8xMWlpMTFsMSxfWnpzMjJaMnope3ZhciBfMDBRPVsuMzg2NTgyMDczMDk3MTgxNCwnXFx4NjFcXHg0MlxceDZjXFx4NmZcXHg2MicsLjM4OTc4NzU2NjUwODAwMDQsJ1xceDY0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0MlxceDZmXFx4NjRcXHg3OSddO3ZhciBfMnNTMiRTJDI9XzAwUVsyXSxfbElJaUkxMWk9XzAwUVswXSxfUVEwb09vMG89XzAwUVszXTtyZXR1cm4gXzAwUVsxXTt9O2Z1bmN0aW9uIEFBbWF0aW9uUmVzdWx0KGNsaWVudFNpZGVDb250ZXh0LHNlc3Npb25Ub2tlbixhY3Rpb25UeXBlKXt0aGlzLmNsaWVudFNpZGVDb250ZXh0PWNsaWVudFNpZGVDb250ZXh0O3RoaXMuc2Vzc2lvblRva2VuPXNlc3Npb25Ub2tlbjt0aGlzLmFjdGlvblR5cGU9YWN0aW9uVHlwZTt9T2JqZWN0LmRlZmluZVByb3BlcnR5KEFBbWF0aW9uUmVzdWx0LnByb3RvdHlwZSxfT09PWzJdLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgX29Pbz1bXTtyZXR1cm4gdGhpcy5jbGllbnRTaWRlQ29udGV4dDt9LGVudW1lcmFibGU6X09PT1szXSxjb25maWd1cmFibGU6X09PT1szXX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQW1hdGlvblJlc3VsdC5wcm90b3R5cGUsX09PT1sxXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9TJHM9W107dmFyIF9RTzBRb09Pbz1mdW5jdGlvbihfb29PT08wTzAsX08wTzBPT09vKXt2YXIgX3NaMj1bJ1xceDYyXFx4NmNcXHg2ZlxceDYyJywnXFx4NjhcXHg2MVxceDczXFx4NjhcXHg0YVxceDczXFx4NmZcXHg2ZScsMjYxNzVdO3ZhciBfME9PT09RUW89X3NaMlsyXSxfJDIkWjJTMlM9X3NaMlswXTtyZXR1cm4gX3NaMlsxXTt9O3JldHVybiB0aGlzLnNlc3Npb25Ub2tlbjt9LGVudW1lcmFibGU6X09PT1szXSxjb25maWd1cmFibGU6X09PT1szXX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQW1hdGlvblJlc3VsdC5wcm90b3R5cGUsX09PT1swXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9sMT1bXTt2YXIgX0xJMWkxbGxpPWZ1bmN0aW9uKF8wTzBRb08wUSl7dmFyIF9sMWk9WzEwMjc3LCdcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg1M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0NVxceDZjJywnXFx4NjJcXHg2ZlxceDY0XFx4NzknLDQ3OTkyLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDQ1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1J107dmFyIF96U3okJCQkej1fbDFpWzRdLF9Pb29vTzBRUT1fbDFpWzNdLF9RT29PME8wbz1fbDFpWzBdO3ZhciBfb1EwMDBvT1E9X2wxaVsyXTtyZXR1cm4gX2wxaVsxXTt9O3JldHVybiB0aGlzLmFjdGlvblR5cGU7fSxlbnVtZXJhYmxlOl9PT09bM10sY29uZmlndXJhYmxlOl9PT09bM119KTtyZXR1cm4gQUFtYXRpb25SZXN1bHQ7fSgpO2V4cG9ydHMuQUFtYXRpb25SZXN1bHQ9QUFtYXRpb25SZXN1bHQ7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEFDSUNDbGllbnRSZXF1ZXN0PWZ1bmN0aW9uKCl7dmFyIF9aJFM9WydcXHg2NlxceDc3XFx4NjNcXHg2OVxceDZkXFx4NDJcXHg2Y1xceDZmXFx4NjJcXHg1NlxceDYxXFx4NmNcXHg3NVxceDY1JywnXFx4NjNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NGZcXHg3MFxceDc0XFx4NjlcXHg2ZlxceDZlXFx4NzMnLHRydWUsLjQ2OTMxMzQ3NjU4Nzk5ODUsbnVsbCwnXFx4NzVcXHg3M1xceDY1XFx4NzJcXHg0Y1xceDYxXFx4NmVcXHg2N1xceDc1XFx4NjFcXHg2N1xceDY1JyxmYWxzZSwnXFx4NjNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NTJcXHg2NVxceDY2XFx4NjVcXHg3MlxceDY1XFx4NmVcXHg2M1xceDY1XFx4NDlcXHg2NFxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLCdcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHg1NFxceDc5XFx4NzBcXHg2NVxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLCdcXHg2M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiXFx4NDZcXHg3NVxceDZlXFx4NjNcXHg3NFxceDY5XFx4NmZcXHg2ZScsJ1xceDY0XFx4NjlcXHg3M1xceDZkXFx4NjlcXHg3M1xceDczXFx4NDNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDQ2XFx4NzVcXHg2ZVxceDYzXFx4NzRcXHg2OVxceDZmXFx4NmUnLCdcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHg0Y1xceDZmXFx4NjFcXHg2NFxceDQzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmJcXHg0NlxceDc1XFx4NmVcXHg2M1xceDc0XFx4NjlcXHg2ZlxceDZlJ107ZnVuY3Rpb24gQUNJQ0NsaWVudFJlcXVlc3QoY2xpZW50UmVmZXJlbmNlSWQsY2FsbGJhY2ssZGlzbWlzc0NhbGxiYWNrLGNoYWxsZW5nZUxvYWRDYWxsYmFjayxjbGllbnREYXRhLGxvY2FsZSxmd2NpbUJsb2IsZXh0ZXJuYWxJZCxlbmFibGVIZWFkZXJGb290ZXIsZW5hYmxlQnlwYXNzTWVjaGFuaXNtLGVuYWJsZU1vZGFsVmlldyxjaGFsbGVuZ2VUeXBlLG1vZGUsZXZlbnRUcmlnZ2VyLGFhRXh0ZXJuYWxUb2tlbixmb3JjZUpzRmx1c2gpe3RoaXMuY2xpZW50UmVmZXJlbmNlSWQ9Y2xpZW50UmVmZXJlbmNlSWQ7dGhpcy5jYWxsYmFjaz1jYWxsYmFjazt0aGlzLmRpc21pc3NDYWxsYmFjaz1kaXNtaXNzQ2FsbGJhY2t8fHRoaXMuZGVmYXVsdERpc21pc3NDYWxsYmFjazt0aGlzLmNoYWxsZW5nZUxvYWRDYWxsYmFjaz1jaGFsbGVuZ2VMb2FkQ2FsbGJhY2t8fHRoaXMuZGVmYXVsdENoYWxsZW5nZUxvYWRDYWxsYmFjazt0aGlzLmNsaWVudERhdGE9Y2xpZW50RGF0YXx8X1okU1s0XTt0aGlzLmV4dGVybmFsSWQ9ZXh0ZXJuYWxJZHx8X1okU1s0XTt0aGlzLmxvY2FsZT1sb2NhbGV8fG5hdmlnYXRvci5sYW5ndWFnZXx8d2luZG93Lm5hdmlnYXRvcltfWiRTWzVdXTt0aGlzLmZ3Y2ltQmxvYj1md2NpbUJsb2J8fF9aJFNbNF07dGhpcy5lbmFibGVIZWFkZXJGb290ZXI9ZW5hYmxlSGVhZGVyRm9vdGVyPT1fWiRTWzZdP2VuYWJsZUhlYWRlckZvb3RlcjpfWiRTWzJdO3RoaXMuZW5hYmxlQnlwYXNzTWVjaGFuaXNtPWVuYWJsZUJ5cGFzc01lY2hhbmlzbT09X1okU1syXT9lbmFibGVCeXBhc3NNZWNoYW5pc206X1okU1s2XTt0aGlzLmVuYWJsZU1vZGFsVmlldz1lbmFibGVNb2RhbFZpZXc9PV9aJFNbMl0/ZW5hYmxlTW9kYWxWaWV3Ol9aJFNbNl07dGhpcy5jaGFsbGVuZ2VUeXBlPWNoYWxsZW5nZVR5cGV8fF9aJFNbNF07dGhpcy5tb2RlPW1vZGV8fF9aJFNbNF07dGhpcy5ldmVudFRyaWdnZXI9ZXZlbnRUcmlnZ2VyfHxfWiRTWzRdO3RoaXMuYWFFeHRlcm5hbFRva2VuPWFhRXh0ZXJuYWxUb2tlbnx8X1okU1s0XTt0aGlzLmZvcmNlSnNGbHVzaD1mb3JjZUpzRmx1c2g9PV9aJFNbMl0/Zm9yY2VKc0ZsdXNoOl9aJFNbNl07fUFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZWZhdWx0RGlzbWlzc0NhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIF9aWlo9WydcXHg0NFxceDY5XFx4NzNcXHg2ZFxceDY5XFx4NzNcXHg3M1xceDIwXFx4NjNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDIwXFx4NmVcXHg2ZlxceDc0XFx4MjBcXHg3M1xceDcwXFx4NjVcXHg2M1xceDY5XFx4NjZcXHg2OVxceDY1XFx4NjQnLG51bGxdO2NvbnNvbGUubG9nKF9aWlpbMF0pO3JldHVybiBfWlpaWzFdO307QUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlZmF1bHRDaGFsbGVuZ2VMb2FkQ2FsbGJhY2s9ZnVuY3Rpb24oKXt2YXIgXzJ6cz1bbnVsbCwnXFx4NjZcXHg3N1xceDYzXFx4NjlcXHg2ZFxceDQ5XFx4NjQnLDU1MjgsJ1xceDQzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDIwXFx4NjNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDIwXFx4NmVcXHg2ZlxceDc0XFx4MjBcXHg3M1xceDcwXFx4NjVcXHg2M1xceDY5XFx4NjZcXHg2OVxceDY1XFx4NjRcXHgyMFxceDY2XFx4NmZcXHg3MlxceDIwXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg3MFxceDYxXFx4NjdcXHg2NSddO3ZhciBfbExMbGkxMWk9XzJ6c1sxXSxfcyRTc1NTJCQ9XzJ6c1syXTtjb25zb2xlLmxvZyhfMnpzWzNdKTtyZXR1cm4gXzJ6c1swXTt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUsX1okU1s3XSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF8xTD1bXTtyZXR1cm4gdGhpcy5jbGllbnRSZWZlcmVuY2VJZDt9LGVudW1lcmFibGU6X1okU1syXSxjb25maWd1cmFibGU6X1okU1syXX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUsX1okU1swXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9zWj1bXTtyZXR1cm4gdGhpcy5md2NpbUJsb2I7fSxlbnVtZXJhYmxlOl9aJFNbMl0sY29uZmlndXJhYmxlOl9aJFNbMl19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9aJFNbOV0se2dldDpmdW5jdGlvbigpe3ZhciBfWnM9W107cmV0dXJuIHRoaXMuY2FsbGJhY2s7fSxlbnVtZXJhYmxlOl9aJFNbMl0sY29uZmlndXJhYmxlOl9aJFNbMl19KTt2YXIgX3oyMlMyUyR6PV9aJFNbM107T2JqZWN0LmRlZmluZVByb3BlcnR5KEFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZSxfWiRTWzEwXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9paUxpPVtdO3ZhciBfb1FPUTBPME89ZnVuY3Rpb24oX1FRb29PT1FvLF9aWlNzJHNTcyl7dmFyIF96Uz1bMzk3NzQsJ1xceDY0XFx4NmZcXHg2ZFxceDRmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NVxceDQ1XFx4NmMnLCdcXHg2OFxceDYxXFx4NzNcXHg2OCcsMjYzODUsJ1xceDZlXFx4NmZcXHg2NFxceDY1XFx4NDRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDQ1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1JywnXFx4NjJcXHg2Y1xceDZmXFx4NjJcXHg0NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0J107dmFyIF8yU3okU1NzJD1felNbM10sXzFJbGwxSTFMPV96U1swXTt2YXIgX1pTMjJ6WnpzPV96U1s1XSxfMnokJCR6eiQ9X3pTWzJdO3ZhciBfbDFsbExsMWk9X3pTWzFdO3JldHVybiBfelNbNF07fTtyZXR1cm4gdGhpcy5kaXNtaXNzQ2FsbGJhY2s7fSxlbnVtZXJhYmxlOl9aJFNbMl0sY29uZmlndXJhYmxlOl9aJFNbMl19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9aJFNbMTFdLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgX29PTz1bJ1xceDY5XFx4NjRcXHg0NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0J107dmFyIF8xbEwxaTFpTD1fb09PWzBdO3JldHVybiB0aGlzLmNoYWxsZW5nZUxvYWRDYWxsYmFjazt9LGVudW1lcmFibGU6X1okU1syXSxjb25maWd1cmFibGU6X1okU1syXX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUsX1okU1sxXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9vT09PPVtdO3JldHVybntjbGllbnREYXRhOnRoaXMuY2xpZW50RGF0YSxjaGFsbGVuZ2VUeXBlOnRoaXMuY2hhbGxlbmdlVHlwZSxsb2NhbGU6dGhpcy5sb2NhbGUsZXh0ZXJuYWxJZDp0aGlzLmV4dGVybmFsSWQsZW5hYmxlSGVhZGVyRm9vdGVyOnRoaXMuZW5hYmxlSGVhZGVyRm9vdGVyLGVuYWJsZUJ5cGFzc01lY2hhbmlzbTp0aGlzLmVuYWJsZUJ5cGFzc01lY2hhbmlzbSxlbmFibGVNb2RhbFZpZXc6dGhpcy5lbmFibGVNb2RhbFZpZXcsZXZlbnRUcmlnZ2VyOnRoaXMuZXZlbnRUcmlnZ2VyLGFhRXh0ZXJuYWxUb2tlbjp0aGlzLmFhRXh0ZXJuYWxUb2tlbixmb3JjZUpzRmx1c2g6dGhpcy5mb3JjZUpzRmx1c2h9O30sZW51bWVyYWJsZTpfWiRTWzJdLGNvbmZpZ3VyYWJsZTpfWiRTWzJdfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZSxfWiRTWzhdLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgX2lJaT1bJ1xceDY1XFx4NmNcXHg0NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NScsMjkxNzddO3ZhciBfaTFpSTFsaWw9X2lJaVswXSxfUU9vUVFvUVE9X2lJaVsxXTtyZXR1cm4gdGhpcy5jaGFsbGVuZ2VUeXBlO30sc2V0OmZ1bmN0aW9uKGNoYWxsZW5nZVR5cGUpe3ZhciBfUTBvPVtdO3ZhciBfTGwxaUlMMWw9ZnVuY3Rpb24oXzBvTzBRTzBPLF9zc1okWnN6eil7dmFyIF8ycz1bLjYzMjg4ODQwNTUzNTQxNiwxNTE5MiwuNTUxMzM4MDk3NDM2NTQ1OCwnXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjVcXHg0MlxceDZmXFx4NjRcXHg3OSddO3ZhciBfUVEwT09PbzA9XzJzWzFdLF8wUVFPT29RMD1fMnNbMl0sX1NzMnokJFN6PV8yc1szXTtyZXR1cm4gXzJzWzBdO307dGhpcy5jaGFsbGVuZ2VUeXBlPWNoYWxsZW5nZVR5cGU7fSxlbnVtZXJhYmxlOl9aJFNbMl0sY29uZmlndXJhYmxlOl9aJFNbMl19KTtyZXR1cm4gQUNJQ0NsaWVudFJlcXVlc3Q7fSgpO2V4cG9ydHMuQUNJQ0NsaWVudFJlcXVlc3Q9QUNJQ0NsaWVudFJlcXVlc3Q7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEFDSUNFcnJvcj1mdW5jdGlvbigpe3ZhciBfU1pzPVsxMDQxOSwzNjY3LC4yMTMyOTI3NjM1NTk1MjMyXTtmdW5jdGlvbiBBQ0lDRXJyb3IoKXt9dmFyIF9paTFMMUxJST1fU1pzWzJdLF9PT09RME9Pbz1fU1pzWzBdLF8xMTFMTDFMbD1fU1pzWzFdO3JldHVybiBBQ0lDRXJyb3I7fSgpO2V4cG9ydHMuQUNJQ0Vycm9yPUFDSUNFcnJvcjsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgQUNJQ1Nlc3Npb25Db250ZXh0PWZ1bmN0aW9uKCl7dmFyIF9TJHo9W107ZnVuY3Rpb24gQUNJQ1Nlc3Npb25Db250ZXh0KCl7dGhpcy5hYW1hdGlvblJlc3VsdHM9W107dGhpcy51c2VyUmVzcG9uc2VzPVtdO31BQ0lDU2Vzc2lvbkNvbnRleHQucHJvdG90eXBlLmFkZFJlc3BvbnNlPWZ1bmN0aW9uKHJlc3BvbnNlKXt2YXIgX2xJPVsuOTY5MTgyOTI0ODE0MTA4LCdcXHg2NFxceDZmXFx4NmQnLC4yOTI5MzU1Nzk1MzYyMjk0XTt2YXIgX1FRMG9Rb09RPV9sSVsyXSxfc1NTWnpTWjI9X2xJWzBdLF96enMyU3oyJD1fbElbMV07dGhpcy51c2VyUmVzcG9uc2VzLnB1c2gocmVzcG9uc2UpO307QUNJQ1Nlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hZGRSZXN1bHQ9ZnVuY3Rpb24ocmVzdWx0KXt2YXIgX3NzPVsuNDA5MzI5Mjg0MzE2NjI2OTYsNDAzODIsLjk0Mjc2NjU1MjQ3MjUyMDZdO3ZhciBfWnMyWiR6UyQ9X3NzWzFdLF9TWnpzcyRzWj1fc3NbMl0sX1FRME9PUTAwPV9zc1swXTt0aGlzLmFhbWF0aW9uUmVzdWx0cy5wdXNoKHJlc3VsdCk7fTt2YXIgX28wT1FRMDBRPWZ1bmN0aW9uKF8kc3NaMjJ6Mil7dmFyIF8kc1M9WzQzNjI2LC4yNzYyNTYwMjUyMDY2NjI4LDQ2MzA4XTt2YXIgX09Pb09RUTBRPV8kc1NbMV0sX3MkWjIyeiRTPV8kc1NbMl07cmV0dXJuIF8kc1NbMF07fTtyZXR1cm4gQUNJQ1Nlc3Npb25Db250ZXh0O30oKTtleHBvcnRzLkFDSUNTZXNzaW9uQ29udGV4dD1BQ0lDU2Vzc2lvbkNvbnRleHQ7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEFDSUNVc2VyUmVzcG9uc2U9ZnVuY3Rpb24oKXt2YXIgX2xpaT1bXTtmdW5jdGlvbiBBQ0lDVXNlclJlc3BvbnNlKGNoYWxsZW5nZVR5cGUsZGF0YSl7dmFyIF9JaWxpaUxpMT1mdW5jdGlvbihfWjIkWlpzJFMpe3ZhciBfT1FRPVsuNjI5NzUyOTM4NzQxNTA5NywuMzM2MjY5MjYzMjc4NDEzNDRdO3ZhciBfbGwxbGxpTGk9X09RUVswXTtyZXR1cm4gX09RUVsxXTt9O3RoaXMuY2hhbGxlbmdlVHlwZT1jaGFsbGVuZ2VUeXBlO3RoaXMuZGF0YT1kYXRhO31yZXR1cm4gQUNJQ1VzZXJSZXNwb25zZTt9KCk7ZXhwb3J0cy5BQ0lDVXNlclJlc3BvbnNlPUFDSUNVc2VyUmVzcG9uc2U7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIGFjaWNfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjFcXHg2M1xceDY5XFx4NjMnKTt2YXIga2F0YWxfbG9nZ2VyXzE9cmVxdWlyZSgnXFx4NDBcXHg2MVxceDZkXFx4N2FcXHg2ZVxceDJmXFx4NmJcXHg2MVxceDc0XFx4NjFcXHg2Y1xceDJkXFx4NmNcXHg2ZlxceDY3XFx4NjdcXHg2NVxceDcyJyk7dmFyIEthdGFsRW5kcG9pbnRSZXNvbHZlcl8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg0YlxceDYxXFx4NzRcXHg2MVxceDZjXFx4NDVcXHg2ZVxceDY0XFx4NzBcXHg2ZlxceDY5XFx4NmVcXHg3NFxceDUyXFx4NjVcXHg3M1xceDZmXFx4NmNcXHg3NlxceDY1XFx4NzInKTtpZighU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKXtjb25zb2xlLmxvZygnXFx4NDFcXHg2NFxceDY0XFx4NjlcXHg2ZVxceDY3XFx4MjBcXHg3MFxceDZmXFx4NmNcXHg3OVxceDY2XFx4NjlcXHg2Y1xceDZjXFx4MjBcXHg2NlxceDZmXFx4NzJcXHgyMFxceDczXFx4NzRcXHg2MVxceDcyXFx4NzRcXHg3M1xceDU3XFx4NjlcXHg3NFxceDY4Jyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsJ1xceDczXFx4NzRcXHg2MVxceDcyXFx4NzRcXHg3M1xceDU3XFx4NjlcXHg3NFxceDY4Jyx7dmFsdWU6ZnVuY3Rpb24oc2VhcmNoLHJhd1Bvcyl7dmFyIF9JST1bMF07dmFyIHBvcz1yYXdQb3M+X0lJWzBdP3Jhd1Bvc3xfSUlbMF06X0lJWzBdO3JldHVybiB0aGlzLnN1YnN0cmluZyhwb3MscG9zK3NlYXJjaC5sZW5ndGgpPT09c2VhcmNoO319KTt9aWYoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpe2NvbnNvbGUubG9nKCdcXHg0MVxceDY0XFx4NjRcXHg2OVxceDZlXFx4NjdcXHgyMFxceDcwXFx4NmZcXHg2Y1xceDc5XFx4NjZcXHg2OVxceDZjXFx4NmNcXHgyMFxceDY2XFx4NmZcXHg3MlxceDIwXFx4NjVcXHg2ZVxceDY0XFx4NzNcXHg1N1xceDY5XFx4NzRcXHg2OCcpO1N0cmluZy5wcm90b3R5cGUuZW5kc1dpdGg9ZnVuY3Rpb24oc2VhcmNoLHRoaXNfbGVuKXt2YXIgX3MyPVtdO3ZhciBfSTFpTElMMUk9ZnVuY3Rpb24oX29PME9RTzBvKXt2YXIgX1N6PVsnXFx4NjJcXHg2Y1xceDZmXFx4NjJcXHg0NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDU1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NCcsMjc3NDcsJ1xceDY4XFx4NjFcXHg3M1xceDY4XFx4NDhcXHg2MVxceDczXFx4NjhcXHg1M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzQnLDI3NjA1LDIzMTYzXTt2YXIgX2lJTEwxSTFJPV9TelszXTt2YXIgX1paU3Myc1okPV9TelsyXSxfTExJMUlMaTE9X1N6WzBdO3ZhciBfMWlMTGxMTGw9X1N6WzRdO3JldHVybiBfU3pbMV07fTtpZih0aGlzX2xlbj09PXVuZGVmaW5lZHx8dGhpc19sZW4+dGhpcy5sZW5ndGgpe3RoaXNfbGVuPXRoaXMubGVuZ3RoO31yZXR1cm4gdGhpcy5zdWJzdHJpbmcodGhpc19sZW4tc2VhcmNoLmxlbmd0aCx0aGlzX2xlbik9PT1zZWFyY2g7fTt9dmFyIGFjaWNLYXRhbExvZ2dlcj1uZXcga2F0YWxfbG9nZ2VyXzEuZGVmYXVsdCh7dXJsOkthdGFsRW5kcG9pbnRSZXNvbHZlcl8xLkthdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRLYXRhbExvZ2dlckVuZHBvaW50KCl9KTthY2ljS2F0YWxMb2dnZXIuYWRkRXJyb3JMaXN0ZW5lcihmdW5jdGlvbihlcnJvcil7dmFyIF9Pbz1bdHJ1ZV07cmV0dXJuIF9Pb1swXTt9KTt2YXIgYWNpYz1uZXcgYWNpY18xLkFDSUMoYWNpY0thdGFsTG9nZ2VyKTt3aW5kb3cuYWNpYz1hY2ljOyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=
/////////////////////////
// END FILE js/acic.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/register-acic.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
if (P && P.AUI_BUILD_DATE) {
    P.when('A', 'ready').register('acic-component', function(A) {
        return;
    });
}
/////////////////////////
// END FILE js/register-acic.js
/////////////////////////

// END ASSET ACICAssets-1.0.17481.0
}));
////////////////////////////////////////////